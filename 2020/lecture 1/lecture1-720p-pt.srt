0
00: 00: 00.000 -> 00: 00: 00.994


1
00: 00: 00,994 -> 00: 00: 03.976
[MÚSICA, TOCANDO]

2
00: 00: 03,976 -> 00: 01: 23.496


3
00: 01: 23,496 -> 00: 01: 27.907
DAVID MALAN: Muito bem, este é o CS50, e este é um dia muito emocionante,

4
00: 01: 27,907 -> 00: 01: 29.990
porque hoje vamos aprender um nova linguagem.

5
00: 01: 29,990 -> 00: 01: 33.020
E isso não é algo que você pode dizer que acontece com você todos os dias.

6
00: 01: 33,020 -> 00: 01: 35.810
E essa linguagem vai se parecer um pouco com isso.

7
00: 01: 35,810 -> 00: 01: 37.220
Hoje, apresentamos C -

8
00: 01: 37,220 -> 00: 01: 41.690
uma linguagem muito tradicional, muito antiga, puramente baseada em texto,

9
00: 01: 41,690 -> 00: 01: 45.230
mas pode fazer tudo o que você pode fazer no Scratch e ainda mais,

10
00: 01: 45,230 -> 00: 01: 47.810
mas sem a interface amigável que estávamos

11
00: 01: 47,810 -> 00: 01: 49.370
acostumados nos últimos dias.

12
00: 01: 49,370 -> 00: 01: 52.490
Embora, no entanto isso possa parecer muito enigmático para você à primeira vista,

13
00: 01: 52,490 -> 00: 01: 55.280
mesmo que haja algumas palavras em inglês ou parecidas com o inglês nisso,

14
00: 01: 55,280 -> 00: 01: 58.200
tenha certeza de que dentro de alguns dias, certamente dentro de algumas semanas,

15
00: 01: 58,200 -> 00: 02: 00.658
você será capaz de entender cada caractere nesta tela,

16
00: 02: 00,658 -> 00: 02: 02.520
cada linha de código e muito mais.

17
00: 02: 02,520 -> 00: 02: 06.157
Mas ouso dizer que qualquer curso como este pode ser um pouco assustador, especialmente

18
00: 02: 06,157 -> 00: 02: 07.490
se você não tem experiência anterior.

19
00: 02: 07,490 -> 00: 02: 10.759
Mas lembre-se da semana passada, de que, de fato, a norma, o caso comum

20
00: 02: 10,759 -> 00: 02: 13.490
2/3 dos alunos do CS50 - talvez você entre eles -

21
00: 02: 13,490 -> 00: 02: 16.250
nunca fizeram um curso de ciência da computação antes.

22
00: 02: 16,250 -> 00: 02: 21.462
Então, o que parece assim hoje, perceba, será exatamente assim no final das contas.

23
00: 02: 21,462 -> 00: 02: 24.170
Na verdade, embora o código pareça diferente - opa.

24
00: 02: 24,170 -> 00: 02: 25.670
Mesmo que o código pareça diferente,

25
00: 02: 25,670 -> 00: 02: 27.830
as ideias hoje serão absolutamente

26
00: 02: 27,830 -> 00: 02: 30.410
as mesmas da semana passada no Scratch.

27
00: 02: 30,410 -> 00: 02: 33.500
Veremos funções e condições e expressões booleanas, loops,

28
00: 02: 33,500 -> 00: 02: 35.390
e outros recursos ao longo do caminho.

29
00: 02: 35,390 -> 00: 02: 37.800
Mas talvez me remeta a este maravilhoso hack do MIT

30
00: 02: 37,800 -> 00: 02: 42.350
em 1991, uma expressão do MIT, é de que, ter uma educação do MIT

31
00: 02: 42,350 -> 00: 02: 44.630
é como beber água de uma mangueira de incêndio.

32
00: 02: 44,630 -> 00: 02: 46.910
E no espírito dos hacks do MIT, como são chamados,

33
00: 02: 46,910 -> 00: 02: 51.140
alguns alunos conectaram uma mangueira de incêndio real a uma fonte de água real

34
00: 02: 51,140 -> 00: 02: 53.480
com uma placa na parede que diz exatamente isso.

35
00: 02: 53,480 -> 00: 02: 56.240
E este é o tipo de curso, como acontece com muitos cursos introdutórios,

36
00: 02: 56,240 -> 00: 02: 58.990
onde parece que você está realmente sendo atingido no rosto com muitas

37
00: 02: 58,990 -> 00: 03: 04.010
informações, muito mais idéias do que você pode carregar de uma vez.

38
00: 03: 04,010 -> 00: 03: 09.652
Mas perceba que você será capaz de absorver ainda mais material com o tempo.

39
00: 03: 09,652 -> 00: 03: 11.360
E o objetivo da aula, em última análise, é

40
00: 03: 11,360 -> 00: 03: 14.240
para apresentar a você tantos conceitos e habilidades práticas

41
00: 03: 14,240 -> 00: 03: 16.040
quantos possam ser úteis mais tarde.

42
00: 03: 16,040 -> 00: 03: 20.960
E então perceba que no final do semestre você vai se sentir muito menos assim

43
00: 03: 20,960 -> 00: 03: 24.630
e muito mais como algo em que você teve sucesso.

44
00: 03: 24,630 -> 00: 03: 27.880
Então, sem mais delongas, vamos introduzir esta linguagem chamada C.

45
00: 03: 27,880 -> 00: 03: 30.380
À esquerda aqui, lembre-se de que isso talvez era o mais simples

46
00: 03: 30,380 -> 00: 03: 31.910
programa que poderíamos escrever no Scratch.

47
00: 03: 31,910 -> 00: 03: 35.330
E tudo o que este programa fez foi compelir um gato, ou qualquer sprite,

48
00: 03: 35,330 -> 00: 03: 36.760
a dizer olá na tela.

49
00: 03: 36,760 -> 00: 03: 38.960
Hoje, para alcançar esse mesmo resultado, 

50
00: 03: 38,960 -> 00: 03: 42.650
vamos começar a escrever código parecido com este, usando apenas um teclado -

51
00: 03: 42,650 -> 00: 03: 44.690
menos controles gráficos para o usuário.

52
00: 03: 44,690 -> 00: 03: 47.910
Mas vamos ver por que o da esquerda é realmente equivalente ao da direita.

53
00: 03: 47,910 -> 00: 03: 50.390
Então, vamos decompô-lo, digamos, nesta única peça do quebra-cabeça.

54
00: 03: 50,390 -> 00: 03: 53.330
Isso, é claro, fez o que -

55
00: 03: 53,330 -> 00: 03: 55.815
isso representava o quê no contexto de um programa Scratch?

56
00: 03: 55,815 -> 00: 03: 57.440
Qual foi o papel desta peça do quebra-cabeças?

57
00: 03: 57,440 -> 00: 03: 58.700
PÚBLICO: Como começar.

58
00: 03: 58,700 -> 00: 03: 59.850
DAVID MALAN: Sim, para começar.

59
00: 03: 59,850 -> 00: 04: 01.892
Então, para a parte principal do seu programa começar,

60
00: 04: 01,892 -> 00: 04: 05.600
você tem que anexá-lo a esta peça do quebra-cabeça com uma bandeira verde.

61
00: 04: 05,600 -> 00: 04: 08.693
E veremos em C que não é tão simples.

62
00: 04: 08,693 -> 00: 04: 11.360
Mas é algo que você pode simplesmente copiar e colar por enquanto.

63
00: 04: 11,360 -> 00: 04: 15.040
E dentro de alguns dias isso fará mais sentido caractere por caractere.

64
00: 04: 15,040 -> 00: 04: 17.720
Int main void e, em seguida, as chaves abertas,

65
00: 04: 17,720 -> 00: 04: 20.029
é seguido por esta chave fechada

66
00: 04: 20,029 -> 00: 04: 22.940
sugere que todo o código que vamos escrever hoje em diante

67
00: 04: 22,940 -> 00: 04: 26.240
vai ficar entre essas duas chaves opostas

68
00: 04: 26,240 -> 00: 04: 28.770
que envolve de uma peça do quebra-cabeça como esta.

69
00: 04: 28,770 -> 00: 04: 31.785
Mesmo que isso não faça muito sentido hoje ou por alguns dias,

70
00: 04: 31,785 -> 00: 04: 34.160
perceba que é funcionalmente equivalente a apenas dizer

71
00: 04: 34,160 -> 00: 04: 38.070
que a bandeira verde foi clicada, aqui está a parte principal do meu programa.

72
00: 04: 38,070 -> 00: 04: 40.197
Agora, o que um programa pode realmente fazer por você?

73
00: 04: 40,197 -> 00: 04: 43.280
Bem, você pode ter algo como dizer "olá, mundo" no Scratch que apenas

74
00: 04: 43,280 -> 00: 04: 45.030
literalmente imprime isso na tela.

75
00: 04: 45,030 -> 00: 04: 48.260
Então, vamos considerar como você implementaria isso em C,

76
00: 04: 48,260 -> 00: 04: 50.930
sendo uma linguagem baseada em texto ou teclado.

77
00: 04: 50,930 -> 00: 04: 55.490
Bem, não há um verbo ou função chamada "say"/"diga" em C. Em vez disso,

78
00: 04: 55,490 -> 00: 04: 57.410
é chamado de "print"/"imprima", ou não exatamente "print".

79
00: 04: 57,410 -> 00: 05: 00.680
Na verdade, é chamado de "printf", onde f significa formatado

80
00: 05: 00,680 -> 00: 05: 03.860
para que você possa imprimir o texto formatado, como veremos em breve.

81
00: 05: 03,860 -> 00: 05: 07.400
Então, você segue e coloca, ao lado de printf, dois parênteses - um

82
00: 05: 07,400 -> 00: 05: 09.830
parênteses de abertura e o parênteses de fechamento.

83
00: 05: 09,830 -> 00: 05: 14.180
E isso é uma espécie de reminiscência desta forma oval em que usamos anteriormente

84
00:05:14,180 -> 00:05:15.770
colocando a entrada em primeiro lugar.

85
00: 05: 15,770 -> 00: 05: 19.210
E a entrada que colocamos na semana passada foi apenas "diga: olá, mundo".

86
00: 05: 19,210 -> 00: 05: 21.770
Então, literalmente, em C, você vai escrever "hello world"

87
00: 05: 21,770 -> 00: 05: 24.200
entre esses dois parênteses.

88
00: 05: 24,200 -> 00: 05: 25.850
Mas C é um pouco mais minucioso.

89
00: 05: 25,850 -> 00: 05: 28.850
Você não pode simplesmente começar a escrever palavras entre parênteses.

90
00: 05: 28,850 -> 00: 05: 32.870
Sempre que você tiver caracteres, palavras, sentenças ou frases,

91
00: 05: 32,870 -> 00: 05: 36.290
você precisa realmente encapsular esse texto com aspas duplas,

92
00: 05: 36,290 -> 00: 05: 37.090
como neste caso.

93
00: 05: 37,090 -> 00: 05: 40.340
Então você só tem que envolver o que quer que você queira dizer ou imprimir

94
00: 05: 40,340 -> 00: 05: 41.540
com aspas duplas aqui.

95
00: 05: 41,540 -> 00: 05: 44.480
E a última coisa com C que é tão fácil de esquecer no início,

96
00: 05: 44,480 -> 00: 05: 47.520
como você sem dúvida irá, é que você precisa terminar seu pensamento.

97
00: 05: 47,520 -> 00: 05: 51.000
Assim como em uma redação de inglês, você normalmente termina uma frase com um ponto,

98
00: 05: 51.000 -> 00: 05: 52.850
Em C você termina seu pensamento

99
00: 05: 52,850 -> 00: 05: 55.730
Mas não com um ponto, e sim com um ponto e vírgula, geralmente

100
00: 05: 55,730 -> 00: 05: 57.560
no final de uma linha de código.

101
00: 05: 57.560 -> 00: 06: 00.882
Mas veremos quais tipos de linhas de código exigem isso.

102
00: 06: 00,882 -> 00: 06: 02.840
À esquerda, temos uma ideia da semana passada.

103
00: 06: 02,840 -> 00: 06: 06.930
À direita, temos uma ideia desta semana, como veremos em breve no meu computador,

104
00: 06: 06,930 -> 00: 06: 08.930
mas elas são funcionalmente equivalentes.

105
00: 06: 08,930 -> 00: 06: 10.440
Elas fazem a mesma coisa.

106
00: 06: 10,440 -> 00: 06: 13.940
Então, como vamos deste programa Scratch

107
00: 06: 13,940 -> 00: 06: 15.540
para este programa Scratch?

108
00:06:15,540 --> 00:06:18,770
Vamos em frente e pontuar uma ultima coisa.

109
00:06:18,770 --> 00:06:20,840
Precisamos de uma última linha de código, que é apenas

110
00:06:20,840 --> 00:06:24,090
surgiu na tela, que é incluir stdio.h.

111
00:06:24,090 --> 00:06:25,320
Bem, o que isso significa?

112
00:06:25,320 --> 00:06:28,010
Acontece que o Scratch é super amigável.

113
00:06:28,010 --> 00:06:30,600
Você tem todas essas categorias de peças coloridas

114
00:06:30,600 --> 00:06:32,670
à esquerda, e elas estão disponíveis para você

115
00:06:32,670 --> 00:06:35,220
a partir do momento que você começa a usar o Scratch.

116
00:06:35,220 --> 00:06:38,910
No C, quando você quer usar alguma função-- ou alguma peça de quebra-cabeças,

117
00:06:38,910 --> 00:06:39,790
Se quiser--

118
00:06:39,790 --> 00:06:42,240
você tem que tipicamente dizer com antecedência ao computador

119
00:06:42,240 --> 00:06:47,110
Onde essa função está implementada, onde ela está salva.

120
00:06:47,110 --> 00:06:50,340
E isso será reconhecido como uma sintaxe encriptada, e dizendo,

121
00:06:50,340 --> 00:06:52,880
Ei, computador, olhe no arquivo que nós vamos

122
00:06:52,880 --> 00:06:56,640
começar chamando stdio.h, seja lá o que isso signifique

123
00:06:56,640 --> 00:06:58,933
com o objetivo de acessar esta função.

124
00:06:58,933 --> 00:07:00,350
Bem, novamente, este é uma assunto muito extenso.

125
00:07:00,350 --> 00:07:02,400
Está é a nossa primeira mangueira de incêndio de hoje.

126
00:07:02,400 --> 00:07:04,620
Mas a linha importante de código para a proposta de hoje

127
00:07:04,620 --> 00:07:07,470
realmente é essa que está mais para baixo ali no meio.

128
00:07:07,470 --> 00:07:11,040
Então, como faço para escrever meu primeiro programa em C,

129
00:07:11,040 --> 00:07:15,210
Igual na semana passada, quando escrevemos nosso primeiro programa no Scratch?

130
00:07:15,210 --> 00:07:18,540
Bem, considere que a primeira coisa que fizemos no Scratch

131
00:07:18,540 --> 00:07:22,950
era abrir um programa, uma ferramenta - scratch.mit.edu.

132
00: 07: 22,950 -> 00: 07: 25.530
Você pode programar, na verdade, em seu próprio Mac, ou PC,

133
00: 07: 25,530 -> 00: 07: 27.510
não importa qual sistema operacional você está usando.

134
00: 07: 27,510 -> 00: 07: 30.630
Mas, francamente, tende a ser muito irritante e muito sujeito

135
00: 07: 30,630 -> 00: 07: 32.640
a dores de cabeça se todos nós

136
00: 07: 32,640 -> 00: 07: 36.900
tentarmos instalar o software necessário em todos os nossos Macs e PCs individualmente.

137
00: 07: 36,900 -> 00: 07: 39.420
Invariavelmente, todos nós temos diferentes versões das coisas,

138
00: 07: 39,420 -> 00: 07: 41.500
e nossos computadores não funcionam exatamente da mesma forma.

139
00: 07: 41,500 -> 00: 07: 44.440
Portanto, nas primeiras semanas do CS50, usamos uma ferramentas baseadas em nuvem -

140
00: 07: 44,440 -> 00: 07: 48.270
CS50 Sandbox, que reside em sandbox.cs50.io.

141
00: 07: 48,270 -> 00: 07: 51.360
E você usará ela para seu primeiro desafio na próxima semana.

142
00: 07: 51,360 -> 00: 07: 54.280
Este é um ambiente de programação semelhante em espírito ao Scratch,

143
00: 07: 54,280 -> 00: 07: 55.530
mas isso não usa Scratch.

144
00:07:55,530 --> 00:07:57,000
Isto não usa peças de quebra-cabeça.

145
00:07:57,000 --> 00:07:59,730
Ao invés usa C, que é uma linguagem de texto

146
00:07:59,730 --> 00:08:01,530
Que vamos começar a ver agora.

147
00:08:01,530 --> 00:08:04,410
Então há duas partis principais no ambiente deste programa.

148
00:08:04,410 --> 00:08:07,350
Aqui no topo, será onde escrevo meu código real.

149
00:08:07,350 --> 00:08:09,250
Literalmente, em um momento, clicarei naquele sinal de mais,

150
00:08:09,250 --> 00:08:10,708
e vou criar um novo arquivo.

151
00:08:10,708 --> 00:08:13,390
E vou começar a escrever o código nesse arquivo e salvá-lo.

152
00: 08: 13,390 -> 00: 08: 16.038
E então, na metade inferior deste ambiente de programação

153
00: 08: 16,038 -> 00: 08: 18.330
é o que vamos chamar uma janela de terminal.

154
00: 08: 18,330 -> 00: 08: 20.880
Uma janela de terminal é uma espécie de interface das antigas

155
00: 08: 20,880 -> 00: 08: 24.780
através do qual você pode executar comandos digitando-os literalmente em um prompt

156
00: 08: 24,780 -> 00: 08: 25.980
e pressione Enter.

157
00: 08: 25,980 -> 00: 08: 27.330
Tão diferente do Scratch -

158
00: 08: 27,330 -> 00: 08: 29.700
e francamente, ao contrário do Mac OS e do Windows hoje em dia -

159
00: 08: 29,700 -> 00: 08: 32.610
onde você aponta e clica e arrasta e assim por diante, interagindo

160
00: 08: 32,610 -> 00: 08: 35.460
com uma interface gráfica de usuário, muito de nossa programação

161
00: 08: 35,460 -> 00: 08: 38.620
no início vai envolver comandos de digitação.

162
00: 08: 38,620 -> 00: 08: 40.380
Então, vamos tornar isso mais real.

163
00: 08: 40,380 -> 00: 08: 44.580
O objetivo em questão, novamente, é, simplesmente, implementar um programa em C

164
00: 08: 44,580 -> 00: 08: 47.580
que diz olá para o mundo, que funcionalmente será

165
00: 08: 47,580 -> 00: 08: 49.950
semelhante ao programa Scratch à esquerda.

166
00: 08: 49,950 -> 00: 08: 53.295
Mas agora precisamos implementá-lo usando a linguagem certa.

167
00: 08: 53,295 -> 00: 08: 55.170
Então, neste ambiente de programação, vou

168
00: 08: 55,170 -> 00: 08: 59.610
seguir em frente e clicar aqui no sinal de mais para criar um novo arquivo ou guia.

169
00: 08: 59,610 -> 00: 09: 03.090
Por convenção, irei prosseguir e nomear meu arquivo com algo como hello.c.

170
00: 09: 03,090 -> 00: 09: 05.550
Olá só porque quero que este programa diga olá,

171
00: 09: 05,550 -> 00: 09: 07.170
mas eu poderia chamá-lo do que quiser.

172
00: 09: 07,170 -> 00: 09: 10.920
E ponto c porque a convenção, nesta linguagem de programação C,

173
00: 09: 10.920 -> 00: 09: 14.640
é nomear seus arquivos que contêm seu código com este

174
00: 09: 14,640 -> 00: 09: 18.740
ponto c, bem como você tem ponto doc ou ponto docx para Microsoft Word,

175
00: 09: 18,740 -> 00: 09: 22.342
ponto gif para arquivos gráficos e similares.

176
00: 09: 22,342 -> 00: 09: 24.300
Então, vou prosseguir e clicar em Criar arquivo.

177
00: 09: 24,300 -> 00: 09: 27.750
E você verá agora que tenho um prompt piscando na linha 1--

178
00: 09: 27,750 -> 00: 09: 31.530
ele numerará automaticamente minhas linhas - em uma guia chamada hello.c.

179
00: 09: 31,530 -> 00: 09: 33.000
É aqui que posso escrever código.

180
00: 09: 33.000 -> 00: 09: 37.210
Agora, embora o código que estou prestes a escrever seja, francamente, bastante enigmático -

181
00: 09: 37,210 -> 00: 09: 41.400
include stdio.h, int main void.

182
00: 09: 41,400 -> 00: 09: 44.220
E então aqui, vou fazer printf, aspas, aspas,

183
00: 09: 44,220 -> 00: 09: 46.650
ponto e vírgula "hello world".

184
00: 09: 46,650 -> 00: 09: 50.008
Acabei de escrever meu primeiro programa em C.

185
00: 09: 50,008 -> 00: 09: 52.050
Vou prosseguir e aumentar o zoom no canto superior esquerdo.

186
00: 09: 52,050 -> 00: 09: 54.120
São seis linhas de código no total.

187
00: 09: 54,120 -> 00: 09: 57.720
E você verá que incluí stdio.h, o que quer que isso signifique,

188
00: 09: 57,720 -> 00: 09: 59.850
int main void, o que quer que isso signifique.

189
00: 09: 59,850 -> 00: 10: 02.610
E então, realmente, a essência deste programa está na linha 5 -

190
00: 10: 02,610 -> 00: 10: 07.050
print ou printf para formatação, "olá, mundo."

191
00: 10: 07,050 -> 00: 10: 10.050
Portanto, lembre-se de que int main void é semelhante em espírito à

192
00: 10: 10,050 -> 00: 10: 11.580
quando a bandeira verde foi clicada.

193
00: 10: 11,580 -> 00: 10: 13.980
E printf é semelhante ao bloco "diga".

194
00: 10: 13,980 -> 00: 10: 16.350
E essa linha de cima de código, só precisamos dela,

195
00: 10: 16,350 -> 00: 10: 19.320
porque o computador não vai entender printf

196
00: 10: 19,320 -> 00: 10: 22.630
a menos que eu diga para incluir esse arquivo.

197
00: 10: 22,630 -> 00: 10: 26.850
Tudo bem, agora eu proclamo que escrevi algum código.

198
00: 10: 26,850 -> 00: 10: 28.110
Como faço para executá-lo?

199
00: 10: 28,110 -> 00: 10: 32.390
Bem, como você executa um programa no seu Mac ou PC?

200
00: 10: 32,390 -> 00: 10: 34.590
O que você normalmente faz?

201
00: 10: 34,590 -> 00: 10: 36.180
Você clica duas vezes, certo?

202
00: 10: 36,180 -> 00: 10: 39.730
Infelizmente, não parece haver nada óbvio para clicar duas vezes aqui.

203
00: 10: 39,730 -> 00: 10: 41.370
Na verdade, não há nenhum ícone na minha tela.

204
00: 10: 41,370 -> 00: 10: 44.100
E, de fato, ainda não existe um programa em si.

205
00: 10: 44,100 -> 00: 10: 47.760
Porque os computadores, lembre-se da semana passada, não entendem inglês.

206
00: 10: 47,760 -> 00: 10: 49.740
Eles não entendem tecnicamente C, em si.

207
00: 10: 49,740 -> 00: 10: 52.440
Veja qual é a linguagem que os computadores falam e entendem?

208
00: 10: 52,440 -> 00: 10: 53.235
PÚBLICO: Binário.

209
00: 10: 53,235 -> 00: 10: 55.110
DAVID MALAN: Sim, binário, zeros e uns.

210
00: 10: 55,110 -> 00: 10: 56.943
E, no entanto, isso claramente não são zeros e uns.

211
00: 10: 56,943 -> 00: 11: 00.030
E, francamente, nenhum de nós se divertiria se a programação estivesse envolvida,

212
00: 11: 00,030 -> 00: 11: 03.240
hoje em dia, literalmente escrevendo zeros e uns, que, de algum modo,

213
00: 11: 03,240 -> 00: 11: 06.450
se fazia necessário muito tempo atrás.

214
00: 11: 06,450 -> 00: 11: 09.510
Mas hoje em dia, parece que existe uma solução para esse problema.

215
00: 11: 09,510 -> 00: 11: 12.660
Por mais enigmático que pareça para a maioria de nós nesta sala,

216
00: 11: 12,660 -> 00: 11: 15.540
pelo menos você pode imaginar eventualmente ficar confortável,

217
00: 11: 15,540 -> 00: 11: 18.700
provavelmente, com esta sintaxe, uma vez que você aprenda as regras e a sintaxe

218
00: 11: 18,700 -> 00: 11: 19.530
e assim por diante.

219
00: 11: 19,530 -> 00: 11: 22.260
Mas precisamos converter isso de alguma forma para zeros e uns.

220
00: 11: 22,260 -> 00: 11: 25.110
E como fazer isso talvez não seja óbvio.

221
00: 11: 25,110 -> 00: 11: 31.110
Então, se quisermos converter um código como este em zeros e uns

222
00: 11: 31,110 -> 00: 11: 34.770
que o computador entenda, deve haver alguma etapa intermediária.

223
00: 11: 34,770 -> 00: 11: 38.370
Eu realmente preciso, no meu Mac ou PC ou neste ambiente baseado em nuvem,

224
00: 11: 38,370 -> 00: 11: 43.200
um programa que vai ter como entrada meu código-fonte, que

225
00: 11: 43.200 -> 00: 11: 45.650
é aquela linguagem chamada C, e vai produzir

226
00: 11: 45,650 -> 00: 11: 48.000
como saída o que é chamado de código de máquina.

227
00: 11: 48.000 -> 00: 11: 53.400
Portanto, o código-fonte é algo como C ou Python ou Java ou C ++ e talvez outros

228
00: 11: 53,400 -> 00: 11: 54.660
idiomas que você já ouviu falar.

229
00: 11: 54,660 -> 00: 11: 58.170
É uma sintaxe semelhante ao inglês, na qual você escreve programas.

230
00: 11: 58,170 -> 00: 12: 02.760
Código de máquina são os zeros e uns que todo computador realmente entende.

231
00: 12: 02,760 -> 00: 12: 05.970
Então, para ir do código-fonte ao código de máquina,

232
00: 12: 05,970 -> 00: 12: 08.773
deve haver algum tipo de algoritmo ou, mais especificamente,

233
00: 12: 08,773 -> 00: 12: 10.690
um software que faz essa conversão.

234
00: 12: 10,690 -> 00: 12: 14.230
E esse software é o que vamos começar a chamar de compilador.

235
00: 12: 14,230 -> 00: 12: 17.790
Então, vamos escrever código literalmente apenas digitando comandos em um teclado.

236
00: 12: 17,790 -> 00: 12: 20.160
Vamos salvar esses comandos em um arquivo,

237
00: 12: 20,160 -> 00: 12: 21.900
assim como você salvou seu código no Scratch.

238
00: 12: 21,900 -> 00: 12: 24.990
Mas antes que eu possa executar meu programa e fazer o equivalente a clicar duas vezes

239
00: 12: 24,990 -> 00: 12: 28.200
nele, preciso executá-lo por meio de um compilador

240
00: 12: 28,200 -> 00: 12: 30.640
e produzir sua saída, que é de zeros e uns.

241
00: 12: 30,640 -> 00: 12: 33.000
Então, como faço isso?

242
00: 12: 33.000 -> 00: 12: 35.640
Este é o primeiro dos comandos mais esotéricos,

243
00: 12: 35,640 -> 00: 12: 38.880
mas acontece que é relativamente simples de fazer.

244
00: 12: 38,880 -> 00: 12: 40.680
No topo do meu ambiente de programação -

245
00: 12: 40,680 -> 00: 12: 43.380
novamente, tenho meu código aqui no canto superior esquerdo.

246
00: 12: 43,380 -> 00: 12: 45.780
E se eu rolar para baixo, eu tenho isso, de novo,

247
00: 12: 45,780 -> 00: 12: 47.322
o chamado terminal.

248
00: 12: 47,322 -> 00: 12: 49.530
E o cifrão é apenas uma convenção humana estranha.

249
00: 12: 49,530 -> 00: 12: 51.930
O cifrão significa apenas digite algo aqui.

250
00: 12: 51,930 -> 00: 12: 54.540
Esse é o seu prompt, ou shell.

251
00: 12: 54,540 -> 00: 12: 59.700
Mas o cursor piscando está apenas me convidando a digitar um comando neste prompt.

252
00: 12: 59,700 -> 00: 13: 04.740
O primeiro comando que vou digitar é o chamado Clang para linguagem C.

253
00: 13: 04,740 -> 00: 13: 09.210
Clang é o nome de um programa que existe para compilar código.

254
00: 13: 09,210 -> 00: 13: 10.650
Que Alguém escreveu.

255
00: 13: 10,650 -> 00: 13: 14.100
Outra pessoa online criou este programa chamado Clang - todo um grupo de pessoas,

256
00: 13: 14,100 -> 00: 13: 14.640
de fato.

257
00: 13: 14,640 -> 00: 13: 18.210
Disponibilizado gratuitamente para mim e para você baixar em seus próprios Macs ou PCs

258
00: 13: 18,210 -> 00: 13: 19.990
ou este ambiente de sandbox.

259
00: 13: 19,990 -> 00: 13: 23.110
E podemos usar o Clang para converter o código-fonte em código de máquina.

260
00: 13: 23,110 -> 00: 13: 26.940
Então, vou prosseguir e executar o Clang hello.c.

261
00: 13: 26,940 -> 00: 13: 29.860
Ainda não pressionei Enter, mas no momento em que pressiono Enter,

262
00: 13: 29,860 -> 00: 13: 31.360
vamos ver algo acontecer.

263
00: 13: 31,360 -> 00: 13: 33.720
Deixe-me ir até este pequeno ícone de pasta aqui,

264
00: 13: 33,720 -> 00: 13: 37.020
e você pode realmente ver todos os arquivos na minha sandbox atual,

265
00: 13: 37,020 -> 00: 13: 38.710
por assim dizer, meu ambiente de programação.

266
00: 13: 38,710 -> 00: 13: 41.752
Claro, há apenas um, porque o único arquivo que criei até agora

267
00: 13: 41,752 -> 00: 13: 43.170
é chamado de hello.c.

268
00: 13: 43,170 -> 00: 13: 45.720
Mas observe o que acontece no momento em que pressiono Enter,

269
00: 13: 45,720 -> 00: 13: 47.940
depois de digitar Clang hello.c.

270
00: 13: 47,940 -> 00: 13: 50.610


271
00: 13: 50,610 -> 00: 13: 54.150
Então, claramente, algo mais existe agora, e é

272
00: 13: 54,150 -> 00: 13: 56.490
um nome realmente estúpido e muito enigmático.

273
00: 13: 56,490 -> 00: 14: 02.520
É a.out, mas talvez você possa adivinhar o que há dentro desse novo arquivo.

274
00: 14: 02,520 -> 00: 14: 03.842
O que pode estar dentro dele?

275
00: 14: 03,842 -> 00: 14: 04.800
PÚBLICO: Código de máquina.

276
00: 14: 04,800 -> 00: 14: 06.133
DAVID MALAN: Sim, código de máquina.

277
00: 14: 06,133 -> 00: 14: 09.540
Portanto, significa saída do assembly, mas que significa apenas código de máquina.

278
00: 14: 09,540 -> 00: 14: 13.110
Portanto, dentro deste arquivo há um monte de zeros e uns

279
00: 14: 13,110 -> 00: 14: 16.437
que correspondem a este código, mas em binário,

280
00: 14: 16,437 -> 00: 14: 18.270
na linguagem que o computador pode entender.

281
00: 14: 18,270 -> 00: 14: 20.640
Então, literalmente, o que acabei de fazer foi isso -

282
00: 14: 20,640 -> 00: 14: 24.450
Tomei como entrada um código semelhante a este, escrito em C.

283
00: 14: 24,450 -> 00: 14: 28.148
Executei-o como entrada no compilador e produzi esta saída, zeros e uns.

284
00: 14: 28,148 -> 00: 14: 29.940
E esses zeros e uns eram automaticamente

285
00: 14: 29,940 -> 00: 14: 35.113
salvo para mim dentro de um arquivo que, por convenção humana, é chamado a.out.

286
00: 14: 35,113 -> 00: 14: 37.530
Tudo bem, mas alguém propôs antes, que para executar um programa,

287
00: 14: 37,530 -> 00: 14: 40.088
normalmente, em seu Mac e PC, basta clicar duas vezes nele.

288
00: 14: 40,088 -> 00: 14: 41.880
Mas realmente não há nada para clicar duas vezes.

289
00: 14: 41,880 -> 00: 14: 44.940
E, na verdade, se eu clicar duas vezes nisso, vai ficar muito estranho,

290
00: 14: 44,940 -> 00: 14: 46.380
e o computador não vai entender.

291
00: 14: 46,380 -> 00: 14: 48.930
Porque são zeros e uns que não devem ser clicados.

292
00: 14: 48,930 -> 00: 14: 52.598
Eles devem ser executados neste prompt de comando.

293
00: 14: 52,598 -> 00: 14: 53.890
Então, deixe-me ir em frente e fazer isso.

294
00: 14: 53,890 -> 00: 14: 54.807
Isso também é enigmático.

295
00: 14: 54,807 -> 00: 14: 58.740
Mas vou prosseguir e fazer ./a.out.

296
00: 14: 58,740 -> 00: 15: 02.190
E isso, por mais estranho que pareça à primeira vista,

297
00: 15: 02,190 -> 00: 15: 07.890
é como digo ao computador, execute o programa a.out no meu diretório atual.

298
00: 15: 07,890 -> 00: 15: 11.010
Então, esse ponto que digitei primeiro significa que está literalmente bem aqui,

299
00: 15: 11,010 -> 00: 15: 13.260
na minha pasta atual, como se você estivesse clicando duas vezes

300
00: 15: 13,260 -> 00: 15: 14.730
nele no seu Mac ou PC.

301
00: 15: 14,730 -> 00: 15: 19.650
E /a.out significa olhar neste diretório e executar o programa no arquivo chamado

302
00: 15: 19,650 -> 00: 15: 20.860
a.out.

303
00: 15: 20,860 -> 00: 15: 23.150
Deixe-me ir em frente e pressione Enter.

304
00: 15: 23,150 -> 00: 15: 25.980
E voila, olá mundo.

305
00: 15: 25,980 -> 00: 15: 29.610
Então você ficou muito impressionado na semana passada, pelo que me lembro, quando fiz o gato dizer:

306
00: 15: 29,610 -> 00: 15: 30.580
Olá Mundo.

307
00: 15: 30,580 -> 00: 15: 32.510
Aqui, parecemos menos do que desapontados.

308
00: 15: 32,510 -> 00: 15: 36.360
Mas olá, mundo agora é meu programa em C que faz exatamente a mesma coisa.

309
00: 15: 36,360 -> 00: 15: 39.870
Mas, admito, parece um pouco estúpido no momento.

310
00: 15: 39,870 -> 00: 15: 40.950
Parece um pouco bugado.

311
00: 15: 40,950 -> 00: 15: 44.373
O que o incomoda, mesmo que você nunca tenha programado antes?

312
00: 15: 44,373 -> 00: 15: 45.290
PÚBLICO: Cifrão.

313
00: 15: 45,290 -> 00: 15: 46.748
DAVID MALAN: Sim, o cifrão.

314
00: 15: 46,748 -> 00: 15: 48.660
Eu não quis dizer olá, mundo cifrão,

315
00: 15: 48,660 -> 00: 15: 50.868
mas aquele cifrão é como um artefato, certo?

316
00: 15: 50,868 -> 00: 15: 52.482
O que significa mesmo o cifrão?

317
00: 15: 52,482 -> 00: 15: 53.190
PÚBLICO: Prompt.

318
00: 15: 53,190 -> 00: 15: 54.150
DAVID MALAN: É apenas esse prompt.

319
00: 15: 54,150 -> 00: 15: 57.270
Ele está esperando por outro comando, e é por isso que meu cursor está piscando aqui.

320
00: 15: 57,270 -> 00: 15: 58.603
Mas parece estúpido, certo?

321
00: 15: 58,603 -> 00: 16: 01.538
Poderíamos argumentar que essa era minha intenção, mas, francamente, eu estaria mentindo.

322
00: 16: 01,538 -> 00: 16: 03.330
Isso não faz exatamente o que eu quero que faça.

323
00: 16: 03,330 -> 00: 16: 05.380
E isso porque, ao contrário do Scratch -

324
00: 16: 05,380 -> 00: 16: 06.930
que, novamente, é mais amigável -

325
00: 16: 06,930 -> 00: 16: 12.220
C, e muitas linguagens como esta, literalmente farão apenas o que você lhes disser para fazer.

326
00: 16: 12,220 -> 00: 16: 16.972
Em nenhum momento eu disse ao computador para mover o cursor para uma nova linha.

327
00: 16: 16,972 -> 00: 16: 18.180
Eu não terminei esse pensamento.

328
00: 16: 18,180 -> 00: 16: 20.340
Eu disse, olá, vírgula, mundo e é isso.

329
00: 16: 20,340 -> 00: 16: 23.650
Nunca enviei um comando ao computador para realmente mover o cursor,

330
00: 16: 23,650 -> 00: 16: 24.660
mas eu posso.

331
00: 16: 24,660 -> 00: 16: 26.830
Então, deixe-me voltar ao meu código aqui.

332
00: 16: 26,830 -> 00: 16: 30.300
E acontece que em C, se você disser ao computador

333
00: 16: 30,300 -> 00: 16: 33.240
imprimir olá, vírgula, mundo, isso é literalmente tudo o que 

334
00: 16: 33,240 -> 00: 16: 34.620
vai imprimir para você.

335
00: 16: 34,620 -> 00: 16: 36.810
Se você deseja imprimir uma nova linha, você precisa

336
00: 16: 36,810 -> 00: 16: 40.950
usar um comando especial, um caractere especial denominado caractere de nova linha,

337
00: 16: 40,950 -> 00: 16: 43.650
que é representado pela barra invertida n.

338
00: 16: 43,650 -> 00: 16: 44.672
Agora, por que isso?

339
00: 16: 44,672 -> 00: 16: 46.380
Bem, é realmente porque embora você

340
00: 16: 46,380 -> 00: 16: 49.590
pode ficar inclinado a pressionar Enter, simplesmente assim

341
00: 16: 49,590 -> 00: 16: 51.900
como você esperaria que o computador fizesse,

342
00: 16: 51,900 -> 00: 16: 54.210
mesmo que você nunca tenha programado antes, isso provavelmente

343
00: 16: 54,210 -> 00: 16: 55.950
deve começar a incomodá-lo.

344
00: 16: 55,950 -> 00: 16: 57.270
Parece um pouco estranho.

345
00: 16: 57,270 -> 00: 16: 59.460
Parece um pouco confuso, essa linha está aqui

346
00: 16: 59,460 -> 00: 17: 00.930
e a segunda linha está aqui.

347
00: 17: 00,930 -> 00: 17: 03.180
Então, o que os humanos decidiram anos atrás foi: vamos

348
00:17:03,180 --> 00:17:06,750
apenas ter uma instrução simples, barra invertida n,

349
00: 17: 06,750 -> 00: 17: 10.170
que diz ao computador para mover essa nova linha para baixo.

350
00: 17: 10,170 -> 00: 17: 11.670
Então, deixe-me ir em frente e diminuir o zoom agora.

351
00: 17: 11,670 -> 00: 17: 14.010
Na sandbox, ele salva automaticamente como o Google Docs,

352
00: 17: 14,010 -> 00: 17: 16.589
então você não precisa ir para Arquivo, Salvar ou qualquer coisa assim.

353
00: 17: 16,589 -> 00: 17: 23.440
Se eu prosseguir agora e executar novamente este programa ./a.out Enter, ainda não foi corrigido.

354
00: 17: 23,440 -> 00: 17: 25.319
Deixe-me ir em frente e aumentar o zoom.

355
00: 17: 25,319 -> 00: 17: 27.210
Observe que o sintoma ainda está lá.

356
00: 17: 27,210 -> 00: 17: 28.260
Por quê?

357
00: 17: 28,260 -> 00: 17: 31.050
Que erro eu cometi?

358
00: 17: 31,050 -> 00: 17: 32.700
Sim, não o recompilei.

359
00: 17: 32,700 -> 00: 17: 36.120
Então, novamente, o computador vai começar a te levar muito, muito ao pé da letra

360
00: 17: 36,120 -> 00: 17: 38.580
agora que você está programando ele para fazer coisas.

361
00: 17: 38,580 -> 00: 17: 41.340
E se você quiser executar a nova versão do seu código,

362
00: 17: 41,340 -> 00: 17: 44.880
você vai literalmente ter que fazer algo como Clang

363
00: 17: 44,880 -> 00: 17: 48.360
e então hello.c, Enter.

364
00: 17: 48,360 -> 00: 17: 49.810
E nada parece acontecer.

365
00: 17: 49,810 -> 00: 17: 52.552
E, francamente, e ironicamente, quando você não vê nenhum resultado,

366
00: 17: 52,552 -> 00: 17: 53.760
isso geralmente é uma coisa boa.

367
00: 17: 53,760 -> 00: 17: 56.340
Quando você vê a saída, geralmente é uma lista de, tipo, cinco erros

368
00: 17: 56,340 -> 00: 17: 58.560
que você cometeu ou mensagens de erro que veremos em breve.

369
00: 17: 58,560 -> 00: 18: 00.120
Mas ainda temos a.out.

370
00: 18: 00,120 -> 00: 18: 02.200
É apenas uma versão mais recente disso.

371
00: 18: 02,200 -> 00: 18: 06.930
Então, se eu prosseguir e aumentar o zoom agora e fizer isso-- ./a.out, Enter--

372
00: 18: 06,930 -> 00: 18: 10.070
agora tenho uma versão mais impressionante de hello world.

373
00: 18: 10,070 -> 00: 18: 12.450
Eu acabei de limpar ele um pouco.

374
00: 18: 12,450 -> 00: 18: 14.190
Tudo bem, deixe-me fazer uma pausa por um momento

375
00: 18: 14,190 -> 00: 18: 18.490
e veja se há alguma dúvida sobre essa mecânica até agora.

376
00: 18: 18,490 -> 00: 18: 19.066
Sim?

377
00: 18: 19,066 -> 00: 18: 20.440
PÚBLICO: Por que a linha 2 está vazia?

378
00: 18: 20,440 -> 00: 18: 21.940
DAVID MALAN: Diga um pouco mais alto.

379
00: 18: 21,940 -> 00: 18: 23.640
PÚBLICO: Por que a linha 2 está vazia?

380
00: 18: 23,640 -> 00: 18: 24.330
DAVID MALAN: Por que a linha 2 está vazia?

381
00: 18: 24,330 -> 00: 18: 25.540
Oh, pergunta realmente boa.

382
00: 18: 25,540 -> 00: 18: 29.678
A linha 2 está vazia porque decidi estéticamente

383
00: 18: 29,678 -> 00: 18: 30.720
ter uma aparência um pouco melhor.

384
00: 18: 30,720 -> 00: 18: 32.553
Muito parecido com uma redação de inglês, você pode dar

385
00:18:32,553 --> 00:18:34,500
Enter, só para separar seus parágrafos,

386
00: 18: 34,500 -> 00: 18: 36.810
assim, os programadores geralmente separam seus códigos, apenas

387
00: 18: 36,810 -> 00: 18: 39.300
para torná-lo um pouco mais fácil de digerir para que não

388
00: 18: 39,300 -> 00: 18: 41.610
pareça apenas um grande amontoado de código.

389
00: 18: 41,610 -> 00: 18: 44.680
Mas não é necessário e eu poderia omitir.

390
00: 18: 44,680 -> 00: 18: 46.880
Outras perguntas?

391
00: 18: 46,880 -> 00: 18: 49.036
Sim?

392
00: 18: 49,036 -> 00: 18: 51.940
PÚBLICO: Você pode renomear a.out para ter mais de um

393
00: 18: 51,940 -> 00: 18: 52.898
arquivo em seu diretório?

394
00: 18: 52,898 -> 00: 18: 54.315
DAVID MALAN: Boa pergunta.

395
00: 18: 54,315 -> 00: 18: 57.750
Você pode renomear a.out para ter mais de um arquivo ou programa

396
00: 18: 57.750 -> 00: 18: 58.740
no mesmo diretório?

397
00: 18: 58,740 -> 00: 18: 59.430
Absolutamente.

398
00: 18: 59,430 -> 00: 19: 00.990
Então deixe-me fazer isso agora.

399
00: 19: 00,990 -> 00: 19: 04.350
Acontece que quando você executa comandos em um computador como o Clang,

400
00: 19: 04,350 -> 00: 19: 08.100
você não precisa apenas dizer o nome do programa e o nome do arquivo.

401
00: 19: 08,100 -> 00: 19: 10.380
Você pode adicionar opções adicionais, também conhecidas

402
00: 19: 10,380 -> 00: 19: 12.180
como argumentos de linha de comando.

403
00: 19: 12,180 -> 00: 19: 14.280
E aqui também é um pouco arcaico.

404
00: 19: 14,280 -> 00: 19: 19.020
Você tem que saber o que é possível para digitar essas coisas.

405
00: 19: 19,020 -> 00: 19: 20.640
Mas acontece que com o Clang -

406
00: 19: 20,640 -> 00: 19: 22.740
e se você ler a documentação, verá -

407
00: 19: 22,740 -> 00: 19: 25.920
você pode realmente dizer -o para a saída.

408
00: 19: 25,920 -> 00: 19: 28.140
E então você pode especificar qualquer nome que você

409
00: 19: 28,140 -> 00: 19: 31.860
deseja para o arquivo no qual seu código de máquina será salvo.

410
00: 19: 31,860 -> 00: 19: 33.000
Portanto, observe o que acontece agora.

411
00: 19: 33.000 -> 00: 19: 35.550
Quando pressiono Enter agora, observe o canto superior esquerdo,

412
00: 19: 35,550 -> 00: 19: 37.710
onde eu tenho a.out e hello.c.

413
00: 19: 37,710 -> 00: 19: 40.930
Agora eu também tenho hello.

414
00: 19: 40,930 -> 00: 19: 45.210
E agora posso prosseguir e dizer ./hello em vez de a.out,

415
00: 19: 45,210 -> 00: 19: 48.137
e o resultado agora será o mesmo.

416
00: 19: 48,137 -> 00: 19: 50.970
E deixe-me aproveitar essa oportunidade para pontuar outra coisa.

417
00: 19: 50,970 -> 00: 19: 53.570
Mesmo que vejamos essa interface gráfica aqui,

418
00: 19: 53,570 -> 00: 19: 55.320
isso é apenas conveniente, porque você e eu

419
00: 19: 55,320 -> 00: 19: 59.310
geralmente estão familiarizados com essa interface de nossos próprios Macs e PCs.

420
00: 19: 59,310 -> 00: 20: 04.590
Mas posso fazer tudo por meio deste prompt de comando o que posso fazer por meio do meu mouse.

421
00: 20: 04,590 -> 00: 20: 07.350
Na verdade, neste ambiente de programação,

422
00: 20: 07,350 -> 00: 20: 10.200
Posso digitar um comando chamado ls para listar.

423
00: 20: 10,200 -> 00: 20: 13.800
É uma notação abreviada, porque anos atrás, os humanos decidiram, bem,

424
00: 20: 13,800 -> 00: 20: 17.830
por que digitar L-I-S-T se podemos apenas digitar ls, que soa quase a mesma coisa.

425
00: 20: 17,830 -> 00: 20: 22.320
E assim nasceu o comando ls, que simplesmente exibe

426
00: 20: 22,320 -> 00: 20: 26.340
uma lista de todos os arquivos da pasta ou diretório atual.

427
00: 20: 26,340 -> 00: 20: 30.570
E vemos a mesma coisa - a.out, hello e hello.c.

428
00: 20: 30,570 -> 00: 20: 33.720
E você pode talvez inferir ou adivinhar, o que o asterisco

429
00: 20: 33,720 -> 00: 20: 36.060
quer dizer depois de a.out e hello, talvez?

430
00: 20: 36,060 -> 00: 20: 37.033
PÚBLICO: Executável.

431
00: 20: 37,033 -> 00: 20: 38.950
DAVID MALAN: É executável, o que significa apenas

432
00: 20: 38,950 -> 00: 20: 42.660
há um código de máquina lá que pode ser executado pelo computador,

433
00: 20: 42,660 -> 00: 20: 45.773
enquanto hello.c não tem esse asterisco ou estrela depois dele,

434
00: 20: 45,773 -> 00: 20: 47.190
o que significa apenas que é o código-fonte.

435
00: 20: 47,190 -> 00: 20: 50.340
Assim, você pode até mesmo distinguir visualmente o código-fonte do código de máquina

436
00: 20: 50,340 -> 00: 20: 51.600
do código de máquina.

437
00: 20: 51,600 -> 00: 20: 54.630
Agora, suponha que eu não queira que a.out exista mais,

438
00: 20: 54,630 -> 00: 20: 56.130
porque parece um nome estúpido.

439
00: 20: 56,130 -> 00: 20: 58.230
Nunca vou lembrar que programa ele é.

440
00: 20: 58,230 -> 00: 21: 02.520
Bem, você pode digitar outros comandos, como rm, para remover, a.out.

441
00: 21: 02,520 -> 00: 21: 03.660
E então pressione Enter.

442
00: 21: 03,660 -> 00: 21: 04.980
E isso é um pouco arcaico.

443
00: 21: 04,980 -> 00: 21: 07.540
Ele diz para remover o arquivo comum a.out.

444
00: 21: 07,540 -> 00: 21: 10.890
Observe que o prompt agora está piscando após esse ponto de interrogação.

445
00: 21: 10.890 -> 00: 21: 15.060
Posso prosseguir e digitar Y para sim ou yes para sim.

446
00: 21: 15,060 -> 00: 21: 17.010
Observe que nada parece ter acontecido.

447
00: 21: 17,010 -> 00: 21: 20.730
Mas como posso verificar quais arquivos existem agora nesta pasta?

448
00: 21: 20,730 -> 00: 21: 24.790
Sim, então apenas digito ls de novo, e agora estou com esses dois arquivos.

449
00: 21: 24,790 -> 00: 21: 27.450
Acontece que também existem outros comandos que podemos digitar.

450
00: 21: 27,450 -> 00: 21: 34.140
E há comandos como ls e rm.

451
00: 21: 34,140 -> 00: 21: 36.690
Há mkdir para criar um diretório.

452
00: 21: 36,690 -> 00: 21: 38.683
Existe rmdir para remover o diretório.

453
00: 21: 38,683 -> 00: 21: 41.100
E a qualquer momento que você precisar saber ou usar um desses comandos,

454
00: 21: 41,100 -> 00: 21: 43.080
faremos questão de informá-lo no seu desafio.

455
00: 21: 43,080 -> 00: 21: 46.320
Mas perceba tudo o que você pode fazer com o mouse

456
00: 21: 46,320 -> 00: 21: 50.610
e aquela interface gráfica, você também pode fazer nesta linha de comando.

457
00: 21: 50,610 -> 00: 21: 53.640
Tudo bem, então vamos aumentar um pouco as coisas

458
00: 21: 53,640 -> 00: 21: 55.950
e fazer algo um pouco mais interessante,

459
00: 21: 55,950 -> 00: 21: 58.350
voltando para o lado a lado aqui.

460
00: 21: 58,350 -> 00: 22: 02.000
Até agora, tudo o que fizemos foi imprimir hello world.

461
00: 22: 02.000 -> 00: 22: 04.620
Mas lembre-se, na semana passada, o segundo programa que escrevemos

462
00: 22: 04,620 -> 00: 22: 06.450
foi um pouco mais dinâmico e interativo.

463
00: 22: 06,450 -> 00: 22: 10.200
O que fizemos na semana passada como nosso segundo programa no Scratch, se você se lembrar?

464
00: 22: 10,200 -> 00: 22: 12.400
PÚBLICO: Solicitamos ao usuário seu nome.

465
00: 22: 12,400 -> 00: 22: 14.692
DAVID MALAN: Sim, solicitamos ao usuário o nome dele.

466
00: 22: 14.692 -> 00: 22: 17.550
E então dissemos olá, David, ou olá, Brian, ou quem quer que seja

467
00: 22: 17,550 -> 00: 22: 19.133
estava realmente executando o programa.

468
00: 22: 19,133 -> 00: 22: 21.300
Então aquele programa parecia um pouco com isso.
469
00: 22: 21,300 -> 00: 22: 25.590
Essas duas linhas de código foram anexadas ao bloco "quando a bandeira verde for clicada".

470
00: 22: 25,590 -> 00: 22: 28.170
Este bloco azul aqui no topo era uma função,

471
00: 22: 28,170 -> 00: 22: 32.940
e essa função retornou um argumento, retornou uma resposta.

472
00: 22: 32,940 -> 00: 22: 35.170
Ele retornou a resposta que o usuário havia digitado.

473
00: 22: 35,170 -> 00: 22: 38.130
E isso foi útil, porque usamos a resposta do usuário

474
00: 22: 38,130 -> 00: 22: 42.600
para juntá-los, ou concatenar esquerda e direita, com a palavra hello.

475
00: 22: 42,600 -> 00: 22: 45.160
E então dissemos o resultado disso.

476
00: 22: 45,160 -> 00: 22: 46.255
Então, como fazemos isso em C?

477
00: 22: 46,255 -> 00: 22: 48.630
Bem, é aqui que as coisas vão se complicar rapidamente.

478
00: 22: 48,630 -> 00: 22: 51.570
Mas, novamente, é tudo uma questão de seguir certas regras e padrões que

479
00: 22: 51,570 -> 00: 22: 54.190
vão ficar cada vez mais familiares com o tempo.

480
00: 22: 54,190 -> 00: 22: 57.990
Em C, pelo menos no CS50 Sandbox, o equivalente mais próximo

481
00: 22: 57,990 -> 00: 23: 03.810
para a função "ask/pergunte" no Scratch será uma função C chamada get_string.

482
00: 23: 03,810 -> 00: 23: 06.180
Uma string é apenas uma expressão de programadores

483
00: 23: 06,180 -> 00: 23: 09.750
para uma palavra ou frase ou sentença.

484
00: 23: 09,750 -> 00: 23: 14.470
Portanto, texto, o oposto de números ou algum outro dado.

485
00: 23: 14,470 -> 00: 23: 19.680
Portanto, get_string é o análogo mais próximo da função ask.

486
00: 23: 19,680 -> 00: 23: 22.830
Entre os parênteses, o que implica que aqui está

487
00: 23: 22,830 -> 00: 23: 24.840
onde você pode fornecer alguma entrada, eu posso seguir

488
00: 23: 24,840 -> 00: 23: 27.673
e fornecer o prompt que o usuário verá na tela -

489
00: 23: 27,673 -> 00: 23: 30.217
por exemplo, qual é o seu nome, abre aspas, fecha aspas.

490
00: 23: 30,217 -> 00: 23: 31.050
Agora, por que as aspas?

491
00: 23: 31,050 -> 00: 23: 34.050
Eu acabei de afirmar que sempre que você passar uma string -

492
00: 23: 34,050 -> 00: 23: 36.450
uma palavra, uma frase, caracteres alfanuméricos -

493
00: 23: 36,450 -> 00: 23: 38.460
você tem que colocá-los entre aspas duplas

494
00: 23: 38,460 -> 00: 23: 40.380
à esquerda e aspas duplas à direita.

495
00: 23: 40,380 -> 00: 23: 44.994
E para ser claro, por que eu tenho esse encantamento estranho aqui, barra invertida n?

496
00: 23: 44,994 -> 00: 23: 45.786
PÚBLICO: Nova linha.

497
00: 23: 45,786 -> 00: 23: 47.970
DAVID MALAN: Sim, ele apenas move o cursor para a nova linha.

498
00: 23: 47,970 -> 00: 23: 48.540
Por quê?

499
00: 23: 48,540 -> 00: 23: 50.207
Só porque parece um pouco mais bonito.

500
00: 23: 50,207 -> 00: 23: 51.000
Não é necessário.

501
00: 23: 51.000 -> 00: 23: 54.370
E, de fato, um momento atrás, meu próprio computador me solicitou a resposta sim ou não,

502
00: 23: 54,370 -> 00: 23: 56.780
e não moveu o cursor para a próxima linha.

503
00: 23: 56,780 -> 00: 23: 59.470
Isso porque aquele programador decidiu não se preocupar em fazer isso.

504
00: 23: 59,470 -> 00: 24: 02.120
Mas irei em frente e manterei as coisas limpas fazendo isso.

505
00: 24: 02,120 -> 00: 24: 07.150
Agora, uma vez que eu pergunto ao usuário por seu nome por meio desta função get_string,

506
00: 24: 07,150 -> 00: 24: 08.680
Eu preciso fazer algo com isso.

507
00: 24: 08,680 -> 00: 24: 12.220
E em C, a maneira como você faz isso é literalmente

508
00: 24: 12,220 -> 00: 24: 15.837
dê a si mesmo uma variável, que é um pedaço de armazenamento para um valor.

509
00: 24: 15,837 -> 00: 24: 18.670
E vou prosseguir e chamá-la de resposta, assim como foi feito no Scratch.

510
00: 24: 18,670 -> 00: 24: 21.040
Mas em C, posso chamar isso do que quiser.

511
00: 24: 21,040 -> 00: 24: 22.565
Eu poderia chamá-la de xyz.

512
00: 24: 22,565 -> 00: 24: 25.690
Nenhuma delas é muito descritiva, então vou chamá-la de resposta.

513
00: 24: 25,690 -> 00: 24: 27.100
Você pode usar qualquer palavra.

514
00: 24: 27,100 -> 00: 24: 28.990
Mas C é um pouco diferente.

515
00: 24: 28,990 -> 00: 24: 34.480
C é da velha guarda, e você tem que ser super explícito quanto ao tipo de valor

516
00: 24: 34,480 -> 00: 24: 37.630
que está obtendo e, portanto, armazenando na variável.

517
00: 24: 37,630 -> 00: 24: 40.040
Então, à esquerda do nome da variável,

518
00: 24: 40,040 -> 00: 24: 43.810
Tenho que dizer ao computador o tipo de valor que preciso armazenar

519
00: 24: 43,810 -> 00: 24: 45.010
vai ser uma string.

520
00: 24: 45,010 -> 00: 24: 49.180
E veremos em um momento, que há outros tipos de valores.

521
00: 24: 49,180 -> 00: 24: 53.860
Existem números e muito mais, mas por enquanto, vamos apenas armazenar uma string.

522
00: 24: 53,860 -> 00: 24: 56.760
E há uma coisa faltando nesta linha de código.

523
00: 24: 56,760 -> 00: 24: 57.700
PÚBLICO: Ponto e vírgula.

524
00: 24: 57,700 -> 00: 24: 58.600
DAVID MALAN: Ponto e vírgula, certo?

525
00: 24: 58,600 -> 00: 25: 00.392
Fim do pensamento, e esse foi um grande pensamento,

526
00: 25: 00,392 -> 00: 25: 02.200
mas um ponto-e-vírgula finaliza esse pensamento.

527
00: 25: 02,200 -> 00: 25: 04.700
Agora, este sinal de igual é um pouco diferente da álgebra,

528
00: 25: 04,700 -> 00: 25: 07.750
se você pensar em seus dias de matemática, onde poderia dizer que x é igual a y.

529
00: 25: 07,750 -> 00: 25: 11.440
Quando x é igual a y, isso significa, literalmente, x é a mesma coisa que y.

530
00: 25: 11,440 -> 00: 25: 14.740
Mas aqui, o sinal de igual nas linguagens de programação

531
00: 25: 14,740 -> 00: 25: 17.990
normalmente é o tipo de movimento da direita para a esquerda.

532
00: 25: 17,990 -> 00: 25: 20.560
Este sinal de igual não significa tecnicamente igual.

533
00: 25: 20,560 -> 00: 25: 24.070
Significa atribuir, ou o operador de atribuição.

534
00: 25: 24,070 -> 00: 25: 27.200
Mova algo da direita para a esquerda.

535
00: 25: 27,200 -> 00: 25: 31.600
Então, se esta função get_string, assim como a função ask,

536
00: 25: 31,600 -> 00: 25: 35.140
pede ao usuário o nome dele e devolve um valor,

537
00: 25: 35,140 -> 00: 25: 37.930
você quer colocar esse nome em uma variável

538
00: 25: 37,930 -> 00: 25: 40.192
chamada de resposta, da direita para a esquerda.

539
00: 25: 40,192 -> 00: 25: 42.650
Então, embora nós - assim como escrevemos da direita para a esquerda,

540
00: 25: 42,650 -> 00: 25: 45.710
então você pensa sobre isso executando da direita para a esquerda.

541
00: 25: 45,710 -> 00: 25: 48.310
Então, neste ponto da história, agora temos

542
00: 25: 48,310 -> 00: 25: 52.960
em algum lugar da memória do computador, em uma chamada variável, a resposta do usuário

543
00: 25: 52,960 -> 00: 25: 54.130
ao seu nome.

544
00: 25: 54,130 -> 00: 25: 55.540
O que eu quero fazer com isso?

545
00: 25: 55,540 -> 00: 25: 58.093
Bem, em C, não há uma função de junção, então vamos

546
00: 25: 58,093 -> 00: 26: 00.010
ter que fazer isso um pouco diferente.

547
00: 26: 00,010 -> 00: 26: 03.613
Mas existe um tipo de função "say/diga", e como essa função foi chamada?

548
00: 26: 03,613 -> 00: 26: 04.340
PÚBLICO: Printf.

549
00:26:04,340 --> 00:26:05,173
DAVID MALAN: Printf.

550
00: 26: 05,173 -> 00: 26: 08.440
Então, printf é a função que pode ser acessada sempre que você quiser imprimir ou dizer algo

551
00: 26: 08,440 -> 00: 26: 09.320
na tela.

552
00: 26: 09,320 -> 00: 26: 10.993
Então, vou prosseguir e usar printf.

553
00: 26: 10,993 -> 00: 26: 13.660
E vou usar parênteses, porque parênteses significam, aqui

554
00: 26: 13,660 -> 00: 26: 18.670
com estas entradas, também conhecidas como argumentos ou parâmetros na programação.

555
00: 26: 18,670 -> 00: 26: 21.100
Mas esses são sinônimos para nossos propósitos.

556
00: 26: 21,100 -> 00: 26: 23.350
E agora isso não é um tanto óbvio, certo?

557
00: 26: 23,350 -> 00: 26: 29.180
Porque eu não quero apenas colocar, abre fecha aspas, "oi, vírgula, resposta".

558
00: 26: 29,180 -> 00: 26: 29.680
Por quê?

559
00: 26: 29,680 -> 00: 26: 34.480
Por que seria incorreto abre, fecha aspas, olá, vírgula, resposta?

560
00: 26: 34,480 -> 00: 26: 35.155
O que é isso?

561
00: 26: 35,155 -> 00: 26: 36.400
PÚBLICO: Vai apenas imprimir "resposta".

562
00: 26: 36,400 -> 00: 26: 39.323
DAVID MALAN: Certo, vai literalmente dizer olá, vírgula, resposta, certo?

563
00: 26: 39,323 -> 00: 26: 40.490
E não é isso que queremos.

564
00: 26: 40,490 -> 00: 26: 41.530
Não queremos dizer "Olá, resposta".

565
00: 26: 41,530 -> 00: 26: 43.450
Queremos dizer olá David ou olá Brian,

566
00: 26: 43,450 -> 00: 26: 45.280
ou quem quer esteja rodando este programa.

567
00: 26: 45,280 -> 00: 26: 49.900
Então, de alguma forma, preciso juntar a palavra hello com a entrada do usuário.

568
00: 26: 49,900 -> 00: 26: 53.335
E a maneira de fazer isso no printf é um pouco diferente do Scratch.

569
00: 26: 53,335 -> 00: 26: 55.550
Você usa o que é chamado de "placeholder/espaço reservado".

570
00: 26: 55,550 -> 00: 26: 57.550
Então você literalmente escreve a sentença ou frase

571
00: 26: 57.550 -> 00: 27: 00.220
que você quer dizer ou imprimir na tela,

572
00: 27: 00,220 -> 00: 27: 03.340
mas onde quer que você ainda não saiba o valor com antecedência,

573
00: 27: 03,340 -> 00: 27: 08.570
você coloca um espaço reservado usando um sinal de porcentagem e, em seguida, um s para representar sua string.

574
00: 27: 08,570 -> 00: 27: 11.320
E isso porque, é claro, se estou escrevendo este programa hoje,

575
00: 27: 11,320 -> 00: 27: 13.840
Não tenho ideia de quem vai executá-lo amanhã.

576
00: 27: 13,840 -> 00: 27: 15.910
Quero colocar dinamicamente um "placeholder/marcador de posição"

577
00: 27: 15,910 -> 00: 27: 19.400
então se alguém rodar este programa amanhã ou no dia seguinte,

578
00: 27: 19,400 -> 00: 27: 21.070
seu nome é inserido dinamicamente.

579
00: 27: 21,070 -> 00: 27: 23.410
Eu, claro, não sei o nome deles hoje.

580
00: 27: 23,410 -> 00: 27: 26.350
Portanto, entre aspas, aspas, "olá, vírgula, %s".

581
00: 27: 26,350 -> 00: 27: 30.130
E esse %s é apenas um espaço reservado para tudo o que eu quiser inserir lá.

582
00: 27: 30,130 -> 00: 27: 32.590
"barra invertida n", é claro, significa apenas nova linha.

583
00: 27: 32,590 -> 00: 27: 35.590
Portanto, a única coisa nova aqui é esse percentual s.

584
00: 27: 35,590 -> 00: 27: 39.490
Agora, acontece que funções em C, assim como em Scratch,

585
00: 27: 39,490 -> 00: 27: 40.990
podem não ter argumentos.

586
00:27:40,990 --> 00:27:42,550
Ou podem ter argumentos.

587
00:27:42,550 --> 00:27:44,650
Ou podem ter 2 ou mais argumentos.

588
00: 27: 44,650 -> 00: 27: 49.310
E se elas tiverem dois ou mais, basta separá-los com vírgulas.

589
00: 27: 49,310 -> 00: 27: 50.450
Então, a maneira como printf funciona -

590
00: 27: 50,450 -> 00: 27: 53.200
e você só saberia disso, novamente, sendo ensinado ou lendo

591
00: 27: 53,200 -> 00: 27: 55.720
a documentação - é que você pode, sim,

592
00: 27: 55,720 -> 00: 27: 59.560
fornecer apenas uma única string como entrada -

593
00: 27: 59,560 -> 00: 28: 00.910
entre aspas, alguma coisa.

594
00: 28: 00,910 -> 00: 28: 03.010
Mas se você tiver alguns "placeholders/marcadores" lá,

595
00: 28: 03,010 -> 00: 28: 06.520
você pode dizer ao computador o que concatenar adicionando uma vírgula

596
00: 28: 06,520 -> 00: 28: 10.570
e, em seguida, o nome do valor ou variável que você deseja conectar.

597
00: 28: 10,570 -> 00: 28: 14.120
Portanto, agora, essas duas linhas de código são equivalentes a estas aqui.

598
00: 28: 14,120 -> 00: 28: 15.870
Mas, novamente, embora à primeira vista,

599
00: 28: 15,870 -> 00: 28: 17.620
pode parecer especialmente enigmático, se você apenas

600
00: 28: 17,620 -> 00: 28: 19.480
decompô-lo em componentes individuais

601
00: 28: 19,480 -> 00: 28: 23.020
da direita para a esquerda e de fora para dentro,

602
00: 28: 23,020 -> 00: 28: 28.150
você pode genericamente supor até mesmo o que um novo código que você nunca viu antes

603
00: 28: 28,150 -> 00: 28: 29.860
está fazendo.

604
00: 28: 29,860 -> 00: 28: 33.880
Alguma dúvida sobre essas duas linhas do Scratch ou C?

605
00: 28: 33,880 -> 00: 28: 34.594
Sim?

606
00: 28: 34,594 -> 00: 28: 36.570
PÚBLICO: Você pode adicionar [INAUDÍVEL]?

607
00: 28: 36,570 -> 00: 28: 40.220


608
00: 28: 40,220 -> 00: 28: 41.220
DAVID MALAN: Com certeza.

609
00: 28: 41,220 -> 00: 28: 42.450
Você pode adicionar outras variáveis?

610
00: 28: 42,450 -> 00: 28: 46.290
Se eu tivesse mais variáveis ​​neste programa, graças a mais linhas de código,

611
00: 28: 46,290 -> 00: 28: 49.740
Eu poderia apenas fazer vírgula, outra coisa, vírgula, outra coisa, vírgula.

612
00: 28: 49,740 -> 00: 28: 52.620
E eu poderia ter apenas um "placeholder" nesta 

613
00: 28: 52,620 -> 00: 28: 56.340
expressão para todas as variáveis ​​que desejo inserir.

614
00: 28: 56,340 -> 00: 28: 57.670
E eles vão da esquerda para a direita.

615
00: 28: 57,670 -> 00: 29: 00.510
Então, se eu tivesse dois sinais de "%" aqui, o primeiro

616
00: 29: 00,510 -> 00: 29: 01.890
viria após a primeira vírgula.

617
00: 29: 01,890 -> 00: 29: 04.481
O segundo viria após a segunda vírgula.

618
00: 29: 04,481 -> 00: 29: 06.485
PÚBLICO: Então você precisa de %s [INAUDÍVEL] ??

619
00: 29: 06,485 -> 00: 29: 07.360
DAVID MALAN: Correto.

620
00: 29: 07,360 -> 00: 29: 10.962
Você precisa de um %s para qualquer "placeholder" que deseja inserir, se for uma string.

621
00: 29: 10,962 -> 00: 29: 13.420
E veremos outros "placeholders" em apenas um momento.

622
00: 29: 13,420 -> 00: 29: 14.720
Boa pergunta.

623
00: 29: 14,720 -> 00: 29: 16.464
Outras perguntas?

624
00: 29: 16,464 -> 00: 29: 17.230
Não?

625
00: 29: 17,230 -> 00: 29: 18.440
Oh, sim, la trás.

626
00: 29: 18,440 -> 00: 29: 20.705
PÚBLICO: Existe outra maneira de concatenar strings?

627
00: 29: 20,705 -> 00: 29: 23.080
DAVID MALAN: Existe outra maneira de concatenar strings?

628
00: 29: 23,080 -> 00: 29: 26.533
Resposta curta - sim, de muitas maneiras, nenhuma delas fácil.

629
00: 29: 26,533 -> 00: 29: 29.200
Então, vamos chegar a isso, na verdade, em algumas semanas.

630
00: 29: 29,200 -> 00: 29: 33.290
Printf, por enquanto, é de longe a maneira mais fácil de fazer isso.

631
00: 29: 33,290 -> 00: 29: 34.175
Outras perguntas?

632
00: 29: 34,175 -> 00: 29: 36.550
Se eu não enxergar as mãos de vocês, é porque há tanto brilho.

633
00: 29: 36,550 -> 00: 29: 37.510
Apenas chame.

634
00: 29: 37,510 -> 00: 29: 38.200
Por aqui.

635
00: 29: 38,200 -> 00: 29: 40.550
OK, vocês três.

636
00: 29: 40,550 -> 00: 29: 41.571
Aqui à direita.

637
00: 29: 41,571 -> 00: 29: 43.890
PÚBLICO: [INAUDÍVEL].

638
00: 29: 43,890 -> 00: 29: 44.640
DAVID MALAN: Claro.

639
00: 29: 44,640 -> 00: 29: 45.420
O que é uma string?

640
00: 29: 45,420 -> 00: 29: 50.530
Uma string é uma sequência de zero ou mais caracteres entre aspas duplas.

641
00: 29: 50,530 -> 00: 29: 54.060
Colocado de outra forma, é uma palavra, uma frase, uma sentença, um parágrafo - zero

642
00: 29: 54,060 -> 00: 29: 58.883
ou mais caracteres, letras do alfabeto, entre aspas duplas.

643
00: 29: 58,883 -> 00: 29: 59.550
Outras perguntas?

644
00: 29: 59,550 -> 00: 30: 01.100
Sim?

645
00: 30: 01,100 -> 00: 30: 07.083
PÚBLICO: O que aconteceria se sua barra invertida estivesse fora das aspas.

646
00: 30: 07,083 -> 00: 30: 08.500
DAVID MALAN: Boa pergunta.

647
00: 30: 08,500 -> 00: 30: 11.270
O que aconteceria se sua barra invertida n estivesse fora das aspas?

648
00: 30: 11,270 -> 00: 30: 12.210
Bem, deixe-me fazer isso.

649
00: 30: 12,210 -> 00: 30: 14.210
E, francamente, esse é o instinto certo de se ter.

650
00: 30: 14,210 -> 00: 30: 17.250
A qualquer momento, a frente, que você tenha as mesmas perguntas instintivas,

651
00: 30: 17,250 -> 00: 30: 17.880
apenas tente.

652
00: 30: 17,880 -> 00: 30: 19.770
Você não pode fazer mal ao computador.

653
00: 30: 19,770 -> 00: 30: 22.170
Então deixe-me ir em frente e acidentalmente, se vocês me permitem,

654
00: 30: 22,170 -> 00: 30: 24.510
coloque a barra invertida n fora das aspas,

655
00: 30: 24,510 -> 00: 30: 25.978
é o que eu acho que foi sua pergunta.

656
00: 30: 25,978 -> 00: 30: 27.520
Tudo bem, então vamos ver o que acontece.

657
00: 30: 27,520 -> 00: 30: 29.490
Então, vou agora e executar o Clang.

658
00: 30: 29,490 -> 00: 30: 31.470
Eu sei como fazer um nome personalizado agora,

659
00: 30: 31,470 -> 00: 30: 34.380
então vou adotar essa convenção. -o hello.

660
00: 30: 34,380 -> 00: 30: 36.720
E agora vou dizer hello.c

661
00: 30: 36,720 -> 00: 30: 38.940
que eu acho que vai quebrar.

662
00: 30: 38,940 -> 00: 30: 41.910
E, de fato, algo, de fato, quebrou aqui.

663
00: 30: 41,910 -> 00: 30: 43.420
Vamos ver qual é o erro.

664
00: 30: 43,420 -> 00: 30: 48.210
Portanto, é um pouco arcaico também, mas hello.c, dois pontos 5, dois pontos 26.

665
00: 30: 48,210 -> 00: 30: 49.240
O que está acontecendo lá?

666
00: 30: 49,240 -> 00: 30: 50.370
Bem, deixe-me diminuir o zoom.

667
00: 30: 50,370 -> 00: 30: 53.110
Sempre que você cometer um erro em seu código como este,

668
00: 30: 53,110 -> 00: 30: 57.870
O Clang vai tentar ajudá-lo a descobrir onde está esse erro ou bug.

669
00: 30: 57,870 -> 00: 31: 02.760
Portanto, hello.c Dois pontos 5 significa procurar na linha 5 por seu erro.

670
00: 31: 02,760 -> 00: 31: 07.930
Então, veja, ele diz erro - esperado parênteses de fechamento bem por aqui.

671
00: 31: 07,930 -> 00: 31: 11.500
Então é um pouco estranho, porque não, eu não quero fechar parênteses,

672
00: 31: 11,500 -> 00: 31: 12.000
Eu acho.

673
00: 31: 12.000 -> 00: 31: 13.170
Eu quero a nova linha.

674
00: 31: 13,170 -> 00: 31: 16.080
Portanto, não é perfeitamente capaz de dizer a você, ei,

675
00: 31: 16,080 -> 00: 31: 18.450
essa "\n" deve estar entre as aspas.

676
00: 31: 18,450 -> 00: 31: 21.780
Mas pode pelo menos ajudá-lo a descobrir onde está o erro.

677
00: 31: 21,780 -> 00: 31: 24.000
Então, está em algum lugar por aí, ao qual

678
00: 31: 24.000 -> 00: 31: 26.850
sua própria memória ou sua própria pesquisa no Google deve funcionar para descobrir,

679
00: 31: 26,850 -> 00: 31: 29.717
oh, isso tem que estar entre as aspas.

680
00: 31: 29,717 -> 00: 31: 30.300
Boa pergunta.

681
00: 31: 30,300 -> 00: 31: 31.883
Houve uma terceira pergunta lá atrás?

682
00: 31: 31,883 -> 00: 31: 32.430
Sim?

683
00: 31: 32,430 -> 00: 31: 32.930
Não?

684
00: 31: 32,930 -> 00: 31: 33.480
ESTÁ BEM.

685
00: 31: 33,480 -> 00: 31: 37.860
Tudo bem, então vamos prosseguir agora e fazer a transição para alguns outros recursos

686
00: 31: 37,860 -> 00: 31: 39.360
que podemos fazer, também -

687
00: 31: 39,360 -> 00: 31: 42.630
ou seja, implementar o mesmo programa que acabei de fazer.

688
00: 31: 42,630 -> 00: 31: 45.600
Vou fechar este arquivo e criar um novo chamado,

689
00: 31: 45,600 -> 00: 31: 49.173
digamos, string.c, porque agora estou fazendo experiências com strings.

690
00: 31: 49,173 -> 00: 31: 50.590
E vou começar como antes -

691
00: 31: 50,590 -> 00: 31: 55.260
incluir stdio.h int main void.

692
00: 31: 55,260 -> 00: 32: 01.470
E então vou prosseguir aqui e dizer string resposta get_string,

693
00: 32: 01,470 -> 00: 32: 07.020
entre aspas, qual é o seu nome, ponto de interrogação, "\n", ponto e vírgula.

694
00: 32: 07,020 -> 00: 32: 09.448
E, à parte, tudo que eu digito no teclado

695
00: 32: 09,448 -> 00: 32: 11.490
hoje vamos postar no site do curso depois.

696
00: 32: 11,490 -> 00: 32: 15.010
Portanto, não há necessidade de digitar cada pequeno caractere, se você não quiser.

697
00: 32: 15,010 -> 00: 32: 18.448
E então vou dizer printf, abre aspas fecha aspas, olá, resposta.

698
00: 32: 18,448 -> 00: 32: 20.490
Não "resposta", porque afirmamos que isso era ruim.

699
00: 32: 20,490 -> 00: 32: 22.440
Isso diria literalmente resposta.

700
00: 32: 22,440 -> 00: 32: 24.750
Eu quero fazer um placeholder, %s.

701
00: 32: 24,750 -> 00: 32: 29.920
E agora "\n", vírgula, resposta, ponto e vírgula.

702
00: 32: 29,920 -> 00: 32: 32.910
Então Acho que transcrevi o código do slide

703
00: 32: 32,910 -> 00: 32: 37.920
em meu ambiente de programação agora em um arquivo chamado string.c.

704
00: 32: 37,920 -> 00: 32: 39.300
Então, deixe-me ir em frente e diminuir o zoom.

705
00: 32: 39,300 -> 00: 32: 41.790
E se eu quiser compilar este programa, convertê-lo

706
00: 32: 41,790 -> 00: 32: 46.795
do código-fonte ao código de máquina, que comando posso digitar aqui?

707
00: 32: 46,795 -> 00: 32: 47.295
Então, Clang.

708
00: 32: 47,295 -> 00: 32: 50.150


709
00: 32: 50,150 -> 00: 32: 51.210
Então string.c.

710
00: 32: 51,210 -> 00: 32: 53.590
Mas isso vai me dar um programa, por padrão, chamado

711
00: 32: 53,590 -> 00: 32: 56.030
a.out, o que é muito inútil.

712
00: 32: 56,030 -> 00: 32: 58.670
Então, deixe-me ir em frente e dizer -o string, apenas para

713
00: 32: 58,670 -> 00: 33: 00.230
que meu programa seja chamado de string

714
00: 33: 00,230 -> 00: 33: 02.090
Mas eu poderia chamá-lo do que eu quiser.

715
00: 33: 02,090 -> 00: 33: 04.975
Eu poderia chamá-lo de programa dois, se preferir.

716
00: 33: 04,975 -> 00: 33: 06.350
Deixe-me ir em frente e pressione Enter.

717
00: 33: 06,350 -> 00: 33: 10.220
E ai meu Deus, há mais erros do que linhas

718
00: 33: 10,220 -> 00: 33: 12.320
de código, o que é um pouco preocupante.

719
00: 33: 12,320 -> 00: 33: 15.530
E esta segunda camada é onde você deve se consolar, pois isso significa apenas

720
00: 33: 15,530 -> 00: 33: 17.113
o computador ficou confuso, certo?

721
00: 33: 17,113 -> 00: 33: 20.480
Você não é tão ruim em programação que gera mais erros do que linhas

722
00: 33: 20,480 -> 00: 33: 21.860
de código que você mesmo escreveu.

723
00: 33: 21,860 -> 00: 33: 25.370
É que o computador ficou realmente confuso em algum momento,

724
00: 33: 25,370 -> 00: 33: 28.670
e meio que começa a tropeçar em si mesmo, por assim dizer, conceitualmente.

725
00: 33: 28,670 -> 00: 33: 31.910
Ele não sabe onde está o erro, então começa a interpretar mal o código correto

726
00: 33: 31,910 -> 00: 33: 33.020
como código incorreto.

727
00: 33: 33,020 -> 00: 33: 38.100
Portanto, o ponto de partida é sempre a primeira mensagem de erro.

728
00: 33: 38,100 -> 00: 33: 41.450
Então, você notará que eu já rolei até o comando

729
00: 33: 41,450 -> 00: 33: 44.570
que digitei, que estava bem aqui, como destaquei.

730
00: 33: 44,570 -> 00: 33: 47.270
Concentre-se no primeiro erro que você vê e talvez nos outros

731
00: 33: 47,270 -> 00: 33: 50.985
são apenas erros fantasmas, confusões que surgiram em seu lugar.

732
00: 33: 50,985 -> 00: 33: 53.360
Então, deixe-me ir em frente e ampliar essa parte da tela

733
00: 33: 53,360 -> 00: 33: 55.700
e ver se não podemos diagnosticar esse problema.

734
00: 33: 55,700 -> 00: 33: 59.420
O comando que executei foi Clang -o string string.c.

735
00: 33: 59,420 -> 00: 34: 02.480
Isso significa apenas que minha entrada é meu código-fonte em string.c.

736
00: 34: 02,480 -> 00: 34: 06.500
Quero que minha saída seja um código de máquina em um arquivo chamado string.

737
00: 34: 06,500 -> 00: 34: 09.409
Tudo bem, string.c linha 5 é onde o erro começa,

738
00: 34: 09,409 -> 00: 34: 11.540
então esse parece ser um local familiar.

739
00: 34: 11,540 -> 00: 34: 13.820
Uso de identificador "string" não declarado.

740
00: 34: 13,820 -> 00: 34: 19.960
Você quis dizer - antecipação - stdin?

741
00: 34: 19,960 -> 00: 34: 21.280
Não, não quis.

742
00: 34: 21,280 -> 00: 34: 22.600
Eu quis dizer string neste caso.

743
00: 34: 22,600 -> 00: 34: 25.159
Então, aqui também, o computador ficou confuso,

744
00: 34: 25,159 -> 00: 34: 28.179
e mesmo que seja uma útil mensagem em verde na verdade não é útil.

745
00: 34: 28,179 -> 00: 34: 29.679
Não, eu quero uma string.

746
00: 34: 29,679 -> 00: 34: 31.270
Eu não quero "standard n".

747
00: 34: 31,270 -> 00: 34: 34.060
Mas a razão para isso é que, tecnicamente,

748
00: 34: 34,060 -> 00: 34: 37.420
pelo menos neste ponto da história, não existe essa tal de string,

749
00: 34: 37,420 -> 00: 34: 41.699
S-T-R-I-N-G em C. Na verdade, é uma espécie de rodinhas de apoio

750
00: 34: 41,699 -> 00: 34: 44.949
vamos usar por apenas algumas semanas até que, para sua pergunta anterior,

751
00: 34: 44,949 -> 00: 34: 48.340
vamos mostrar o que realmente está acontecendo sob o capô do computador,

752
00: 34: 48,340 -> 00: 34: 51.130
por assim dizer, quando se trata de implementar uma string.

753
00: 34: 51,130 -> 00: 34: 56.620
Então string é algo que o curso CS50 oferece a você

754
00: 34: 56,620 -> 00: 35: 01.570
em um arquivo chamado CS50.h.

755
00: 35: 01,570 -> 00: 35: 06.355
Assim como existe um arquivo chamado "stardard I/O"-

756
00: 35: 06,355 -> 00: 35: 10.330
onde I/O significa apenas "input/output" entrada/saída, como imprimir e obter entrada.

757
00: 35: 10,330 -> 00: 35: 16.060
Assim como existe um arquivo chamado stdio.h, no qual printf foi inventado,

758
00: 35: 16,060 -> 00: 35: 19.420
todas essas outras funções que posso usar neste programa,

759
00: 35: 19,420 -> 00: 35: 25.000
como get_string, está armazenado em um arquivo chamado CS50.h.

760
00: 35: 25.000 -> 00: 35: 28.150
Então, meu problema surgiu um momento atrás, ao compilar este código,

761
00: 35: 28,150 -> 00: 35: 30.640
porque o computador não tinha ideia do que é uma string.

762
00: 35: 30,640 -> 00: 35: 34.870
E não tem ideia - veremos o que é a função get_string.

763
00: 35: 34,870 -> 00: 35: 37.570
Deixe-me ir em frente e recompilar isso agora.

764
00: 35: 37,570 -> 00: 35: 46.130
Vou prosseguir e fazer Clang -o string string.c e aumentar o zoom.

765
00: 35: 46,130 -> 00: 35: 46.630
Aqui vamos nós.

766
00: 35: 46,630 -> 00: 35: 47.820
Enter.

767
00: 35: 47,820 -> 00: 35: 49.930
OK, progresso.

768
00: 35: 49,930 -> 00: 35: 51.100
Ainda é um bug.

769
00: 35: 51,100 -> 00: 35: 53.230
Ainda há um erro, porque o vermelho não pode

770
00: 35: 53,230 -> 00: 35: 54.850
significa qualquer coisa boa neste contexto.

771
00: 35: 54,850 -> 00: 35: 56.590
E, de fato, é um erro.

772
00: 35: 56,590 -> 00: 35: 58.940
Mas são muito menos erros.

773
00: 35: 58,940 -> 00: 36: 02.080
Portanto, este é o último comando que precisamos apresentar agora.

774
00: 36: 02,080 -> 00: 36: 04.240
Observe o que a mensagem de erro está dizendo.

775
00: 36: 04,240 -> 00: 36: 07.450
Depois de executar o Clang -o string string.c, há

776
00: 36: 07,450 -> 00: 36: 09.490
ainda é um problema na minha função principal.

777
00: 36: 09,490 -> 00: 36: 11.170
Qual é o problema?

778
00: 36: 11,170 -> 00: 36: 13.480
Referência indefinida para get_string.

779
00: 36: 13,480 -> 00: 36: 18.490
Portanto, ao usar a biblioteca CS50, você precisa fazer duas coisas.

780
00: 36: 18,490 -> 00: 36: 21.100
Em seu código-fonte, você tem que dizer ao computador

781
00: 36: 21,100 -> 00: 36: 23.800
para incluir este arquivo CS50.h, onde, novamente,

782
00: 36: 23,800 -> 00: 36: 26.860
funções como get_string e a palavra string

783
00: 36: 26,860 -> 00: 36: 28.870
são realmente implementados para você.

784
00: 36: 28,870 -> 00: 36: 32.170
Mas ao compilar seu código, você precisa, de forma um tanto redundante

785
00: 36: 32,170 -> 00: 36: 37.060
mas por diferentes razões, dizer ao computador para adicionar todo o código

786
00: 36: 37,060 -> 00: 36: 40.600
que a equipe do CS50 escreveu para implementar get_string e string

787
00: 36: 40,600 -> 00: 36: 44.110
e outras funções como esta.

788
00: 36: 44,110 -> 00: 36: 50.530
Então escrever Clang -o string string.c, como antes,

789
00: 36: 50,530 -> 00: 36: 54.400
mas preciso dizer ao computador esta instrução especial

790
00: 36: 54,400 -> 00: 36: 56.410
para vinculá-lo ao CS50.

791
00: 36: 56,410 -> 00: 36: 59.320
E isso fará mais sentido em apenas algumas semanas.

792
00: 36: 59,320 -> 00: 37: 02.620
Mas isso é apenas um -l para link e CS50.

793
00: 37: 02,620 -> 00: 37: 04.720
E tudo isso diz que o computador o que é isso -

794
00: 37: 04,720 -> 00: 37: 10.550
os zeros e uns para o meu programa real virão de string.c certo

795
00: 37: 10,550 -> 00: 37: 11.050
aqui.

796
00: 37: 11,050 -> 00: 37: 12.400
Este é meu código-fonte.

797
00: 37: 12,400 -> 00: 37: 16.780
Mas a equipe do CS50, anos atrás, também escreveu código em C para

798
00: 37: 16,780 -> 00: 37: 19.420
fornecer funções como get_string, para

799
00: 37: 19,420 -> 00: 37: 22.390
fornecer variáveis ​​como strings.

800
00: 37: 22,390 -> 00: 37: 27.070
Os zeros e uns da biblioteca CS50 são armazenados em outro lugar na nuvem.

801
00: 37: 27,070 -> 00: 37: 29.920
Eles precisam estar ligados aos seus.

802
00: 37: 29,920 -> 00: 37: 34.000
Então, assim como seu código está neste arquivo, nosso código está nesse arquivo.

803
00: 37: 34.000 -> 00: 37: 37.330
E assim, dizendo ao computador para incluí-lo em seu código-fonte

804
00: 37: 37,330 -> 00: 37: 40.980
e vinculá-lo a este comando é apenas a maneira arcaica de dizer,

805
00: 37: 40,980 -> 00: 37: 46.930
combine meu código com o código do CS50 em um programa que eu possa realmente executar.

806
00: 37: 46,930 -> 00: 37: 49.180
Agora, tudo isso, francamente é muito rápido

807
00: 37: 49,180 -> 00: 37: 53.170
tornando-se muito opressor, eu acho, e muito desnecessariamente complicado.

808
00: 37: 53,170 -> 00: 37: 56.200
Portanto, há uma maneira melhor do que essa.

809
00: 37: 56,200 -> 00: 38: 00.310
Acontece que, seguindo em frente, se você gostaria de compilar seu código,

810
00: 38: 00,310 -> 00: 38: 01.720
você não precisa se lembrar.

811
00: 38: 01,720 -> 00: 38: 03.935
Você não precisa se lembrar de -l CS50.

812
00: 38: 03,935 -> 00: 38: 07.060
Você não precisa se lembrar de nenhum desses comandos, espero que apenas das ideias.

813
00: 38: 07,060 -> 00: 38: 12.130
Em vez disso, você pode dizer, faça-me um programa chamado string e pronto.

814
00: 38: 12,130 -> 00: 38: 15.970
Toda essa saída é gerada automaticamente para você

815
00: 38: 15,970 -> 00: 38: 18.610
quando você disser ao computador, "make/faça" meu programa.

816
00: 38: 18,610 -> 00: 38: 24.130
E o programa "make" descobrirá quais argumentos de linha de comando usar,

817
00: 38: 24,130 -> 00: 38: 26.800
que nome dar ao arquivo, quais bibliotecas

818
00: 38: 26,800 -> 00: 38: 29.650
ou código que outras pessoas escreveram para serem ligados no seu.

819
00: 38: 29,650 -> 00: 38: 32.500
Portanto, de agora em diante, quando você quiser compilar seu programa,

820
00: 38: 32,500 -> 00: 38: 36.460
literalmente, diga apenas  "make" e o nome do programa.

821
00: 38: 36,460 -> 00: 38: 38.680
Mas não é "make string.c".

822
00: 38: 38,680 -> 00: 38: 41.260
É só "make" e o nome do programa.

823
00: 38: 41,260 -> 00: 38: 43.180
Make, este outro programa, descobrirá

824
00: 38: 43,180 -> 00: 38: 46.630
que você quis dizer algo chamado string.c.

825
00: 38: 46,630 -> 00: 38: 48.910
E posso retroceder e fazer isso para hello também.

826
00: 38: 48,910 -> 00: 38: 50.770
make hello.

827
00: 38: 50,770 -> 00: 38: 53.150
Oh, eu nunca corrigi o problema de antes.

828
00: 38: 53,150 -> 00: 38: 56.660
Então, deixe-me entrar em hello.c abrindo esse arquivo.

829
00: 38: 56,660 -> 00: 38: 59.740
Deixe-me consertar isso para a posteridade.

830
00: 38: 59,740 -> 00: 39: 02.110
Salvar este arquivo ou deixe o arquivo ser salvo automaticamente.

831
00: 39: 02,110 -> 00: 39: 03.310
Agora make hello.

832
00: 39: 03,310 -> 00: 39: 06.100
E viola, fez a mesma coisa pra mim agora.

833
00: 39: 06,100 -> 00: 39: 06.820
Sim?

834
00: 39: 06,820 -> 00: 39: 09.543
PÚBLICO: make é algo padrão... [INAUDÍVEL] ?..

835
00: 39: 09,543 -> 00: 39: 10.960
DAVID MALAN: Boa pergunta.

836
00: 39: 10,960 -> 00: 39: 13.300
"make é algo padrão ou específico do CS50?

837
00: 39: 13,300 -> 00: 39: 16.280
Não é uma coisa específica do CS50.

838
00: 39: 16,280 -> 00: 39: 19.460
É uma ferramenta padrão que existe em Macs, PCs e computadores

839
00: 39: 19,460 -> 00: 39: 21.410
geralmente executando Unix ou Linux.

840
00: 39: 21,410 -> 00: 39: 24.020
E, de fato, a ferramenta sandbox que estamos usando

841
00: 39: 24,020 -> 00: 39: 26.480
é em si um computador na nuvem, embora apenas

842
00: 39: 26,480 -> 00: 39: 30.960
tem essas duas janelas, guias no topo e a janela do terminal embaixo.

843
00: 39: 30,960 -> 00: 39: 32.960
Ao fazer login no CS50 Sandbox, você tem acesso

844
00: 39: 32,960 -> 00: 39: 36.620
ao seu próprio servidor na nuvem executando um sistema operacional chamado Linux.

845
00: 39: 36,620 -> 00: 39: 41.600
E Clang e make e outras ferramentas que veremos, como ls e rm,

846
00: 39: 41,600 -> 00: 39: 43.700
todos existem nesse sistema operacional.

847
00: 39: 43,700 -> 00: 39: 46.580
Eles não são específicos do CS50.

848
00: 39: 46,580 -> 00: 39: 47.768
Sim?

849
00: 39: 47,768 -> 00: 39: 51.235
PÚBLICO: Com isso, hello seria código de máquina, não [INAUDÍVEL] ??

850
00: 39: 51,235 -> 00: 39: 52.110
DAVID MALAN: Correto.

851
00:39:52,110 --> 00:39:53,520
Hello é o código de máquina.

852
00: 39: 53,520 -> 00: 39: 55.756
Hello.c é o código-fonte.

853
00: 39: 55,756 -> 00: 39: 57.244
PÚBLICO: Então [INAUDÍVEL]?

854
00: 39: 57,244 -> 00: 40: 00.915


855
00: 40: 00,915 -> 00: 40: 01.790
DAVID MALAN: Correto.

856
00: 40: 01,790 -> 00: 40: 06.110
Make é um programa inteligente projetado para tornar nossas vidas mais fáceis, sem trocadilhos,

857
00: 40: 06,110 -> 00: 40: 11.210
onde se você fizer "make hello", ele procurará um arquivo chamado hello.c.

858
00: 40: 11,210 -> 00: 40: 14.450
E se o encontrar, criará o programa chamado hello

859
00: 40: 14,450 -> 00: 40: 16.630
do código-fonte ao código de máquina, respectivamente.

860
00: 40: 16,630 -> 00: 40: 17.267
Sim?

861
00: 40: 17,267 -> 00: 40: 18.698
PÚBLICO: [INAUDÍVEL].

862
00: 40: 18,698 -> 00: 40: 22.498


863
00: 40: 22,498 -> 00: 40: 23.540
DAVID MALAN: Não exatamente.

864
00: 40: 23,540 -> 00: 40: 27.770
Portanto, make é um programa que vem com um sistema operacional chamado Linux,

865
00: 40: 27,770 -> 00: 40: 29.150
e também vem com Mac OS.

866
00: 40: 29,150 -> 00: 40: 31.160
E hoje em dia, também vem com o Windows.

867
00: 40: 31,160 -> 00: 40: 34.040
É um programa que você pode executar digitando seu nome,

868
00: 40: 34,040 -> 00: 40: 37.147
não que você execute clicando duas vezes em um ícone.

869
00: 40: 37,147 -> 00: 40: 37.730
Boa pergunta.

870
00: 40: 37,730 -> 00: 40: 38.882
Sim?

871
00: 40: 38,882 -> 00: 40: 39.854
PÚBLICO: [INAUDÍVEL]?

872
00: 40: 39,854 -> 00: 40: 43.755


873
00: 40: 43,755 -> 00: 40: 44.880
DAVID MALAN: Boa pergunta.

874
00: 40: 44,880 -> 00: 40: 46.610
Isso significa que o make está armazenado no seu computador

875
00: 40: 46,610 -> 00: 40: 47.930
ou no computador baseado em nuvem?

876
00: 40: 47,930 -> 00: 40: 49.350
No computador baseado em nuvem.

877
00: 40: 49,350 -> 00: 40: 52.100
Então, até esse ponto do semestre, e nas primeiras semanas,

878
00: 40: 52,100 -> 00: 40: 55.310
tudo o que fizermos será na nuvem em um ambiente padronizado

879
00: 40: 55,310 -> 00: 40: 58.670
chamado CS50 Sandbox e, em breve, algo chamado CS50 Lab.

880
00: 40: 58,670 -> 00: 41: 02.780
Mas é projetado para ser uma representação de um computador Linux padrão

881
00: 41: 02,780 -> 00: 41: 04.210
e também um Mac ou PC.

882
00: 41: 04,210 -> 00: 41: 05.960
Mas o software tende a ser um pouco diferente,

883
00: 41: 05,960 -> 00: 41: 09.470
então padronizamos no Linux, que é um sistema operacional muito popular

884
00: 41: 09,470 -> 00: 41: 12.140
no mundo do desenvolvimento de software.

885
00: 41: 12,140 -> 00: 41: 15.265
Tudo bem, então vamos dar uma olhada em algumas outras equivalências e então

886
00: 41: 15,265 -> 00: 41: 18.015
comparações e começar a escrever programas mais interessantes do que estes

887
00: 41: 18,015 -> 00: 41: 19.220
que apenas dizem olá, mundo.

888
00: 41: 19,220 -> 00: 41: 22.400
Então, aqui está, novamente, um resumo de como você tecnicamente

889
00: 41: 22,400 -> 00: 41: 25.070
deve converter seu código fonte em código de máquina

890
00: 41: 25,070 -> 00: 41: 28.580
usando um programa chamado Clang com um argumento de linha de comando,

891
00: 41: 28,580 -> 00: 41: 33.322
um parâmetro especial, -o hello, para nomear o arquivo de outra forma.

892
00: 41: 33,322 -> 00: 41: 35.780
E honestamente, ninguém nunca vai se lembrar desse comando.

893
00: 41: 35,780 -> 00: 41: 37.905
E mesmo se você fizer isso, é muito entediante digitar.

894
00: 41: 37,905 -> 00: 41: 40.250
É por isso que programas como o make existem, que

895
00: 41: 40,250 -> 00: 41: 42.142
apenas automatize exatamente o mesmo processo.

896
00: 41: 42,142 -> 00: 41: 43.850
Mas eles ainda estão fazendo a mesma coisa -

897
00: 41: 43,850 -> 00: 41: 46.700
compilar seu código-fonte em código de máquina.

898
00: 41: 46,700 -> 00: 41: 48.500
E para executar o programa depois disso, você diz

899
00: 41: 48,500 -> 00: 41: 50.920
ponto, que se refere apenas à sua pasta atual,

900
00: 41: 50,920 -> 00: 41: 54.140
porque veremos que você pode ter várias pastas em um servidor, e hello

901
00: 41: 54,140 -> 00: 41: 55.510
é o nome do programa.

902
00: 41: 55,510 -> 00: 41: 58.760
Tudo bem, vamos dar uma olhada em alguns outros tipos de recursos do Scratch

903
00: 41: 58,760 -> 00: 42: 00.510
e ver como ficam em C,

904
00: 42: 00,510 -> 00: 42: 04.560
e então começaremos a implementar alguns programas em C mais manualmente.

905
00: 42: 04,560 -> 00: 42: 07.130
Portanto, considere este exemplo aqui, que foi um exemplo

906
00: 42: 07,130 -> 00: 42: 11.450
de que tipo de característica no Scratch?

907
00: 42: 11,450 -> 00: 42: 13.300
Isso fez o quê por nós?

908
00: 42: 13,300 -> 00: 42: 14.260
PÚBLICO: Variável.

909
00: 42: 14,260 -> 00: 42: 16.000
DAVID MALAN: Este foi um exemplo de variável.

910
00: 42: 16.000 -> 00: 42: 18.167
E essa variável, neste caso, foi chamada de contador.

911
00: 42: 18,167 -> 00: 42: 21.130
E nós a inicializamos como-- isto é, nós o definimos igual a-- zero.

912
00: 42: 21,130 -> 00: 42: 24.220
Em C, do lado direito, se quisermos obter este mesmo resultado

913
00: 42: 24,220 -> 00: 42: 27.190
de hoje em diante, você vai literalmente dizer o nome da variável,

914
00: 42: 27,190 -> 00: 42: 30.490
como contador, mas você pode chamá-lo do que quiser, igual a zero.

915
00: 42: 30,490 -> 00: 42: 33.198
Porque lembre-se de que o sinal de igual é o operador de atribuição.

916
00: 42: 33,198 -> 00: 42: 34.990
Então, o que está à direita vai ser

917
00: 42: 34,990 -> 00: 42: 37.210
copiado para o que estiver à esquerda.

918
00: 42: 37,210 -> 00: 42: 41.200
No entanto, isso não é suficiente, porque quando você declara uma variável

919
00: 42: 41,200 -> 00: 42: 44.230
e você diz, ei, computador, preciso de algum armazenamento para algum valor,

920
00: 42: 44,230 -> 00: 42: 47.950
você tem que dizer ao computador qual é o tipo dessa variável.

921
00: 42: 47,950 -> 00: 42: 52.000
Vimos que strings são variáveis ​​que armazenam várias palavras.

922
00: 42: 52.000 -> 00: 42: 55.000
Mas, neste caso, queremos armazenar um número.

923
00: 42: 55.000 -> 00: 42: 58.390
E em C, esse tipo de número é chamado de int ou integer,

924
00: 42: 58,390 -> 00: 43: 00.070
mas I-N-T para abreviar.

925
00: 43: 00,070 -> 00: 43: 02.147
Há uma coisa faltando nesta linha de código.

926
00: 43: 02,147 -> 00: 43: 02.980
PÚBLICO: Ponto e vírgula.

927
00: 43: 02,980 -> 00: 43: 03.610
DAVID MALAN: Ponto e vírgula.

928
00: 43: 03,610 -> 00: 43: 04.840
Apenas termina o pensamento.

929
00: 43: 04,840 -> 00: 43: 05.830
Então, o que isso faz?

930
00: 43: 05,830 -> 00: 43: 10.270
Ei, computador, me dê uma variável cujo tipo seja itneger ou int.

931
00: 43: 10,270 -> 00: 43: 15.280
Chame esse contador de variável e armazene o valor zero nessa variável

932
00: 43: 15,280 -> 00: 43: 19.970
por padrão. Acontece que podemos fazer outras operações desse tipo em variáveis.

933
00: 43: 19,970 -> 00: 43: 23.460
Por exemplo, aqui temos o recurso de incrementação do Scratch.

934
00: 43: 23,460 -> 00: 43: 27.080
Altere o contador em um adicionando 1 à variável.

935
00: 43: 27,080 -> 00: 43: 28.510
Então, como fazemos isso em C?

936
00: 43: 28,510 -> 00: 43: 30.800
Em C, você faria algo assim.

937
00: 43: 30,800 -> 00: 43: 35.110
E isso é um pouco paradoxal se você está vindo da álgebra,

938
00: 43: 35,110 -> 00: 43: 38.110
porque como poderia counter ser igual a counter mais 1?

939
00: 43: 38,110 -> 00: 43: 39.560
Mas aqui isso não é igualdade.

940
00: 43: 39,560 -> 00: 43: 41.780
Esta é uma atribuição da direita para a esquerda.

941
00: 43: 41,780 -> 00: 43: 43.780
Portanto, no lado esquerdo, você está dizendo counter.

942
00: 43: 43,780 -> 00: 43: 45.190
Esse é o nome da sua variável.

943
00: 43: 45,190 -> 00: 43: 47.500
No lado direito, você está dizendo counter mais 1,

944
00: 43: 47,500 -> 00: 43: 49.390
qualquer que seja essa resposta aritmética.

945
00: 43: 49,390 -> 00: 43: 53.260
E você está copiando o contador mais 1 no contador.

946
00: 43: 53,260 -> 00: 43: 56.420
Ainda estou sentindo falta de alguma coisa aqui, que é aquele ponto e vírgula.

947
00: 43: 56,420 -> 00: 44: 00.580
Mas não preciso dizer int neste exemplo.

948
00: 44: 00,580 -> 00: 44: 05.200
Neste ponto da história, presume-se que counter já exista

949
00: 44: 05,200 -> 00: 44: 08.020
e que usei uma linha de código como a anterior

950
00: 44: 08,020 -> 00: 44: 10.270
em outro lugar no meu programa.

951
00: 44: 10,270 -> 00: 44: 13.330
Porque isso diz ao computador uma vez, dê-me uma variável chamada counter,

952
00: 44: 13,330 -> 00: 44: 14.950
e deixe-me armazenar ints nela.

953
00: 44: 14,950 -> 00: 44: 17.110
Esta linha de código assume que counter já exista,

954
00: 44: 17,110 -> 00: 44: 20.410
e, portanto, não especificamos a palavra int novamente.

955
00: 44: 20,410 -> 00: 44: 22.060
Você especifica apenas uma vez.

956
00: 44: 22,060 -> 00: 44: 24.040
Agora, precisamos do ponto-e-vírgula, como propus.

957
00: 44: 24,040 -> 00: 44: 26.680
Mas, francamente, esta é uma operação tão comum na programação,

958
00: 44: 26,680 -> 00: 44: 28.930
como veremos, apenas para incrementar uma variável.

959
00: 44: 28,930 -> 00: 44: 31.280
Acontece que há outras maneiras de fazer isso.

960
00: 44: 31,280 -> 00: 44: 33.520
Você pode, em vez disso, equivalentemente dizer isso -

961
00: 44: 33,520 -> 00: 44: 36.250
counter mais igual 1 ponto-e-vírgula.

962
00: 44: 36,250 -> 00: 44: 37.800
É literalmente a mesma coisa.

963
00: 44: 37,800 -> 00: 44: 39.550
E se isso for muito para você,

964
00: 44: 39,550 -> 00: 44: 42.910
você pode literalmente apenas dizer counter mais mais ponto-e-vírgula,

965
00: 44: 42,910 -> 00: 44: 44.500
e isso também faz a mesma coisa.

966
00: 44: 44,500 -> 00: 44: 47.650
Isso é conhecido em programação como sintaxe adocicada.

967
00: 44: 47,650 -> 00: 44: 51.110
Ela não adiciona nenhuma funcionalidade que você não poderia fazer de outra maneira.

968
00: 44: 51,110 -> 00: 44: 53.800
Mas faz isso de uma forma mais bonita, geralmente mais sucinta.

969
00: 44: 53,800 -> 00: 44: 56.680
E é mais comum escrever linhas de código como esta.

970
00: 44: 56,680 -> 00: 44: 58.430
Tudo bem, vamos considerar outro exemplo.

971
00: 44: 58,430 -> 00: 45: 01.750
Isso foi chamado de quê no Scratch?

972
00: 45: 01,750 -> 00: 45: 03.980
Sim, uma condição, uma decisão que você tem que tomar.

973
00: 45: 03,980 -> 00: 45: 06.310
Portanto, se algo for verdade, faça isso.

974
00: 45: 06,310 -> 00: 45: 08.720
Em C, podemos convertê-lo da seguinte maneira.

975
00: 45: 08,720 -> 00: 45: 11.260
Se x menor que y entre parênteses -

976
00: 45: 11,260 -> 00: 45: 15.300
que não é bem a forma angular que temos aqui em verde, mas em C,

977
00: 45: 15,300 -> 00: 45: 16.780
você usa parênteses aqui.

978
00: 45: 16,780 -> 00: 45: 20.380
Portanto, se x for menor que y, abre parênteses, fecha parênteses,

979
00: 45: 20,380 -> 00: 45: 21.970
então vá em frente e faça o seguinte.

980
00: 45: 21,970 -> 00: 45: 25.720
E assim como esta peça amarela ou laranja do quebra-cabeça parece que está

981
00: 45: 25,720 -> 00: 45: 29.920
abraçando a peça roxa do quebra-cabeça, esta chave aberta também

982
00: 45: 29,920 -> 00: 45: 32.830
e esta chave fechada, por assim dizer, está meio que lá

983
00: 45: 32,830 -> 00: 45: 36.050
pronta para abraçar ou encapsular uma ou mais linhas de código.

984
00: 45: 36,050 -> 00: 45: 37.090
Qual é a linha de código?

985
00: 45: 37,090 -> 00: 45: 42.640
Pode ser algo assim - printf x é menor que y barra invertida n.

986
00: 45: 42,640 -> 00: 45: 47.080
Então, novamente, nova sintaxe, mas vimos as chaves antes

987
00: 45: 47,080 -> 00: 45: 48.490
no contexto de principal.

988
00: 45: 48,490 -> 00: 45: 52.280
E vimos parênteses antes no contexto de entradas.

989
00: 45: 52,280 -> 00: 45: 54.520
Portanto, este é apenas um tipo de padrão que iremos

990
00: 45: 54,520 -> 00: 45: 58.530
comece a seguir em C sempre que quisermos fazer algo condicionalmente.

991
00: 45: 58,530 -> 00: 46: 01.000
OK, no Scratch, vimos algo assim -

992
00: 46: 01.000 -> 00: 46: 04.300
se x for menor que y, então digamos que x seja menor que y.

993
00: 46: 04,300 -> 00: 46: 06.730
Caso contrário, conclua que x não é menor que y.

994
00: 46: 06,730 -> 00: 46: 11.380
Em C, quase parece o mesmo, mas você mesmo deve montar o bloco "else"

995
00: 46: 11,380 -> 00: 46: 15.010
com dois conjuntos de chaves, meio que dois caracteres prontos para abraçar

996
00: 46: 15,010 -> 00: 46: 16.600
as linhas de código entre eles.

997
00: 46: 16,600 -> 00: 46: 19.660
E podemos apenas inserir agora, literalmente, as traduções para o printf

998
00: 46: 19,660 -> 00: 46: 25.060
dizendo que printf x é menor que y ou printf x não é menor que y.

999
00: 46: 25,060 -> 00: 46: 28.450
Agora, observe, há apenas dois pontos e vírgulas neste exemplo.

1000
00: 46: 28,450 -> 00: 46: 33.430
Geralmente, você não termina coisas como condições com ponto e vírgula.

1001
00: 46: 33,430 -> 00: 46: 37.690
Você termina funções ou linhas que envolvem funções com ponto e vírgula.

1002
00: 46: 37,690 -> 00: 46: 39.850
E essa não é uma regra que vale para tudo, mas você

1003
00: 46: 39,850 -> 00: 46: 42.490
não quer linhas de código - você não quer ponto e vírgula

1004
00: 46: 42,490 -> 00: 46: 43.870
após cada linha de código.

1005
00: 46: 43,870 -> 00: 46: 45.855
Você geralmente quer depois de alguma ação.

1006
00: 46: 45,855 -> 00: 46: 48.730
E você começará a notar esse padrão, embora talvez não seja

1007
00: 46: 48,730 -> 00: 46: 50.560
óbvio no início.

1008
00: 46: 50,560 -> 00: 46: 52.260
Certo, que tal esse?

1009
00: 46: 52,260 -> 00: 46: 55.090
If, else if, else if.

1010
00: 46: 55.090 -> 00: 46: 58.900
Agora, observe que estamos apenas reutilizando o bloco if-else if e depois outro

1011
00: 46: 58,900 -> 00: 47: 00.250
bloco if aqui.

1012
00: 47: 00,250 -> 00: 47: 02.500
Acontece que em C, é quase um pouco mais fácil.

1013
00: 47: 02,500 -> 00: 47: 04.120
Você pode literalmente apenas dizer isso -

1014
00: 47: 04,120 -> 00: 47: 07.060
se x for menor que y, faça isso com chaves.

1015
00: 47: 07,060 -> 00: 47: 10.220
Caso contrário, se x for maior do que y, faça isso entre chaves.

1016
00: 47: 10,220 -> 00: 47: 14.160
Caso contrário, se x for igual a y, faça isso entre chaves.

1017
00: 47: 14,160 -> 00: 47: 16.050
E o que você quer fazer em cada caso?

1018
00: 47: 16,050 -> 00: 47: 20.560
Printf's diferentes com base nas mensagens que queremos exibir.

1019
00: 47: 20,560 -> 00: 47: 23.220
Mas há uma curiosidade aqui.

1020
00: 47: 23,220 -> 00: 47: 26.550
Quase parece um erro de digitação.

1021
00: 47: 26,550 -> 00: 47: 28.278
Sim, o duplo sinal de igual.

1022
00: 47: 28,278 -> 00: 47: 29.070
Mas não é um bug.

1023
00: 47: 29,070 -> 00: 47: 29.940
Não é um engano.

1024
00: 47: 29,940 -> 00: 47: 35.070
Por que estou usando dois iguais aqui em vez de um único sinal de igual,

1025
00: 47: 35,070 -> 00: 47: 36.990
como no Scratch?

1026
00: 47: 36,990 -> 00: 47: 37.980
Deixe-me detalhar aqui.

1027
00: 47: 37,980 -> 00: 47: 38.687
Sim?

1028
00: 47: 38,687 -> 00: 47: 42.335
PÚBLICO: [INAUDÍVEL].

1029
00: 47: 42,335 -> 00: 47: 43.210
DAVID MALAN: Exatamente.

1030
00: 47: 43,210 -> 00: 47: 46.420
Eu disse anteriormente que o único sinal de igual é usado para atribuição da direita

1031
00: 47: 46,420 -> 00: 47: 47.140
para a esquerda.

1032
00: 47: 47,140 -> 00: 47: 49.120
E honestamente, esta é apenas uma situação humana, onde

1033
00: 47: 49,120 -> 00: 47: 50.590
nós nos colocamos em um canto.

1034
00: 47: 50,590 -> 00: 47: 53.050
Já usamos o sinal de igual para atribuição.

1035
00: 47: 53,050 -> 00: 47: 56.570
Então, presumivelmente, algum humano percebeu: "A, nossa, como vamos fazer a pergunta,

1036
00: 47: 56,570 -> 00: 47: 57.808
isso é igual a isso?"

1037
00: 47: 57.808 -> 00: 47: 59.350
Bem, já usamos esse símbolo.

1038
00: 47: 59,350 -> 00: 48: 01.510
Então, os humanos, décadas atrás, decidiram, tudo bem,

1039
00: 48: 01,510 -> 00: 48: 05.200
vamos resolver esse problema usando apenas dois sinais de iguais lado a lado.

1040
00: 48: 05,200 -> 00: 48: 07.690
Portanto, este é o chamado operador de igualdade.
1041
00: 48: 07,690 -> 00: 48: 09.633
Um único sinal de igual é apenas a atribuição.

1042
00: 48: 09,633 -> 00: 48: 12.550
Este é, sem dúvida, um dos erros mais comuns de se cometer no início,

1043
00: 48: 12,550 -> 00: 48: 15.730
especialmente se você usa Scratch ou outras linguagens de antemão.

1044
00: 48: 15,730 -> 00: 48: 18.880
E você só consegue desenvolver a memória muscular ao longo do tempo.

1045
00: 48: 18,880 -> 00: 48: 22.030
Depois que você cometer esse erro algumas vezes, ele desaparecerá.

1046
00: 48: 22,030 -> 00: 48: 24.010
Tudo bem, mas acontece que este programa,

1047
00: 48: 24,010 -> 00: 48: 26.530
embora indiscutivelmente correto - ou este código, embora correto,

1048
00: 48: 26,530 -> 00: 48: 30.340
em que vai fazer isso ou isso ou aquilo - e eu acho que aqueles

1049
00: 48: 30,340 -> 00: 48: 31.960
são as três situações possíveis.

1050
00: 48: 31,960 -> 00: 48: 37.090
Se você tiver dois inteiros, x e y, x é menor que y, maior que y,

1051
00: 48: 37,090 -> 00: 48: 38.530
ou igual a y.

1052
00: 48: 38,530 -> 00: 48: 42.490
Mas uma dessas questões tecnicamente não precisa ser feita.

1053
00: 48: 42,490 -> 00: 48: 45.400
Há tecnicamente três expressões booleanas aqui, certo -

1054
00: 48: 45,400 -> 00: 48: 49.098
x menor que y, x maior que y, x é igual a y.

1055
00: 48: 49,098 -> 00: 48: 50.890
Uma expressão booleana, lembre-se, é uma pergunta

1056
00: 48: 50,890 -> 00: 48: 56.170
que tem uma resposta sim / não ou uma resposta verdadeiro / falso ou uma resposta 1/0.

1057
00: 48: 56,170 -> 00: 48: 59.560
Mas não preciso fazer três perguntas aqui, preciso?

1058
00: 48: 59,560 -> 00: 49: 00.920
Acho que vi sua mão.

1059
00: 49: 00,920 -> 00: 49: 01.654
Por que não?

1060
00: 49: 01,654 -> 00: 49: 05.920
PÚBLICO: Bem, porque se x for menor que [INAUDÍVEL] ..

1061
00: 49: 05,920 -> 00: 49: 09.975


1062
00: 49: 09,975 -> 00: 49: 10.850
DAVID MALAN: Exatamente.

1063
00: 49: 10.850 -> 00: 49: 14.570
Esta terceira pergunta, esta expressão booleana, x é igual a y,

1064
00: 49: 14,570 -> 00: 49: 16.700
nem é preciso dizer logicamente.

1065
00: 49: 16,700 -> 00: 49: 19.655
Porque se x não é menor que, e não é maior que,

1066
00: 49: 19,655 -> 00: 49: 22.280
se for apenas [INAUDÍVEL] o único outro cenário que consigo pensar

1067
00: 49: 22,280 -> 00: 49: 24.020
é que é igual a y.

1068
00: 49: 24,020 -> 00: 49: 28.550
Portanto, podemos realmente simplificar o código Scratch e o código C

1069
00: 49: 28,550 -> 00: 49: 31.978
apenas por ter essa condição "else" abaixo.

1070
00: 49: 31,978 -> 00: 49: 33.770
Então, conversaremos nas próximas semanas,

1071
00: 49: 33,770 -> 00: 49: 36.230
sobre diferentes qualidades de código.

1072
00: 49: 36,230 -> 00: 49: 38.480
Acertividade, tal como, isso faz o que deveria fazer?

1073
00: 49: 38,480 -> 00: 49: 42.770
mas também a qualidade do design, como você escreveu este código tão eficientemente quanto

1074
00: 49: 42,770 -> 00: 49: 45.530
possível, o mais rápido possível, de uma forma que

1075
00: 49: 45,530 -> 00: 49: 49.160
usa a menor quantidade de memória e a menor quantidade de CPU,

1076
00: 49: 49,160 -> 00: 49: 50.420
o cérebro do computador?

1077
00: 49: 50,420 -> 00: 49: 54.047
E isso é apenas uma alusão a esse tipo de capacidade.

1078
00: 49: 54,047 -> 00: 49: 55.880
Tudo bem, apenas mais algumas comparações

1079
00: 49: 55,880 -> 00: 49: 58.070
antes de voltarmos a escrever algum código.

1080
00: 49: 58,070 -> 00: 49: 59.397
Que tal algo como isso?

1081
00: 49: 59,397 -> 00: 50: 02.480
No Scratch, nós, é claro, chamamos isso de loop - um ciclo que acontece novamente

1082
00: 50: 02,480 -> 00: 50: 03.740
e novamente e novamente.

1083
00: 50: 03,740 -> 00: 50: 08.120
E um loop como este pode ser implementado em C não da mesma maneira,

1084
00: 50: 08,120 -> 00: 50: 09.080
mas assim.

1085
00: 50: 09,080 -> 00: 50: 11.480
Acontece que a palavra mais próxima da palavra

1086
00: 50: 11,480 -> 00: 50: 14.820
"forever/para sempre" no Scratch é a palavra "while/enquanto".

1087
00: 50: 14,820 -> 00: 50: 17.900
Isso meio que sugere a ideia de fazer algo repetidamente.

1088
00: 50: 17,900 -> 00: 50: 20.330
Esta foi a palavra que os humanos escolheram anos atrás.

1089
00: 50: 20,330 -> 00: 50: 22.280
Mas você não diz apenas "while/enquanto".

1090
00: 50: 22,280 -> 00: 50: 26.090
Você tem que dizer não só o que você quer fazer para sempre,

1091
00: 50: 26,090 -> 00: 50: 29.910
mas você precisa responder a uma expressão booleana.

1092
00: 50: 29,910 -> 00: 50: 32.540
Então, em C, se você deseja implementar um loop,

1093
00: 50: 32,540 -> 00: 50: 36.090
você precisa literalmente ser capaz de dizer enquanto algo é verdade.

1094
00: 50: 36,090 -> 00: 50: 40.850
Você precisa fazer uma pergunta cuja resposta seja um sim ou verdadeiro ou 1.

1095
00: 50: 40,850 -> 00: 50: 42.980
Todos esses são equivalentes a um programador.

1096
00: 50: 42,980 -> 00: 50: 46.130
Então, o que é um exemplo de uma expressão, uma expressão booleana,

1097
00: 50: 46,130 -> 00: 50: 49.990
isso é sempre verdade, se meu objetivo é fazer algo para sempre?

1098
00: 50: 49,990 -> 00: 50: 51.173
PÚBLICO: Cinco é igual a cinco.

1099
00: 50: 51,173 -> 00: 50: 53.340
DAVID MALAN: cinco é igual a cinco, certo.

1100
00: 50: 53,340 -> 00: 50: 55.220
Eu poderia fazer quatro é igual a quatro.

1101
00: 50: 55,220 -> 00: 50: 56.930
Eu poderia fazer dois é maior que um.

1102
00: 50: 56,930 -> 00: 50: 59.030
Eu poderia fazer um é menor do que dois.

1103
00: 50: 59,030 -> 00: 51: 01.640
Eu poderia chegar a um número infinito de expressões booleanas

1104
00: 51: 01,640 -> 00: 51: 03.800
que logicamente são sempre verdadeiros.

1105
00: 51: 03,800 -> 00: 51: 07.070
Mas a maneira mais simples é dizer literalmente a "true/verdadeiro".

1106
00: 51: 07,070 -> 00: 51: 09.050
É um pouco hackeado, mas talvez seja

1107
00: 51: 09,050 -> 00: 51: 12.440
a pergunta mais simples que você pode fazer, porque é "true", por definição,

1108
00: 51: 12,440 -> 00: 51: 16.520
Acontece que é sempre "verdadeiro", assim como falso é sempre falso.

1109
00: 51: 16,520 -> 00: 51: 19.310
E então posso literalmente apenas dizer enquanto verdadeiro para

1110
00: 51: 19,310 -> 00: 51: 24.008
induzir um loop infinito, por assim dizer, que faz algo para sempre.

1111
00: 51: 24,008 -> 00: 51: 26.300
Tudo bem, vamos tentar outro tipo de construção de loop.

1112
00: 51: 26,300 -> 00: 51: 28.192
Este foi um loop que fez algo 50 vezes.

1113
00: 51: 28,192 -> 00: 51: 30.275
Neste, agora temos que ser um pouco mais espertos,

1114
00: 51: 30,275 -> 00: 51: 32.360
e temos que ligar as coisas.

1115
00: 51: 32,360 -> 00: 51: 35.120
Então, se eu quiser fazer algo 50 vezes, aqui está uma maneira.

1116
00: 51: 35,120 -> 00: 51: 37.850
Por que não me dou uma variável e a chamo de contador?

1117
00: 51: 37,850 -> 00: 51: 40.760
Mas eu poderia chamá-lo do que quiser e inicializá-lo como zero.

1118
00: 51: 40,760 -> 00: 51: 42.980
Então, deixe-me ir em frente - sabe de uma coisa?

1119
00: 51: 42,980 -> 00: 51: 44.510
Counter é realmente muito prolixo.

1120
00: 51: 44,510 -> 00: 51: 46.490
A maioria dos programadores, quando estão apenas contando,

1121
00: 51: 46,490 -> 00: 51: 49.557
eles, por convenção, apenas usam a letra i, i para inteiro.

1122
00: 51: 49,557 -> 00: 51: 51.140
Mas você pode chamá-lo do que quiser.

1123
00: 51: 51,140 -> 00: 51: 53.810
Vou chamá-lo de int i igual a zero.

1124
00: 51: 53,810 -> 00: 51: 56.990
Em seguida, vou prosseguir e fazer o seguinte.

1125
00: 51: 56,990 -> 00: 51: 59.840
"while" a seguinte expressão seja verdadeira, deixe-me apenas

1126
00: 51: 59,840 -> 00: 52: 01.790
fazer uma pergunta de novo e de novo...

1127
00: 52: 01,790 -> 00: 52: 06.170
Enquanto i for menor que 50, vou em frente dizendo, "hello world".

1128
00: 52: 06,170 -> 00: 52: 09.300
Então posso imprimir, olá, mundo.

1129
00: 52: 09,300 -> 00: 52: 12.260
Mas ainda não terminei de construir essa lógica.

1130
00: 52: 12,260 -> 00: 52: 14.330
Inicializei uma variável com zero.

1131
00: 52: 14,330 -> 00: 52: 18.380
Vou, repetidamente, fazer a pergunta: i é menor que 50?

1132
00: 52: 18,380 -> 00: 52: 21.530
Mas para que isso funcione logicamente, que outro pedaço de lógica

1133
00: 52: 21,530 -> 00: 52: 24.360
eu preciso adicionar ao código?

1134
00: 52: 24,360 -> 00: 52: 25.916
Sim?

1135
00: 52: 25,916 -> 00: 52: 27.810
PÚBLICO: Você tem que aumentar i em um.

1136
00: 52: 27,810 -> 00: 52: 29.530
DAVID MALAN: Sim, tenho que incrementar i, certo?

1137
00: 52: 29,530 -> 00: 52: 30.770
Então, mesmo que você não se lembre -

1138
00: 52: 30,770 -> 00: 52: 33.130
e tudo bem - a sintaxe para fazer isso, você vai

1139
00: 52: 33,130 -> 00: 52: 35.090
precisar de uma linha de código como esta.

1140
00: 52: 35,090 -> 00: 52: 38.710
Então, logicamente, você vai fazer o seguinte - definir i igual a zero,

1141
00: 52: 38,710 -> 00: 52: 41.120
e, em seguida, faça o seguinte enquanto i for menor que 50.

1142
00: 52: 41,120 -> 00: 52: 42.430
Bem, i é menor que 50?

1143
00: 52: 42,430 -> 00: 52: 45.200
Obviamente, porque 0 é menor que 50.

1144
00: 52: 45,200 -> 00: 52: 46.660
Então você imprime, olá, mundo.

1145
00: 52: 46,660 -> 00: 52: 48.820
E então, como vocês disseram, precisamos incrementar i.

1146
00: 52: 48,820 -> 00: 52: 51.290
Portanto, agora i é igual a i mais 1.

1147
00: 52: 51,290 -> 00: 52: 53.980
Portanto, neste ponto da história, i é igual a 1.

1148
00: 52: 53,980 -> 00: 52: 57.430
E agora a forma como o código funciona, muito parecido com o nosso pseudo código da semana passada,

1149
00: 52: 57,430 -> 00: 53: 00.220
é você meio que implicitamente voltar a esta linha.

1150
00: 53: 00,220 -> 00: 53: 04.010
Na semana passada, em pseudocódigo, eu disse literalmente, volte para a linha 3.

1151
00: 53: 04,010 -> 00: 53: 09.460
Aqui, isso acontece automaticamente por natureza de como C interpreta essas linhas de código

1152
00: 53: 09,460 -> 00: 53: 10.720
nessas chaves.

1153
00: 53: 10,720 -> 00: 53: 12.980
E posso realmente simplificar isso da seguinte maneira.

1154
00: 53: 12,980 -> 00: 53: 14.568
Posso dizer i plus plus.

1155
00: 53: 14,568 -> 00: 53: 17.110
Agora, não é tão bonito quanto o Scratch, onde você apenas diz,

1156
00: 53: 17,110 -> 00: 53: 18.760
repita as seguintes 50 vezes.

1157
00: 53: 18,760 -> 00: 53: 22.630
Mas usando os princípios da semana passada agora traduzidos para C,

1158
00: 53: 22,630 -> 00: 53: 24.760
você pode conectar sua própria lógica que

1159
00: 53: 24,760 -> 00: 53: 27.610
faz algo inúmeras vezes.

1160
00: 53: 27,610 -> 00: 53: 30.430
E há uma outra maneira de fazer isso, só para você ver aqui.

1161
00: 53: 30,430 -> 00: 53: 33.850
Acontece que a maneira mais comum de fazer algo um número fixo de vezes

1162
00: 53: 33,850 -> 00: 53: 36.430
é usar uma preposição diferente - a palavra "for/para".

1163
00: 53: 36,430 -> 00: 53: 38.710
E um loop for se parece com isso.

1164
00: 53: 38,710 -> 00: 53: 43.180
Um loop for faz algo, como imprimir hello world, de novo e de novo,

1165
00: 53: 43,180 -> 00: 53: 44.740
mas é ainda mais mecânico.

1166
00: 53: 44,740 -> 00: 53: 48.580
Mas ele automatiza em uma linha de código exatamente a mesma lógica

1167
00: 53: 48,580 -> 00: 53: 50.020
que acabamos de implementar.

1168
00: 53: 50,020 -> 00: 53: 52.362
Após a palavra "for", você pode colocar os parênteses.

1169
00: 53: 52,362 -> 00: 53: 54.070
E então dentro desses parênteses, você

1170
00: 53: 54,070 -> 00: 53: 56.740
pode dizer algo como, me dê uma variável chamada "counter/contador"

1171
00: 53: 56,740 -> 00: 53: 58.180
e inicialize-a com zero.

1172
00: 53: 58,180 -> 00: 53: 59.410
Ou isso é um pouco verboso.

1173
00: 53: 59,410 -> 00: 54: 00.760
Vamos apenas usar i.

1174
00: 54: 00,760 -> 00: 54: 04.540
Então, isso é idêntico, logicamente, ao que fizemos agora pouco.

1175
00: 54: 04,540 -> 00: 54: 09.190
Mas o "laço for" realmente tem uma, duas, três entradas dentro

1176
00: 54: 09,190 -> 00: 54: 10.000
de seus parênteses.

1177
00: 54: 10.000 -> 00: 54: 12.520
É um pouco extravagante em termos de sintaxe.

1178
00: 54: 12,520 -> 00: 54: 15.790
o segundo parâmetro do loop for é a expressão Booleana

1179
00: 54: 15,790 -> 00: 54: 20.380
o que você quer perguntar repetidamente, então i é menor que 50?

1180
00: 54: 20,380 -> 00: 54: 22.900
E a última coisa que você pode fazer em um loop for

1181
00: 54: 22,900 -> 00: 54: 27.410
é o terceiro parâmetro, onde você pode fazer sua atualização de uma ou mais variáveis.

1182
00: 54: 27,410 -> 00: 54: 32.830
Então, se eu fizer i igual a i mais 1 ou, mais sucintamente, i mais igual 1,

1183
00: 54: 32,830 -> 00: 54: 36.700
ou ainda mais sucinto, i mais mais, eu agora

1184
00: 54: 36,700 -> 00: 54: 40.210
reduzi para apenas quatro linhas de código o que eu anteriormente

1185
00: 54: 40,210 -> 00: 54: 42.440
fiz com algumas linhas a mais de código.

1186
00: 54: 42,440 -> 00: 54: 43.660
Ambos estão corretos.

1187
00: 54: 43,660 -> 00: 54: 45.800
Ambos fazem exatamente a mesma coisa.

1188
00: 54: 45,800 -> 00: 54: 49.580
E mesmo que o loop "for" não seja um tanto óbvio - porque esta é a etapa um,

1189
00: 54: 49,580 -> 00: 54: 52.090
esta é a etapa dois, esta é a etapa três, então

1190
00: 54: 52,090 -> 00: 54: 54.265
em incrementos - atinge o mesmo resultado.

1191
00: 54: 54,265 -> 00: 54: 56.890
E você vai brincar com isso ao longo do tempo nas próximas semanas

1192
00: 54: 56,890 -> 00: 54: 58.510
quando precisar fazer coisas sucessivamente.

1193
00: 54: 58,510 -> 00: 55: 02.830
Mas está é apenas uma maneira mais sucinta de atingir o mesmo objetivo.

1194
00: 55: 02,830 -> 00: 55: 06.940
Alguma dúvida, então, sobre loops "while" ou loops "for" aqui?

1195
00: 55: 06,940 -> 00: 55: 09.990


1196
00: 55: 09,990 -> 00: 55: 15.180
Tudo bem, então vamos dar uma olhada em um conjunto final de definições.

1197
00: 55: 15,180 -> 00: 55: 18.510
Acontece que em C, temos uma lista completa de tipos de dados

1198
00: 55: 18,510 -> 00: 55: 20.210
além de apenas strings e além de ints.

1199
00: 55: 20,210 -> 00: 55: 22.260
E veremos isso e usaremos com o tempo.

1200
00: 55: 22,260 -> 00: 55: 26.320
Você pode ter um bool, por assim dizer, que é literalmente o valor verdadeiro ou falso.

1201
00: 55: 26,320 -> 00: 55: 29.620
E usamos isso implicitamente agora pouco, quando simplismente disse "while true".

1202
00: 55: 29,620 -> 00: 55: 34.140
Você pode ter um char, ou caractere, que é um único caractere, não dois ou mais

1203
00: 55: 34,140 -> 00: 55: 34.920
ou uma frase.

1204
00: 55: 34,920 -> 00: 55: 39.390
É como a letra S ou N se você estiver perguntando sim ou não.

1205
00: 55: 39,390 -> 00: 55: 42.720
Você pode ter um int, é claro, que é um inteiro, uma string, que

1206
00: 55: 42,720 -> 00: 55: 44.940
é um ou mais caracteres entre aspas duplas.

1207
00: 55: 44,940 -> 00: 55: 47.670
Portanto, é maior do que um char individual, normalmente.

1208
00: 55: 47,670 -> 00: 55: 49.650
E então há alguns outros tipos de dados -

1209
00: 55: 49,650 -> 00: 55: 50.700
int e longo.

1210
00: 55: 50,700 -> 00: 55: 52.890
Portanto, int normalmente tem um determinado tamanho.

1211
00: 55: 52,890 -> 00: 55: 55.260
Você só pode contar até certo ponto com um int.

1212
00: 55: 55,260 -> 00: 55: 58.110
Normalmente, você pode contar até 4 bilhões com um int,

1213
00: 55: 58,110 -> 00: 56: 00.610
e isso não é grande o suficiente para determinados aplicativos.

1214
00: 56: 00,610 -> 00: 56: 03.330
As maiores empresas de hoje, como Facebook, Microsoft e Google

1215
00: 56: 03,330 -> 00: 56: 06.240
tem muito mais dados do que 4 bilhões.

1216
00: 56: 06,240 -> 00: 56: 10.030
Portanto, existem coisas chamadas longs, que na verdade usam mais bits.

1217
00: 56: 10,030 -> 00: 56: 12.640
Eles são valores mais amplos, então podem contar ainda mais.

1218
00: 56: 12,640 -> 00: 56: 14.940
Um float é um valor de ponto flutuante, que é

1219
00: 56: 14,940 -> 00: 56: 18.390
uma maneira elegante de dizer um número real, algo que tem um ponto decimal.

1220
00: 56: 18,390 -> 00: 56: 23.130
E um double é apenas um número real que pode ter ainda mais dígitos

1221
00: 56: 23,130 -> 00: 56: 24.790
após o ponto decimal.

1222
00: 56: 24,790 -> 00: 56: 26.370
Então, veremos isso em breve.

1223
00: 56: 26,370 -> 00: 56: 28.950
Bem, que outros recursos a biblioteca do CS50 oferece?

1224
00: 56: 28,950 -> 00: 56: 31.320
Ele fornece não apenas a função get_string,

12: 25h
00: 56: 31,320 -> 00: 56: 35.567
veremos alguns outros como get_int ou get_float ou get_double ou get_char.

1226
00: 56: 35,567 -> 00: 56: 37.650
Todas essas são funções que irão solicitar do ser humano

1227
00: 56: 37,650 -> 00: 56: 42.360
com o prompt piscando por certos valores que eles podem querer fornecer.

1228
00: 56: 42,360 -> 00: 56: 44.540
E então, para "placeholders/marcadores de posição" vamos completar isso.

1229
00: 56: 44,540 -> 00: 56: 48.090
Printf, lembre-se, tinha um "placeholder" para "%s" para uma string.

1230
00: 56: 48,090 -> 00: 56: 50.580
Acontece que tem alguns outros "placeholders" também.

1231
00: 56: 50,580 -> 00: 56: 53.520
Se você quiser conectar um int, vamos começar a usar o "%i".

1232
00: 56: 53,520 -> 00: 56: 55.920
Se você deseja conectar um float - isto é, um número real -

1233
00: 56: 55,920 -> 00: 56: 57.350
você vai usar o %f.

1234
00: 56: 57,350 -> 00: 57: 00.390
E há alguns outros códigos de formatação também.

1235
00: 57: 00,390 -> 00: 57: 02.430
Mas vimos apenas um deles até agora.

1236
00: 57: 02,430 -> 00: 57: 05.010
E então, em termos de operações aritméticas,

1237
00: 57: 05,010 -> 00: 57: 07.290
você pode fazer muita matemática de forma muito simples.

1238
00: 57: 07,290 -> 00: 57: 09.540
E vamos fazer apenas alguns exemplos, literalmente apenas

1239
00: 57: 09,540 -> 00: 57: 13.320
usando os caracteres que você pode ser tendenciado a digitar na tela.

1240
00: 57: 13,320 -> 00: 57: 18.603
Então, em resumo, suponha que queiramos ir em frente e escrever um programa nosso.

1241
00: 57: 18.603 -> 00: 57: 21.270
Podemos usar qualquer uma dessas funções - get_int e get_float

1242
00: 57: 21,270 -> 00: 57: 22.240
e get_more.

1243
00: 57: 22,240 -> 00: 57: 24.990
Mas antes disso, vamos fazer uma pausa de cinco minutos aqui,

1244
00: 57: 24,990 -> 00: 57: 26.865
porque esta foi uma mangueira de incêndio e tanto.

1245
00: 57: 26,865 -> 00: 57: 30.570
Os biscoitos aguardam no saguão do lado de fora e retomaremos em cinco minutos.

1246
00: 57: 30,570 -> 00: 57: 36.420
Então, estamos de volta, e agora começamos a nos concentrar não apenas em comparações

1247
00: 57: 36,420 -> 00: 57: 39.090
de C com Scratch, mas na verdade escrevendo

1248
00: 57: 39,090 -> 00: 57: 42.960
algum código que veio do Scratch, mas em C. E o objetivo em mãos

1249
00: 57: 42,960 -> 00: 57: 46.050
realmente é começar a desenvolver a memória muscular por meio da qual

1250
00: 57: 46,050 -> 00: 57: 49.860
você pode começar com arquivos literalmente vazios e começar a preenchê-los

1251
00: 57: 49,860 -> 00: 57: 54.090
com implementações C de suas idéias.

1252
00: 57: 54,090 -> 00: 57: 57.660
Portanto, tenha certeza de que todos os exemplos que vamos fazer ao vivo

1253
00: 57: 57,660 -> 00: 57: 59.670
já estão prontos online, então você será

1254
00: 57: 59,670 -> 00: 58: 02.580
capaz de baixar todos esses exemplos do site do curso.

1255
00: 58: 02,580 -> 00: 58: 05.632
Na superseção de Brian, você poderá explorá-los com mais detalhes.

1256
00: 58: 05,632 -> 00: 58: 07.590
E ainda esta semana você terá oportunidades

1257
00: 58: 07,590 -> 00: 58: 11.020
de trabalhar na prática nesses mesmos tipos de programas também.

1258
00: 58: 11,020 -> 00: 58: 16.140
Por enquanto, o objetivo geral é exposição e conceitos e o início

1259
00: 58: 16,140 -> 00: 58: 18.270
de desenvolver essa memória muscular.

1260
00: 58: 18,270 -> 00: 58: 21.947
Com isso dito, deixe-me continuar e criar um novo arquivo chamado int.c,

1261
00: 58: 21,947 -> 00: 58: 24.780
o objetivo do qual será obter um número inteiro do usuário,

1262
00: 58: 24,780 -> 00: 58: 28.530
muito parecido com o de agora pouco, Eu recebi uma string do usuário.

1263
00: 58: 28,530 -> 00: 58: 30.630
Eu vou seguir, como antes, estou

1264
00: 58: 30,630 -> 00: 58: 32.410
incluindo alguns arquivos familiares.

1265
00: 58: 32,410 -> 00: 58: 35.012
Então, vou prosseguir e incluir preventivamente CS50.h

1266
00: 58: 35,012 -> 00: 58: 37.830
para que eu tenha acesso a strings e get_string

1267
00: 58: 37,830 -> 00: 58: 40.800
e get_int e get_float e outros recursos também.

1268
00: 58: 40,800 -> 00: 58: 43.890
Vou incluir stdio.h para ter acesso ao printf

1269
00: 58: 43,890 -> 00: 58: 45.780
para que eu possa realmente ver o que estamos fazendo.

1270
00: 58: 45,780 -> 00: 58: 48.600
Então vou fazer isso, que novamente, para os propósitos de hoje

1271
00: 58: 48,600 -> 00: 58: 51.150
e por algumas semanas, será apenas meio que copiar / colar.

1272
00: 58: 51,150 -> 00: 58: 54.090
Isso é o equivalente a quando a bandeira verde é clicada,

1273
00: 58: 54,090 -> 00: 58: 57.240
mas vamos explicar, em algumas semanas, exatamente por que você está escrevendo int

1274
00: 58: 57,240 -> 00: 58: 59.235
e porque você está escrevendo vazio.

1275
00: 58: 59,235 -> 00: 59: 01.110
Aqui, vou fazer algo assim.

1276
00: 59: 01,110 -> 00: 59: 03.360
Desta vez, não quero uma string, mas um int.

1277
00: 59: 03,360 -> 00: 59: 08.320
Então vamos começar get_int, qual é a sua idade?

1278
00: 59: 08,320 -> 00: 59: 10.860
Agora, para ser justo, provavelmente posso digitar muito rapidamente,

1279
00: 59: 10.860 -> 00: 59: 13.650
porque já tenho a memória muscular para programar em C.

1280
00: 59: 13,650 -> 00: 59: 16.150
Mas se olharmos para isso metodicamente por um momento,

1281
00: 59: 16,150 -> 00: 59: 19.540
esta é apenas outra função, get_int, da biblioteca CS50 que é

1282
00: 59: 19,540 -> 00: 59: 20.800
obter um número inteiro.

1283
00: 59: 20,800 -> 00: 59: 22.550
Este é o prompt que o humano está indo

1284
00: 59: 22,550 -> 00: 59: 25.862
para ver com o cursor se movendo para uma nova linha por causa da barra invertida n.

1285
00: 59: 25,862 -> 00: 59: 27.570
E não importa o que eles digitarem será

1286
00: 59: 27,570 -> 00: 59: 31.350
copiado da direita para a esquerda em uma variável chamada idade, cujo tipo,

1287
00: 59: 31,350 -> 00: 59: 34.140
por assim dizer, é int ou inteiro.

1288
00: 59: 34,140 -> 00: 59: 37.717
Agora deixe-me ir em frente e calcular, tipo, quantos dias de vida essa pessoa tem.

1289
00: 59: 37,717 -> 00: 59: 40.050
Então, se eu quiser fazer isso, posso fazer algo assim.

1290
00: 59: 40,050 -> 00: 59: 41.490
Bem, dê-me um número inteiro.

1291
00: 59: 41,490 -> 00: 59: 42.780
Chame isso de dias.

1292
00: 59: 42,780 -> 00: 59: 45.602
E então faça a idade vezes 365.

1293
00: 59: 45,602 -> 00: 59: 47.310
Eu propus agora a pouco que há um monte

1294
00: 59: 47,310 -> 00: 59: 49.830
de operadores aritméticos como mais e menos

1295
00: 59: 49,830 -> 00: 59: 53.850
e multiplicação e subtração e até mesmo o operador de resto.

1296
00: 59: 53,850 -> 00: 59: 58.680
Portanto, esta linha, 7, diz apenas multiplicar a idade por 365.

1297
00: 59: 58,680 -> 01: 00: 02.800
Copie esse valor, da direita para a esquerda, em uma nova variável chamada dias.

1298
01: 00: 02.800 -> 01: 00: 04.800
E agora posso ir em frente e imprimir isso, se quiser.

1299
01: 00: 04,800 -> 01: 00: 09.090
Então printf algo como, você tem pelo menos percentual -

1300
01: 00: 09,090 -> 01: 00: 13.620
não com "s", porque não é uma string, mas percentual i porque é um inteiro agora -

1301
01: 00: 13,620 -> 01: 00: 15.900
dias de vida, barra invertida n.

1302
01: 00: 15.900 -> 01: 00: 18.190
Mas, novamente, este é um "placeholder", então ainda não terminei.

1303
01: 00: 18,190 -> 01: 00: 23.580
O que devo colocar dentro desses parênteses também na linha 8?

1304
01: 00: 23.580 -> 01: 00: 27.990
Sim, então vírgula, dias, se esse for o valor que eu quero exibir.

1305
01: 00: 27,990 -> 01: 00: 29.377
E estou esquecendo mais uma coisa.

1306
01: 00: 29,377 -> 01: 00: 30.210
PÚBLICO: Ponto e vírgula.

1307
01: 00: 30.210 -> 01: 00: 32.127
DAVID MALAN: Ponto e vírgula no final da linha.

1308
01: 00: 32,127 -> 01: 00: 33.503
Agora, espero, está tudo feito direito.

1309
01: 00: 33,503 -> 01: 00: 35.670
Mas as chances de é a primeira vez que você escreve seus programas,

1310
01: 00: 35.670 -> 01: 00: 37.150
aparecerem mensagens de erro.

1311
01: 00: 37,150 -> 01: 00: 41.040
Mas vamos ver, "make int" é a maneira mais rápida agora de compilar este código.

1312
01: 00: 41,040 -> 01: 00: 41.850
Enter.

1313
01: 00: 41,850 -> 01: 00: 43.860
Tudo bem, o grande e longo comando branco está OK.

1314
01: 00: 43,860 -> 01: 00: 47.490
Contanto que você não veja uma saída vermelha, amarela ou colorida que indique

1315
01: 00: 47,490 -> 01: 00: 49.590
avisos ou erros, você deverá estar indo bem.

1316
01: 00: 49.590 -> 01: 00: 53.910
Vou limpar minha tela agora para executar este programa, ./int.

1317
01: 00: 53.910 -> 01: 00: 56.150
E suponha que sua idade seja, digamos, 50.

1318
01: 00: 56,150 -> 01: 01: 00.422
Bem, você tem pelo menos 18.250 dias de vida.

1319
01: 01: 00,422 -> 01: 01: 03.630
Mas deixe-me usar isso como uma oportunidade não apenas de fazer algo correto, que

1320
01: 01: 03,630 -> 01: 01: 06.690
Eu afirmo que este código é, mas apenas para torná-lo melhor projetado.

1321
01: 01: 06,690 -> 01: 01: 11.580
Não há problema em armazenar esse valor, idade, em uma variável chamada idade.

1322
01: 01: 11.580 -> 01: 01: 13.950
E não há problema em criar uma segunda variável chamada

1323
01: 01: 13,950 -> 01: 01: 19.300
dias, em que minha resposta matemática é idade vezes 365.

1324
01: 01: 19,300 -> 01: 01: 22.530
Mas, estritamente falando, não preciso dessa linha de código adicional.

1325
01: 01: 22.530 -> 01: 01: 26.520
Eu também poderia fazer a idade vezes 365 aqui.

1326
01: 01: 26.520 -> 01: 01: 27.660
Então C é legal assim.

1327
01: 01: 27,660 -> 01: 01: 32.370
Você pode compor, assim como no Scratch, ideias maiores a partir de múltiplas ideias menores

1328
01: 01: 32.370 -> 01: 01: 33.090
peças.

1329
01: 01: 33.090 -> 01: 01: 35.550
E, francamente, se eu realmente quero ficar louco,

1330
01: 01: 35.550 -> 01: 01: 38.040
observe que posso destacar toda a função

1331
01: 01: 38.040 -> 01: 01: 42.000
chamar, por assim dizer, livrar-se da idade todos juntos,

1332
01: 01: 42.000 -> 01: 01: 49.330
e basta conectar aqui vezes 365.

1333
01: 01: 49,330 -> 01: 01: 53.190
Mas neste ponto, estamos começando a cruzar um ponto de inflexão.

1334
01: 01: 53,190 -> 01: 01: 55.342
Sim, isso é correto, porque eu, estritamente falando,

1335
01: 01: 55,342 -> 01: 01: 56.550
não precisa de uma variável, certo?
1336
01: 01: 56.550 -> 01: 01: 58.020
Eu posso passar - vimos semana passada -

1337
01: 01: 58,020 -> 01: 02: 00.870
saída de uma função como entrada de outra função

1338
01: 02: 00,870 -> 01: 02: 02.540
simplesmente aninhando-os dessa maneira.

1339
01: 02: 02.540 -> 01: 02: 05.040
Mas, honestamente, agora estamos no ponto em que esta linha de código

1340
01: 02: 05.040 -> 01: 02: 08.080
é relativamente longa, é muito difícil de ler.

1341
01: 02: 08.080 -> 01: 02: 10.830
E então este é um exemplo onde, pelo bem do design, sabe de uma coisa?

1342
01: 02: 10.830 -> 01: 02: 13.210
A versão anterior provavelmente era um pouco melhor,

1343
01: 02: 13,210 -> 01: 02: 16.950
porque posso ler o código mais de cima para baixo do que da esquerda para a direita.

1344
01: 02: 16.950 -> 01: 02: 18.900
Mas esta é uma decisão de design.
1345
01: 02: 18.900 -> 01: 02: 21.000
E, de fato, você pode concordar ou discordar.

1346
01: 02: 21.000 -> 01: 02: 24.420
Você pode concordar ou discordar de seu professor, ou TF, em última instância.

1347
01: 02: 24.420 -> 01: 02: 28.770
Esses são os tipos de decisões que envolvem a escrita de códigos bons ou ruins

1348
01: 02: 28.770 -> 01: 02: 30.300
ou código bom ou melhor.

1349
01: 02: 30,300 -> 01: 02: 33.000
Muito parecido com uma redação de inglês ou em qualquer idioma escrito,

1350
01: 02: 33.000 -> 01: 02: 36.030
você poderia discutir que uma pessoa escreveu seu documento melhor

1351
01: 02: 36.030 -> 01: 02: 36.730
do que outro.

1352
01: 02: 36.730 -> 01: 02: 40.140
Portanto, começaremos a apreciar essas nuancias com o tempo.

1353
01: 02: 40,140 -> 01: 02: 41.310
Que tal o float?

1354
01: 02: 41,310 -> 01: 02: 45.758
Bem, deixe-me prosseguir e escrever outro programa bem rápido chamado float.c.

1355
01: 02: 45,758 -> 01: 02: 47.550
E este vai usar ponto flutuante

1356
01: 02: 47.550 -> 01: 02: 50.800
valores, que novamente, são apenas sinônimos de números reais com pontos decimais.

1357
01: 02: 50.800 -> 01: 02: 54.150
Deixe-me ir em frente e incluir CS50.h, incluir stdio.h.

1358
01: 02: 54,150 -> 01: 02: 57.840


1359
01: 02: 57.840 -> 01: 03: 02.003
E então int main void e então minhas chaves abertas.

1360
01: 03: 02.003 -> 01: 03: 02.920
E agora vamos fazer isso.

1361
01: 03: 02,920 -> 01: 03: 04.680
Deixe-me ver o preço de alguma coisa.

1362
01: 03: 04,680 -> 01: 03: 10.290
Então, "int price" é igual a get_float, qual é o preço, por exemplo.

1363
01: 03: 10.290 -> 01: 03: 11.450
Ponto e vírgula.

1364
01: 03: 11.450 -> 01: 03: 13.660
E agora deixe-me fazer algo matemático com isso.

1365
01: 03: 13.660 -> 01: 03: 18.120
Deixe-me ir em frente e dizer, seu total é.

1366
01: 03: 18,120 -> 01: 03: 21.330
E agora deixe-me fazer o preço total com imposto, por exemplo.

1367
01: 03: 21,330 -> 01: 03: 24.353
Em Massachusetts, o imposto sobre vendas é de 6,25%.

1368
01: 03: 24,353 -> 01: 03: 26.520
Então, vamos escrever um pequeno programa que faça isso.

1369
01: 03: 26.520 -> 01: 03: 30.540
Seu total é-- não o "%s", porque não é uma string.

1370
01: 03: 30.540 -> 01: 03: 33.190
Não o percentual i, porque não é um número inteiro.

1371
01: 03: 33,190 -> 01: 03: 37.990
Deve ser %f para float.
1372
01: 03: 37,990 -> 01: 03: 39.350
E, de fato, eu me enganei.

1373
01: 03: 39,350 -> 01: 03: 41.860
Na verdade, cometi um erro aqui acidentalmente.

1374
01: 03: 41,860 -> 01: 03: 44.997
Não quero armazenar o preço em um int se estou entendendo como um float.

1375
01: 03: 44,997 -> 01: 03: 47.080
Se estou obtendo um número real com um ponto decimal,

1376
01: 03: 47.080 -> 01: 03: 49.310
Provavelmente quero armazená-lo como um float também.

1377
01: 03: 49,310 -> 01: 03: 52.480
Então, novamente, códigos de formato diferentes, "placeholders" diferentes

1378
01: 03: 52.480 -> 01: 03: 53.787
para contextos diferentes.

1379
01: 03: 53.787 -> 01: 03: 55.120
Agora, deixe-me ir em frente e fazer isso.
1380
01: 03: 55,120 -> 01: 03: 56.995
E se eu quiser adicionar o preço, vou

1381
01: 03: 56,995 -> 01: 04: 05.230
fazer o preço vezes 1,0625, o que significa apenas matematicamente adicionar 106,25% -

1382
01: 04: 05,230 -> 01: 04: 08.770
ou multiplicar, em vez disso, o preço por 106,25%

1383
01: 04: 08,770 -> 01: 04: 11.203
para que você realmente veja o total com impostos.

1384
01: 04: 11.203 -> 01: 04: 13.120
Tudo bem, então vamos compilar isso.

1385
01: 04: 13,120 -> 01: 04: 14.980
"make float", Enter.

1386
01: 04: 14.980 -> 01: 04: 17.320
Sem mensagens de erro, isso já é promissor.

1387
01: 04: 17.320 -> 01: 04: 18.730
./float.

1388
01: 04: 18,730 -> 01: 04: 19.990
E qual é o preço?
1389
01: 04: 19.990 -> 01: 04: 23.170
Que tal $ 100.

1390
01: 04: 23,170 -> 01: 04: 25.180
OK, isso é um pouco excessivamente preciso.

1391
01: 04: 25,180 -> 01: 04: 29.932
O preço total é $ 106,250000.

1392
01: 04: 29.932 -> 01: 04: 33.130
Mas isso é só porque o computador, de acordo com a semana passada,

1393
01: 04: 33,130 -> 01: 04: 35.440
está usando um certo número de bits para armazenar valores.

1394
01: 04: 35.440 -> 01: 04: 40.120
E o computador passa a ser capaz de mostrar todos esses dígitos

1395
01: 04: 40,120 -> 01: 04: 41.140
após o ponto decimal.

1396
01: 04: 41,140 -> 01: 04: 42.830
Mas e se você não quiser fazer isso?

1397
01: 04: 42.830 -> 01: 04: 46.660
Bem, acontece que existem alguns truques bastante misteriosos que você pode fazer.

1398
01: 04: 46.660 -> 01: 04: 48.910
Em vez de fazer "%f", posso realmente

1399
01:04:48,910 --> 01:04:52,360
fazer %2f, o qual novamente, você poderia somente

1400
01: 04: 52,360 -> 01: 04: 55.570
saber por ter ouvido antes, procurando em um livro ou referência.

1401
01: 04: 55.570 -> 01: 04: 59.150
Isso vai me mostrar apenas dois dígitos após a vírgula decimal.

1402
01: 04: 59,150 -> 01: 05: 02.560
Então, se eu recompilar este código e "make float" e fazer ./float,

1403
01: 05: 02.560 -> 01: 05: 07.720
agora observe se o preço é $ 100, agora meu total é um pouco mais amigável -

1404
01: 05: 07,720 -> 01: 05: 09.790
106,25.

1405
01: 05: 09,790 -> 01: 05: 11.953
Resumindo, este é o f em printf.

1406
01: 05: 11.953 -> 01: 05: 13.870
Assim como você pode imprimir algo na tela,

1407
01: 05: 13.870 -> 01: 05: 19.380
você pode formatá-lo dizendo a printf para mostrar apenas alguns dígitos.

1408
01: 05: 19,380 -> 01: 05: 20.810
Bem, deixe-me tentar outra coisa.

1409
01: 05: 20.810 -> 01: 05: 23.470
Vou copiar / colar o início deste código,

1410
01: 05: 23.470 -> 01: 05: 24.940
apenas para acelerar as coisas.

1411
01: 05: 24.940 -> 01: 05: 27.190
Portanto, posso implementar um programa chamado parity.c.

1412
01: 05: 27,190 -> 01: 05: 30.343
Portanto, paridade é uma maneira elegante de dizer que é um valor par ou ímpar.

1413
01: 05: 30,343 -> 01: 05: 32.260
E eu fui em frente e apenas copiei e colei

1414
01: 05: 32,260 -> 01: 05: 35.708
a configuração do código, não a essência da minha função principal.

1415
01: 05: 35.708 -> 01: 05: 38.500
Mas vamos prosseguir, neste programa, e pedir ao usuário um número.

1416
01: 05: 38,500 -> 01: 05: 39.540
Vamos chamá-lo de n.

1417
01: 05: 39.540 -> 01: 05: 41.620
E usaremos get_int para obter esse valor.

1418
01: 05: 41.620 -> 01: 05: 44.620
E vamos apenas dizer ao humano, qual é o valor de n?

1419
01: 05: 44.620 -> 01: 05: 49.540
E vou apenas dizer n espaço-dois-pontos apenas para solicitar algum número inteiro.

1420
01: 05: 49.540 -> 01: 05: 51.460
Então, vou fazer uma pergunta.

1421
01: 05: 51.460 -> 01: 05: 55.570
Quero, em última análise, quero imprimir par se o número for par ou ímpar

1422
01: 05: 55.570 -> 01: 05: 56.830
se o número for ímpar.

1423
01: 05: 56.830 -> 01: 06: 02.650
Então você pode imaginar fazer isso de uma maneira muito tediosa, como se n for igual a 1,

1424
01: 06: 02,650 -> 01: 06: 06.130
Eu poderia ir em frente e imprimir impar.

1425
01: 06: 06,130 -> 01: 06: 12.340
E então, se n for igual a 2, eu poderia imprimir par.

1426
01: 06: 12,340 -> 01: 06: 16.190
E depois disso, eu poderia dar suporte ao número três, senão se n--

1427
01: 06: 16,190 -> 01: 06: 17.440
Quer dizer, isso é estúpido, certo?

1428
01: 06: 17.440 -> 01: 06: 18.880
Eu poderia fazer isso para sempre.

1429
01: 06: 18,880 -> 01: 06: 21.632
Mas está pelo menos mostrando um padrão, certo?

1430
01: 06: 21,632 -> 01: 06: 24.340
Um e depois três e depois cinco, é claro, vão ser impares,

1431
01: 06: 24,340 -> 01: 06: 26.990
e dois e quatro e seis vão ser pares, e assim por diante.

1432
01: 06: 26,990 -> 01: 06: 29.240
Bem, acontece que podemos calcular isso matematicamente.

1433
01: 06: 29.240 -> 01: 06: 30.970
E um truque muito comum pode ser este -

1434
01: 06: 30.970 -> 01: 06: 32.500
podemos realmente fazer isso.

1435
01: 06: 32,500 -> 01: 06: 39.070
Se n dividido por 2 tem um resto de, por exemplo, 0,

1436
01: 06: 39,070 -> 01: 06: 42.850
então, prosseguirei e concluirei que o número é par.

1437
01: 06: 42.850 -> 01: 06: 45.430
Portanto, este sinal de porcentagem é uma construção nova.

1438
01: 06: 45,430 -> 01: 06: 46.090
Não é positivo.

1439
01: 06: 46.090 -> 01: 06: 47.440
Não é menos.

1440
01: 06: 47.440 -> 01: 06: 49.240
Não é multiplicação ou divisão.

1441
01: 06: 49,240 -> 01: 06: 53.150
Esta é a operação de resto, ou a operação de módulo, por assim dizer.

1442
01: 06: 53,150 -> 01: 06: 59.470
E isso significa apenas dividir n por 2, e se a resposta tiver um resto de 0,

1443
01: 06: 59.470 -> 01: 07: 02.670
você pode concluir, por definição de par, que o número é par.

1444
01: 07: 02,670 -> 01: 07: 04.100
Vou imprimir isso.

1445
01: 07: 04,100 -> 01: 07: 08.320
Senão - eu poderia fazer outra coisa se n por cento 2 for igual a 1

1446
01: 07: 08,320 -> 01: 07: 11.380
e tem um resto de 1, você pode imaginar dizendo impar.

1447
01: 07: 11,380 -> 01: 07: 15.405
Mas, como você observou anteriormente, isso não é necessário.

1448
01: 07: 15.405 -> 01: 07: 18.280
O que eu poderia fazer para tornar o programa um pouco melhor projetado,
1449
01: 07: 18,280 -> 01: 07: 19.600
um pouco mais eficiente?

1450
01: 07: 19.600 -> 01: 07: 20.248
Sim?

1451
01: 07: 20,248 -> 01: 07: 22.440
PÚBLICO: Você poderia apenas usar o else e isso seria ótimo.

1452
01: 07: 22,440 -> 01: 07: 22.770
DAVID MALAN: Sim.

1453
01: 07: 22,770 -> 01: 07: 24.687
Então, se estamos falando de inteiros, posso apenas

1454
01: 07: 24.687 -> 01: 07: 28.360
concluir, bem, se não for par, deve ser impar, por definição.

1455
01: 07: 28,360 -> 01: 07: 30.510
E aqui, podemos apenas fazer pares e ímpares.

1456
01: 07: 30.510 -> 01: 07: 33.510
Portanto, este programa, uma vez executado, terá esta aparência.

1457
01: 07: 33.510 -> 01: 07: 35.400
"make parity"

1458
01: 07: 35.400 -> 01: 07: 36.630
Parece que compilou bem.

1459
01: 07: 36.630 -> 01: 07: 38.880
Então ./paridade é como eu o executo.

1460
01: 07: 38,880 -> 01: 07: 40.290
Vamos digitar o número 50.

1461
01: 07: 40.290 -> 01: 07: 40.950
Isso mesmo.

1462
01: 07: 40,950 -> 01: 07: 42.510
Vamos digitar o número 49.

1463
01: 07: 42,510 -> 01: 07: 43.380
este é impar.

1464
01: 07: 43,380 -> 01: 07: 44.850
Prova por exemplo.

1465
01: 07: 44,850 -> 01: 07: 48.060
Isso não é muito convincente, mas aposto que vai ser correto, apenas

1466
01: 07: 48.060 -> 01: 07: 49.480
com base apenas nesses dois exemplos.

1467
01: 07: 49.480 -> 01: 07: 49.980
Sim?

1468
01: 07: 49,980 -> 01: 07: 52.938
PÚBLICO: [INAUDÍVEL] o usuário não entendeu nosso comentário que respondeu

1469
01: 07: 52,938 -> 01: 07: 54.332
um float ou não um inteiro?

1470
01: 07: 54,332 -> 01: 07: 55.790
DAVID MALAN: Desculpe, diga isso de novo?

1471
01: 07: 55,790 -> 01: 07: 58.207
PÚBLICO: E se o usuário não entender, estou dizendo?

1472
01: 07: 58,207 -> 01: 08: 02.783
Tipo, eu faço algo como 1.5 [INAUDÍVEL] ..

1473
01: 08: 02,783 -> 01: 08: 04.200
DAVID MALAN: Boa pergunta.

1474
01: 08: 04,200 -> 01: 08: 06.950
Uma das razões que fornecemos nas primeiras semanas de aula

1475
01: 08: 06,950 -> 01: 08: 10.700
algumas funções na biblioteca CS50 como get_string e get_int e get_float

1476
01: 08: 10.700 -> 01: 08: 14.960
é que força o usuário a se comportar como você espera, para seu programa não

1477
01: 08: 14.960 -> 01: 08: 17.149
travar devido a entrada inesperada do usuário.

1478
01: 08: 17,149 -> 01: 08: 20.180
Então, para seu ponto, suponha que o usuário esteja sendo um pouco difícil e diga:

1479
01: 08: 20,180 -> 01: 08: 22.939
meu número será 1,5.

1480
01: 08: 22.939 -> 01: 08: 27.854
Get_int irá solicitar a mesma pergunta repetidas vezes

1481
01: 08: 27.854 -> 01: 08: 28.729
até que eles cooperem.

1482
01: 08: 28,729 -> 01: 08: 31.819
Se você digitar "maça", será exibido novamente.

1483
01: 08: 31.819 -> 01: 08: 34.880
Somente depois de fornecer um número inteiro real ele cooperará.

1484
01: 08: 34.880 -> 01: 08: 37.540
Portanto, esses estão entre os recursos que você obtém da biblioteca CS50,

1485
01: 08: 37.540 -> 01: 08: 39.410
apenas para que possamos nos concentrar em ideias e não

1486
01: 08: 39.410 -> 01: 08: 44.270
no que chamaríamos de verificação de erros, ou usuários mal-intencionados, neste caso.

1487
01: 08: 44.270 -> 01: 08: 46.670
Tudo bem, então o que mais podemos fazer uma vez que

1488
01: 08: 46.670 -> 01: 08: 49.279
temos a capacidade de expressar condições?

1489
01: 08: 49,279 -> 01: 08: 52.010
Bem, deixe-me ir em frente e abrir um que trouxe comigo.

1490
01: 08: 52.010 -> 01: 08: 54.109
Então, em vez de digitar tudo do zero,

1491
01: 08: 54,109 -> 01: 08: 56.618
deixe-me ir em frente e abrir as conditions1.c.

1492
01: 08: 56.618 -> 01: 08: 58.660
Portanto, este é um programa que já foi escrito.

1493
01: 08: 58.660 -> 01: 09: 00.920
E acontece que tem algumas outras linhas,

1494
01: 09: 00,920 -> 01: 09: 03.643
esses contornos acinzentados que começam com barra barra.

1495
01: 09: 03.643 -> 01: 09: 05.810
Você pode não ter notado isso, mas no Scratch, você

1496
01: 09: 05,810 -> 01: 09: 06.979
pode ter o que se chama de comentários.

1497
01: 09: 06,979 -> 01: 09: 09.050
Eles são como pequenas notas adesivas que você pode adicionar

1498
01: 09: 09,050 -> 01: 09: 10.550
que não fazem nada funcionalmente.

1499
01: 09: 10.550 -> 01: 09: 13.825
É como notas para você mesmo ou para seu amigo ou notas para o seu TF.

1500
01: 09: 13.825 -> 01: 09: 15.950
Isso é o que um comentário é em uma linguagem de programação.

1501
01: 09: 15.950 -> 01: 09: 19.310
Portanto, qualquer coisa que comece com uma barra é uma nota para mim.

1502
01: 09: 19,310 -> 01: 09: 21.873
E é um lembrete para mim do que essa linha de código faz.

1503
01: 09: 21,873 -> 01: 09: 24.040
É um lembrete para seus colegas do mundo real

1504
01: 09: 24,040 -> 01: 09: 27.380
ou seu TF em uma aula para explicar a eles o que esta linha de código

1505
01: 09: 27,380 -> 01: 09: 30.520
deveria estar fazendo, mesmo que você tenha um bug

1506
01: 09: 30.520 -> 01: 09: 32.090
e não está realmente fazendo isso.

1507
01: 09: 32.090 -> 01: 09: 35.840
Então, comecei, nestes exemplos pré-criados, a comentar meu código,

1508
01: 09: 35.840 -> 01: 09: 37.580
mas as linhas são essencialmente as mesmas.

1509
01: 09: 37.580 -> 01: 09: 40.250
Vá em frente e me dê acesso à biblioteca CS50.

1510
01: 09: 40,250 -> 01: 09: 43.010
E uma biblioteca, novamente, é apenas um arquivo de código

1511
01: 09: 43.010 -> 01: 09: 45.080
que outra pessoa escreveu que estamos usando.

1512
01: 09: 45,080 -> 01: 09: 47.960
E me dê acesso à biblioteca padrão de I/O, que contém

1513
01: 09: 47,960 -> 01: 09: 50.430
printf e algumas outras coisas também.

1514
01: 09: 50.430 -> 01: 09: 54.170
Observe aqui, eu tenho x igual a get_int com o objetivo de

1515
01: 09: 54,170 -> 01: 09: 56.390
obter um inteiro do usuário chamado x.

1516
01: 09: 56,390 -> 01: 09: 59.840
Agora vou pedir um segundo inteiro apenas chamando de y

1517
01: 09: 59.840 -> 01: 10: 01.400
e chamando get_int novamente.

1518
01: 10: 01.400 -> 01: 10: 03.840
E agora posso fazer coisas como comparar esses valores.

1519
01: 10: 03.840 -> 01: 10: 07.790
Portanto, esta é agora uma versão completa do programa tipo Scratch

1520
01: 10: 07,790 -> 01: 10: 11.450
Eu puxei antes que nos permite concluir que é x menor do que y,

1521
01: 10: 11.450 -> 01: 10: 15.290
maior que y, ou, por padrão, igual a y.

1522
01: 10: 15,290 -> 01: 10: 19.080
Portanto, a única diferença é que vimos essas linhas de código na tela antes.

1523
01: 10: 19.080 -> 01: 10: 22.340
Agora vemos, no contexto, que, para essas linhas funcionarem,

1524
01: 10: 22,340 -> 01: 10: 25.640
precisamos obter os inteiros do usuário.

1525
01: 10: 25.640 -> 01: 10: 28.520
E precisamos ter o equivalente a quando a bandeira verde é clicada,

1526
01: 10: 28.520 -> 01: 10: 31.115
e precisamos do equivalente a estes includes para que seja

1527
01: 10: 31,115 -> 01: 10: 33.575
um programa completo e independente.

1528
01: 10: 33.575 -> 01: 10: 35.450
E só para ficar claro, embora eu tenha feito isso

1529
01: 10: 35.450 -> 01: 10: 38.710
antecipadamente, se eu quisesse executar este programa, como poderia executá-lo?

1530
01: 10: 38,710 -> 01: 10: 41.770
Chame coditions.c

1531
01: 10: 41.770 -> 01: 10: 45.030
Sim, então estabeleça as condições primeiro.

1532
01: 10: 45.030 -> 01: 10: 45.530
Desculpe.

1533
01: 10: 45.530 -> 01: 10: 48.140
Oh, este é realmente um momento para se ensinar.

1534
01: 10: 48,140 -> 01: 10: 49.670
Por que isso não funcionou?

1535
01: 10: 49.670 -> 01: 10: 54.020
Portanto, nenhuma regra para impedir as condições-alvo, o que é um pouco enfático.

1536
01: 10: 54.020 -> 01: 10: 55.130
Mas o que isso significa?

1537
01: 10: 55,130 -> 01: 10: 58.700
Bem, antecipadamente hoje, o que eu fiz foi baixar para o meu sandbox

1538
01: 10: 58,700 -> 01: 11: 02.630
uma pasta chamada src1, S-R-C que significa "fonte" na linguagem do programador.
1539
01: 11: 02.630 -> 01: 11: 06.140
E acabei de baixar na sandbox para mim.

1540
01: 11: 06,140 -> 01: 11: 08.540
Porque nessa pasta estão todos os exemplos

1541
01: 11: 08.540 -> 01: 11: 12.050
não só que escrevi ao vivo, mas também algumas outras que trouxe comigo.

1542
01: 11: 12.050 -> 01: 11: 15.920
Infelizmente, todos esses arquivos estão em uma pasta chamada src1.

1543
01: 11: 15.920 -> 01: 11: 18.920
Agora, no seu Mac ou PC, se você quiser abrir uma pasta, faça o que eu fiz.

1544
01: 11: 18,920 -> 01: 11: 22.100
Você duplica o ícone e bum, a pasta está aberta.

1545
01: 11: 22,100 -> 01: 11: 25.880
Mas em uma janela de terminal, um ambiente baseado em texto, você não pode fazer isso.

1546
01: 11: 25,880 -> 01: 11: 29.840
Se eu digitar ls, veremos todos os arquivos que criei hoje -

1547
01: 11: 29.840 -> 01: 11: 32.120
float e hello e int.

1548
01: 11: 32,120 -> 01: 11: 34.520
Mas observe aqui, há uma pasta.

1549
01: 11: 34.520 -> 01: 11: 36.145
E é isso que a barra final é.

1550
01: 11: 36,145 -> 01: 11: 38.270
Essa é uma barra que significa, ei, humano,

1551
01: 11: 38,270 -> 01: 11: 40.250
esta é uma pasta, então é óbvio.

1552
01: 11: 40,250 -> 01: 11: 44.150
Assim como o asterisco significa que aqui está um código de máquina que você pode executar.

1553
01: 11: 44,150 -> 01: 11: 47.270
Preciso mudar para esse diretório, mas não consigo clicar duas vezes.

1554
01: 11: 47,270 -> 01: 11: 49.700
Nada vai acontecer se eu clicar duas vezes neste texto.

1555
01: 11: 49,700 -> 01: 11: 53.650
Mas posso digitar cd space src1.

1556
01: 11: 53.650 -> 01: 11: 55.760
cd significa mudança de diretório.

1557
01: 11: 55,760 -> 01: 11: 57.200
E agora eu pressiono Enter.

1558
01: 11: 57,200 -> 01: 11: 59.990
E agora, se eu clicar em ls, percebo que vejo ainda mais arquivos,

1559
01: 11: 59,990 -> 01: 12: 03.110
porque esses são todos os arquivos do site do curso

1560
01: 12: 03,110 -> 01: 12: 05.180
que eu trouxe comigo hoje.

1561
01: 12: 05,180 -> 01: 12: 08.037
E se você digitar um comando como este, pwd,

1562
01: 12: 08,037 -> 01: 12: 10.370
isso revelará ainda mais informações sobre o sistema,

1563
01: 12: 10,370 -> 01: 12: 12.050
mas mais sobre isso nas próximas semanas.

1564
01: 12: 12.050 -> 01: 12: 16.160
Na verdade, você está dentro de uma pasta src1 que está dentro de uma pasta sandbox

1565
01: 12: 16,160 -> 01: 12: 17.840
que está dentro de uma pasta raiz.

1566
01: 12: 17.840 -> 01: 12: 21.140
Agora, as chances são de que, em algum ponto, você ficará confuso sobre onde está.

1567
01: 12: 21,140 -> 01: 12: 23.150
Em caso de dúvida, basta digitar cd.

1568
01: 12: 23,150 -> 01: 12: 25.950
Isso o levará para a pasta padrão onde você começou,

1569
01: 12: 25.950 -> 01: 12: 28.430
não importa onde você se encontre.

1570
01: 12: 28.430 -> 01: 12: 30.470
Digite ls e você estará de volta ao início.

1571
01: 12: 30.470 -> 01: 12: 32.570
Então, em caso de dúvida, basta digitar cd e Enter,

1572
01: 12: 32.570 -> 01: 12: 34.430
e você estará de volta ao início.

1573
01: 12: 34.430 -> 01: 12: 37.610
Bem, deixe-me ir em frente e abrir este programa, mas execute este primeiro.

1574
01: 12: 37.610 -> 01: 12: 40.190
Vou entrar em um programa chamado agree.c.

1575
01: 12: 40,190 -> 01: 12: 44.520
Vou ocultar o código por um momento e chamar agree.

1576
01: 12: 44.520 -> 01: 12: 47.360
Fiz de novo, cd src1, Enter.

1577
01: 12: 47,360 -> 01: 12: 49.800
Agora posso make agree.

1578
01: 12: 49.800 -> 01: 12: 51.500
Parece ter compilado o programa.

1579
01: 12: 51,500 -> 01: 12: 55.700
E se eu fizer ./agree, este programa parece estar me fazendo uma pergunta -

1580
01: 12: 55,700 -> 01: 12: 56.523
você concorda?

1581
01: 12: 56.523 -> 01: 12: 58.940
Agora, não é óbvio no programa o que devo digitar,

1582
01: 12: 58.940 -> 01: 13: 01.220
mas meu instinto me diz, claro, sim.

1583
01: 13: 01,220 -> 01: 13: 04.370
Portanto, vou prosseguir e digitar y para sim e Enter.

1584
01: 13: 04,370 -> 01: 13: 06.050
E parece saber que concordei.

1585
01: 13: 06,050 -> 01: 13: 07.490
Se eu executá-lo novamente -

1586
01: 13: 07.490 -> 01: 13: 11.900
./agree-- e digite n desta vez, não concordado.

1587
01: 13: 11.900 -> 01: 13: 12.650
Mas você sabe o que?

1588
01: 13: 12,650 -> 01: 13: 13.942
Na verdade, é melhor do que isso.

1589
01: 13: 13,942 -> 01: 13: 18.650
Se eu concordar ./agree e talvez digitar um Y maiúsculo, Enter, isso também parece funcionar.

1590
01: 13: 18.650 -> 01: 13: 20.130
Então, como isso está acontecendo?

1591
01: 13: 20,130 -> 01: 13: 21.770
Bem, deixe-me ver o código aqui.

1592
01: 13: 21.770 -> 01: 13: 25.190
O topo do arquivo é quase idêntico a tudo até agora.

1593
01: 13: 25,190 -> 01: 13: 27.650
Inclui esses dois arquivos, int main void.

1594
01: 13: 27,650 -> 01: 13: 30.320
Mas agora estou usando get_char e armazenando minha resposta

1595
01: 13: 30,320 -> 01: 13: 33.710
em uma variável chamada c, mas posso armazená-la em qualquer coisa que eu quiser.

1596
01: 13: 33.710 -> 01: 13: 36.350
E agora observe a sintaxe ligeiramente nova.

1597
01: 13: 36,350 -> 01: 13: 41.300
O que há de novo sobre o que estou fazendo aqui?

1598
01: 13: 41,300 -> 01: 13: 43.910
Que símbolos aparecem?

1599
01: 13: 43.910 -> 01: 13: 45.200
Sim, a barra vertical.

1600
01: 13: 45,200 -> 01: 13: 48.020
Portanto, esta é uma maneira de dizer um ou lógico.

1601
01: 13: 48,020 -> 01: 13: 50.630
Então, em Python e em algumas outras linguagens hoje em dia, você

1602
01: 13: 50,630 -> 01: 13: 52.280
pode escrever literalmente a palavra "or/ou".

1603
01: 13: 52,280 -> 01: 13: 57.500
Isso não funciona em C. Se você quiser fazer esta pergunta ou esta pergunta

1604
01: 13: 57.500 -> 01: 14: 00.740
e aceite qualquer uma das respostas como uma resposta válida,

1605
01: 14: 00,740 -> 01: 14: 03.020
você apenas usa duas barras verticais, que normalmente são

1606
01: 14: 03,020 -> 01: 14: 05.720
acima da tecla Enter em um teclado americano, pelo menos.

1607
01: 14: 05,720 -> 01: 14: 07.760
Portanto, duas barras verticais significam ou.

1608
01: 14: 07,760 -> 01: 14: 10.640
Dois &, ao que parece, significa e.

1609
01: 14: 10.640 -> 01: 14: 13.940
Mas esta é apenas uma maneira de fazer duas perguntas ao mesmo tempo

1610
01: 14: 13,940 -> 01: 14: 16.800
e aceitar qualquer uma das respostas como potencialmente verdadeiras.

1611
01: 14: 16,800 -> 01: 14: 21.650
Portanto, se c for Y maiúsculo ou c for y minúsculo, assuma que o humano concordou.

1612
01: 14: 21.650 -> 01: 14: 26.090
Caso contrário, se c for igual a N maiúsculo ou n minúsculo, assuma que eles não concordaram.

1613
01: 14: 26.090 -> 01: 14: 28.970
E suponha que eu digite alguma outra letra toda junto,

1614
01: 14: 28.970 -> 01: 14: 32.220
o que o programa vai fazer?

1615
01: 14: 32,220 -> 01: 14: 32.720
Repita?

1616
01: 14: 32,720 -> 01: 14: 33.740
PÚBLICO: Perguntar novamente.

1617
01: 14: 33.740 -> 01: 14: 35.000
DAVID MALAN: Não vai me perguntar de novo,

1618
01: 14: 35.000 -> 01: 14: 36.950
porque não há loop aqui, certo?

1619
01: 14: 36.950 -> 01: 14: 41.360
Não há evidência de while ou for aqui.

1620
01: 14: 41,360 -> 01: 14: 46.190
E get_char vai literalmente pegar um char, mas não especifica qual char.

1621
01: 14: 46,190 -> 01: 14: 50.900
O que acontece se eu não digitar y ou n, maiúsculo ou minúsculo?

1622
01: 14: 50,900 -> 01: 14: 52.103
Parece que nada.

1623
01: 14: 52,103 -> 01: 14: 54.020
Nada vai acontecer, e tudo bem.

1624
01: 14: 54,020 -> 01: 14: 56.210
Seu programa não precisa imprimir nada.

1625
01: 14: 56,210 -> 01: 15: 01.060
E, de fato, se eu executar novamente e ./agree x.

1626
01: 15: 01.060 -> 01: 15: 02.130
Não faz nada.

1627
01: 15: 02,130 -> 01: 15: 03.860
Portanto, não concordei nem discordei.

1628
01: 15: 03,860 -> 01: 15: 07.910
No entanto, você pode imaginar escrever um loop que de alguma forma força o humano

1629
01: 15: 07,910 -> 01: 15: 10.117
para cooperar de uma forma ou de outra.

1630
01: 15: 10,117 -> 01: 15: 12.200
Tudo bem, vamos fazer um exemplo diferente, desta vez

1631
01: 15: 12,200 -> 01: 15: 15.800
baseado em uma ideia da última vez - a de abstração.

1632
01: 15: 15,800 -> 01: 15: 18.980
Lembre-se de que no Scratch não havia nenhuma peça do quebra-cabeça para tossir,

1633
01: 15: 18.980 -> 01: 15: 21.620
para fazer o gato [TOSSIR] na tela.

1634
01: 15: 21.620 -> 01: 15: 25.070
E então implementamos isso, realmente, com nossa própria peça de quebra-cabeça personalizada,

1635
01: 15: 25.070 -> 01: 15: 25.850
em última análise.

1636
01: 15: 25.850 -> 01: 15: 30.080
Deixe-me criar um programa chamado cough0.c.

1637
01: 15: 30.080 -> 01: 15: 33.140
Essa é uma definição generosa de inatividade, mas OK.

1638
01: 15: 33,140 -> 01: 15: 35.960
Deixe-me recarregar a tela.

1639
01: 15: 35.960 -> 01: 15: 38.420
Na dúvida, no CS50, como na vida, recarregue.

1640
01: 15: 38.420 -> 01: 15: 39.920
Isso provavelmente vai resolver.

1641
01: 15: 39,920 -> 01: 15: 43.248
Infelizmente, com a programação e a internet, isso às vezes acontece.

1642
01: 15: 43.248 -> 01: 15: 45.290
Então, em um momento, o que vou fazer

1643
01: 15: 45,290 -> 01: 15: 49.730
é traduzir essa ideia do Scratch de implementar a noção de tosse.

1644
01: 15: 49,730 -> 01: 15: 54.060
Mas em vez do bloco de dizer, vou usar o bloco printf ou 

1645
01: 15: 54.060 -> 01: 15: 54.990
a função printf.

1646
01: 15: 54,990 -> 01: 15: 58.700
E então vou prosseguir e projetar esta versão do código ligeiramente

1647
01: 15: 58,700 -> 01: 16: 01.920
cada vez melhor e ligeiramente melhor.

1648
01: 16: 01,920 -> 01: 16: 07.010
Vou prosseguir e abrir um arquivo cough0.c.

1649
01: 16: 07,010 -> 01: 16: 11.900
E vou prosseguir e incluir, digamos, stdio.h.

1650
01: 16: 11.900 -> 01: 16: 16.180
Vou prosseguir e fazer int main void, que, de novo, é apenas o nosso caldeirão

1651
01: 16: 16,180 -> 01: 16: 18.080
de referências ou copiar/colar para hoje.

1652
01: 16: 18.080 -> 01: 16: 21.080
Vou prosseguir, então, e dizer printf, aspas, aspas,

1653
01: 16: 21,080 -> 01: 16: 22.580
tosse e "\n" para uma nova linha.

1654
01: 16: 22.580 -> 01: 16: 25.050
E lembre-se, no Scratch eu queria que isso acontecesse três vezes,

1655
01: 16: 25,050 -> 01: 16: 27.300
então vou fazer assim - tosse, tosse, tosse.

1656
01: 16: 27,300 -> 01: 16: 31.520
Tudo bem, vou me dar uma janela de terminal aqui na parte inferior

1657
01: 16: 31.520 -> 01: 16: 35.330
para que agora eu possa ir em frente e dizer make cough0, Enter.

1658
01: 16: 35,330 -> 01: 16: 39.470
Nada de ruim parece acontecer. ./cough0 e tosse, tosse, tosse.

1659
01: 16: 39.470 -> 01: 16: 42.950
Então, na semana passada, afirmei que, hã, você pode projetar isso melhor, certo?

1660
01: 16: 42.950 -> 01: 16: 44.960
Sempre que você estiver copiando e colando, provávelmente

1661
01: 16: 44,960 -> 01: 16: 46.850
você deve começar a resistir a essa tentação,

1662
01: 16: 46.850 -> 01: 16: 49.933
porque vai levar a um código confuso, um código mais longo do que o necessário.

1663
01: 16: 49,933 -> 01: 16: 52.133
Qual é a solução para esse problema da semana passada?

1664
01: 16: 52,133 -> 01: 16: 52.920
PÚBLICO: Um loop.

1665
01: 16: 52,920 -> 01: 16: 54.390
DAVID MALAN: Sim, um loop, um loop for.

1666
01: 16: 54,390 -> 01: 16: 55.682
Então, deixe-me ir em frente e fazer isso.

1667
01: 16: 55.682 -> 01: 16: 57.693
Deixe-me criar outra versão, cough1.c.

1668
01: 16: 57,693 -> 01: 17: 00.360
E vou copiar/colar este código, apenas como ponto de partida.

1669
01: 17: 00,360 -> 01: 17: 02.400
Mas agora vou limpar tudo.

1670
01: 17: 02.400 -> 01: 17: 04.960
Então, vou prosseguir e, em vez disso, fazer um loop for.

1671
01: 17: 04,960 -> 01: 17: 07.460
E ainda não me lembro bem do que está entre parênteses,

1672
01: 17: 07.460 -> 01: 17: 08.690
mas vamos voltar a isso.

1673
01: 17: 08.690 -> 01: 17: 12.530
Eu sei que o que eu quero fazer algumas vezes é apenas tossir.

1674
01: 17: 12.530 -> 01: 17: 15.333
Portanto, a única coisa em questão é: qual era a sintaxe aqui?

1675
01: 17: 15,333 -> 01: 17: 17.250
Bem, podemos escrever isso de várias maneiras,

1676
01: 17: 17,250 -> 01: 17: 18.890
e poderíamos até usar um loop while.

1677
01: 17: 18,890 -> 01: 17: 22.520
Mas me lembro de dizer int e depois o nome de uma variável.

1678
01: 17: 22.520 -> 01: 17: 24.960
Eu poderia dizer contar, ou poderia apenas dizer

1679
01: 17: 24,960 -> 01: 17: 28.970
i para mantê-lo sucinto, é igual a 0 por padrão.

1680
01: 17: 28.970 -> 01: 17: 32.540
Eu poderia fazer isso desde que i seja menor que 3, por exemplo.

1681
01: 17: 32.540 -> 01: 17: 38.070
E então, em cada iteração, posso dizer que i é igual a i mais 1 ou, mais sucintamente,

1682
01: 17: 38,070 -> 01: 17: 39.710
i mais mais.

1683
01: 17: 39,710 -> 01: 17: 41.223
Portanto, novamente, é uma série de novas sintaxes.

1684
01: 17: 41,223 -> 01: 17: 43.140
E agora há pontos-e-vírgulas por todo o lugar.

1685
01: 17: 43,140 -> 01: 17: 46.700
Mas se eu for em frente e "make cough1",

1686
01: 17: 46,700 -> 01: 17: 48.410
nada de ruim parece ter acontecido.

1687
01: 17: 48.410 -> 01: 17: 51.020
./cough1, tosse, tosse, tosse.

1688
01: 17: 51,020 -> 01: 17: 53.180
Parece ser um pouco melhor projetado.

1689
01: 17: 53,180 -> 01: 17: 55.460
Infelizmente, existe esse paradigma na programação

1690
01: 17: 55.460 -> 01: 18: 00.110
onde humanos, programadores, tendem a pensar ou a contar começando do zero.

1691
01: 18: 00,110 -> 01: 18: 02.240
No entanto, se você não gosta disso, pelo menos no início,

1692
01: 18: 02,240 -> 01: 18: 05.210
não há nada me impedindo de inicializar i com 1

1693
01: 18: 05,210 -> 01: 18: 08.420
e fazer i é menor que 4 ou, ainda mais explicitamente,

1694
01: 18: 08,420 -> 01: 18: 10.655
i é menor ou igual a 3.

1695
01: 18: 10.655 -> 01: 18: 13.280
Não há sinal de menor igual no teclado, normalmente,

1696
01: 18: 13,280 -> 01: 18: 17.390
então você pode imitá-lo fazendo um sinal de menor que e, em seguida, um sinal de igual, dois caracteres.

1697
01: 18: 17,390 -> 01: 18: 18.800
Isso é logicamente o mesmo.

1698
01: 18: 18,800 -> 01: 18: 20.240
Defina i igual a 1.

1699
01: 18: 20.240 -> 01: 18: 23.450
Então vá em frente e imprima a tosse e certifique-se de incrementá-la.

1700
01: 18: 23.450 -> 01: 18: 26.150
E certifique-se de que ainda seja menos de 3 e 2 é.

1701
01: 18: 26,150 -> 01: 18: 28.850
Certifique-se de que ainda é menor ou igual a 3 e ainda é.

1702
01: 18: 28,850 -> 01: 18: 31.620
Portanto, o 2, logicamente, terá o mesmo efeito.

1703
01: 18: 31.620 -> 01: 18: 36.590
No entanto, no interesse da convenção, essa seria a abordagem mais comum.

1704
01: 18: 36.590 -> 01: 18: 42.768
Faça isso enquanto i for igual a 0 e, em seguida, 1 e 2, para um total de 3 vezes.
1705
01: 18: 42,768 -> 01: 18: 44.810
Tudo bem, mas lembre-se do que fizemos da última vez também,

1706
01: 18: 44,810 -> 01: 18: 47.540
é que se eu estou escrevendo muito código, por algum motivo,

1707
01: 18: 47,540 -> 01: 18: 51.800
envolve programas de tosse, seria bom ter a minha própria customização

1708
01: 18: 51,800 -> 01: 18: 52.920
desta função.

1709
01: 18: 52,920 -> 01: 18: 54.450
Então, deixe-me ir em frente e fazer isso.

1710
01: 18: 54.450 -> 01: 18: 58.430
Deixe-me prosseguir e escrever minha primeira função totalmente nova.

1711
01: 18: 58,430 -> 01: 19: 00.570
E vou fazer isso da seguinte maneira.

1712
01: 19: 00,570 -> 01: 19: 04.220
Vou prosseguir e digitar void e, em seguida, o nome da função que desejo.

1713
01: 19: 04,220 -> 01: 19: 07.160
Então vou dizer vazio aqui, por razões às quais voltaremos.

1714
01: 19: 07,160 -> 01: 19: 10.160
E então vou literalmente apenas ir em frente e dizer cough.

1715
01: 19: 10,160 -> 01: 19: 14.120
Portanto, existem funções que usamos hoje - printf, get_int, get_string,
1716
01: 19: 14,120 -> 01: 19: 18.650
get_float-- nenhum dos quais mostramos a implementação feita, porque as pessoas,

1717
01: 19: 18.650 -> 01: 19: 21.270
anos atrás, tanto na equipe quanto no mundo real,

1718
01: 19: 21,270 -> 01: 19: 23.000
implementou essas funções para nós.

1719
01: 19: 23.000 -> 01: 19: 26.270
Você também pode implementar suas próprias funções personalizadas ou, no Scratch,

1720
01: 19: 26,270 -> 01: 19: 29.690
aquelas peças do quebra-cabeça que fizemos nesses blocos rosa.

1721
01: 19: 29.690 -> 01: 19: 31.940
Então, se você quiser fazer sua própria função cujo nome é

1722
01: 19: 31.940 -> 01: 19: 35.960
cough, cujo objetivo na vida é dizer tosse na tela,

1723
01: 19: 35,960 -> 01: 19: 37.010
esta é a sintaxe.

1724
01: 19: 37,010 -> 01: 19: 40.880
Para os fins de hoje, você diz void and void aqui, mas o nome da função

1725
01: 19: 40,880 -> 01: 19: 41.690
é importante.

1726
01: 19: 41,690 -> 01: 19: 43.040
Vou chamar de cough.

1727
01: 19: 43.040 -> 01: 19: 45.000
E então posso usá-lo da seguinte maneira.

1728
01: 19: 45.000 -> 01: 19: 50.750
Eu posso dizer tosse, tosse, tosse agora para tossir três vezes.

1729
01: 19: 50,750 -> 01: 19: 53.150
Ou ainda, já decidimos que era um design ruim.

1730
01: 19: 53,150 -> 01: 19: 57.770
Para int eu obtenho 0, i menor que 3, i mais mais.

1731
01: 19: 57.770 -> 01: 20: 00.230
Agora posso fazer algo como tossir.

1732
01: 20: 00,230 -> 01: 20: 03.290
E agora, novamente, fora de vista, longe da mente.

1733
01: 20: 03.290 -> 01: 20: 07.460
Não preciso saber ou me importar como a função da tosse é implementada.

1734
01: 20: 07.460 -> 01: 20: 10.850
Posso me importar que meu código apenas diga ao computador o que fazer.

1735
01: 20: 10.850 -> 01: 20: 15.260
Para i de 0 em até 3, tosse, tosse, tosse.

1736
01: 20: 15.260 -> 01: 20: 16.480
E isso é uma abstração.

1737
01: 20: 16.480 -> 01: 20: 18.950
Não me importa se a tosse é implementada com printf.

1738
01: 20: 18.950 -> 01: 20: 22.070
Eu só me importo se houver uma função chamada tosse.

1739
01: 20: 22.070 -> 01: 20: 25.490
Então, deixe-me executar isso e ver o que acontece.

1740
01: 20: 25.490 -> 01: 20: 28.710
Deixe-me rolar até o final, faça tosse1.

1741
01: 20: 28,710 -> 01: 20: 29.750
OK, incrível.

1742
01: 20: 29.750 -> 01: 20: 30.830
Sem erros vermelhos agora.

1743
01: 20: 30.830 -> 01: 20: 34.550
Então ./tosse1, tosse, tosse, tosse.

1744
01: 20: 34.550 -> 01: 20: 38.553
Mas observe que este é um projeto um pouco ruim, eu diria,

1745
01: 20: 38.553 -> 01: 20: 39.470
porque você sabe o quê?

1746
01: 20: 39.470 -> 01: 20: 42.890
Se você continuar escrevendo funções personalizadas aqui, aqui, aqui,

1747
01: 20: 42.890 -> 01: 20: 46.145
a parte principal de seu programa será empurrada para baixo.

1748
01: 20: 46,145 -> 01: 20: 48.770
E é uma convenção humana geralmente ter a função principal

1749
01: 20: 48.770 -> 01: 20: 49.790
na parte superior do seu arquivo.

1750
01: 20: 49,790 -> 01: 20: 50.790
Parece bastante razoável.

1751
01: 20: 50,790 -> 01: 20: 53.420
Então você abre o arquivo, bum, a função principal está bem ali.

1752
01: 20: 53.420 -> 01: 20: 54.620
Então, vamos mantê-lo lá.

1753
01: 20: 54.620 -> 01: 20: 58.448
Então, deixe-me mover a função da cough para baixo, apenas para

1754
01: 20: 58,448 -> 01: 21: 01.490
que, novamente, a primeira coisa que vejo é de fato a parte principal do meu programa.

1755
01: 21: 01,490 -> 01: 21: 03.020
E onde quer que esteja a tosse, não me importo.

1756
01: 21: 03,020 -> 01: 21: 05.090
Esse foi o objetivo de implementá-lo.

1757
01: 21: 05.090 -> 01: 21: 08.990
Deixe-me ir agora para a janela do meu terminal e "make cough1".

1758
01: 21: 08,990 -> 01: 21: 12.500
Oh meu Deus, alguns erros vermelhos passaram voando.

1759
01: 21: 12.500 -> 01: 21: 14.030
O que há de errado aqui?

1760
01: 21: 14.030 -> 01: 21: 19.130
So error, implicit declaration of function cough is invalid in C '99.

1761
01: 21: 19,130 ​​-> 01: 21: 22.610
C '99 significa a versão de C inventada em 1999.

1762
01: 21: 22.610 -> 01: 21: 23.690
O que está acontecendo?

1763
01: 21: 23.690 -> 01: 21: 25.100
Implicit declaration/Declaração Implicita?

1764
01: 21: 25,100 -> 01: 21: 27.500
Então é aqui que C difere do Scratch novamente.

1765
01: 21: 27,500 -> 01: 21: 29.840
C é velho e meio burro.

1766
01: 21: 29.840 -> 01: 21: 32.840
Ele só sabe o que você diz, e só

1767
01: 21: 32.840 -> 01: 21: 36.290
sabe o que você diz em ordem de cima para baixo, da esquerda para a direita.

1768
01: 21: 36,290 -> 01: 21: 41.480
Portanto, neste programa agora, incluí stdio.h, como antes.

1769
01: 21: 41,480 -> 01: 21: 43.700
Eu incluí o início de a função "main".

1770
01: 21: 43,700 -> 01: 21: 45.480
Eu comecei um loop for.

1771
01: 21: 45,480 -> 01: 21: 48.320
E então estou usando uma função que aparentemente é chamada de cough.

1772
01: 21: 48,320 -> 01: 21: 52.640
No entanto, onde a função cough está implementada agora?

1773
01: 21: 52.640 -> 01: 21: 54.880
Bem aqui na linha 11 em diante.

1774
01: 21: 54,880 -> 01: 21: 56.600
C não é tão inteligente.

1775
01: 21: 56.600 -> 01: 21: 59.510
Não vai presumir e procurar mais adiante em seu arquivo para ver,

1776
01: 21: 59.510 -> 01: 22: 02.150
talvez eles coloquem a função tosse abaixo.

1777
01: 22: 02,150 -> 01: 22: 04.070
Só vai fazer o que você mandar.

1778
01: 22: 04,070 -> 01: 22: 05.503
Portanto, há uma solução para isso.

1779
01: 22: 05,503 -> 01: 22: 07.670
Você pode fazer o que eu fiz inicialmente, que é colocar

1780
01: 22: 07,670 -> 01: 22: 09.268
todas as suas funções personalizadas no topo.

1781
01: 22: 09,268 -> 01: 22: 11.810
Mas isso é uma espécie de ciclo vicioso, porque você não pode para sempre

1782
01: 22: 11.810 -> 01: 22: 13.107
coloque as novas funções no topo.

1783
01: 22: 13,107 -> 01: 22: 15.690
Eventualmente, você encontrará algum tipo de restrição.

1784
01: 22: 15.690 -> 01: 22: 19.070
E meu Deus, você quer que a função principal, por convenção, esteja no topo.

1785
01: 22: 19,070 -> 01: 22: 20.880
Portanto, há outra solução aqui.

1786
01: 22: 20,880 -> 01: 22: 23.900
E este é o único momento em que copiar/colar é atraente.

1787
01: 22: 23,900 -> 01: 22: 29.210
Você literalmente copia a primeira linha do código de sua função na linha 11 lá.

1788
01: 22: 29,210 -> 01: 22: 33.660
E você vai em frente e cola no topo do seu arquivo com um ponto e vírgula.

1789
01: 22: 33.660 -> 01: 22: 38.113
Portanto, esta é uma espécie de enganar C para, oh, você já viu cough antes.

1790
01: 22: 38,113 -> 01: 22: 40.530
Você não viu tudo isso, mas você já viu o suficiente -

1791
01: 22: 40.530 -> 01: 22: 41.720
você viu seu nome -

1792
01: 22: 41,720 -> 01: 22: 45.870
para agora tolere o aparecimento em minha função "main".

1793
01: 22: 45,870 -> 01: 22: 49.130
Então, deixe-me recompilar este código.

1794
01: 22: 49,130 ​​-> 01: 22: 51.770
Vou seguir em frente e fazer cough1 entrar.

1795
01: 22: 51,770 -> 01: 22: 53.510
OK, agora está compilado.

1796
01: 22: 53.510 -> 01: 22: 59.370
./cough1 e viola, estamos de volta aos negócios lá.

1797
01: 22: 59,370 -> 01: 23: 00.740
Mas deixe-me fazer um refinamento.

1798
01: 23: 00,740 -> 01: 23: 05.810
E vou pular para o que chamei nos exemplos online cough3.c.

1799
01: 23: 05,810 -> 01: 23: 08.600
Acontece que suas próprias funções personalizadas podem receber entrada.

1800
01: 23: 08.600 -> 01: 23: 11.610
Esta palavra "void" significa que não é necessária nenhuma entrada.

1801
01: 23: 11,610 -> 01: 23: 15.938
E esta palavra "void" significa que não retorna nenhum valor, como get_int e get_string manda

1802
01: 23: 15.938 -> 01: 23: 16.730
algo de volta para você.

1803
01: 23: 16,730 -> 01: 23: 18.647
Isso não é aplicável agora, mas vamos voltar

1804
01: 23: 18.647 -> 01: 23: 20.450
para isso em uma ou duas semanas.

1805
01: 23: 20.450 -> 01: 23: 24.770
Suponha que você queira tornar a função cough mais versátil

1806
01: 23: 24.770 -> 01: 23: 28.190
de forma que ele vai tossir várias vezes para você.

1807
01: 23: 28,190 -> 01: 23: 29.660
Você sabe o que pode fazer, é isso.

1808
01: 23: 29.660 -> 01: 23: 34.670
Você pode alterar a entrada para a função de tosse para algum valor como n,

1809
01: 23: 34,670 -> 01: 23: 38.840
e você pode fazer algo assim - para int eu obtenho 0.

1810
01: 23: 38,840 -> 01: 23: 43.730
i é menor que n, portanto, não é mais "hardcoded/fixo no código". i mais mais.

1811
01: 23: 43.730 -> 01: 23: 48.650
E então, dentro das chaves, você pode imprimir esta linha de tosse.

1812
01: 23: 48.650 -> 01: 23: 52.520
Então agora, observe, a tosse foi parametrizada.

1813
01: 23: 52.520 -> 01: 23: 55.430
Agora, leva a entrada de um inteiro chamado n, e

1814
01: 23: 55.430 -> 01: 23: 58.220
usa essa entrada, n, exatamente como você poderia ter feito

1815
01: 23: 58,220 -> 01: 24: 00.740
no Scratch, para fazer algo n vezes -

1816
01: 24: 00,740 -> 01: 24: 04.010
não uma, não três vezes, mas um número variável de vezes.

1817
01: 24: 04,010 -> 01: 24: 06.360
Tenho que mudar minha primeira linha aqui.

1818
01: 24: 06,360 -> 01: 24: 07.520
Isso é chamado de protótipo.

1819
01: 24: 07.520 -> 01: 24: 09.860
Está função de linha única é o que chamamos de protótipo,

1820
01: 24: 09,860 -> 01: 24: 12.140
e é só copiar/colar da sua função real.

1821
01: 24: 12,140 -> 01: 24: 13.700
Mas agora observe o que posso fazer.

1822
01: 24: 13,700 -> 01: 24: 16.550
Minha função principal, novamente, é a essência do meu programa.

1823
01: 24: 16.550 -> 01: 24: 19.190
É um pouco complicado agora.

1824
01: 24: 19,190 -> 01: 24: 23.150
Não seria melhor se eu pudesse dizer "cough" três vezes?

1825
01: 24: 23,150 -> 01: 24: 28.040
E, de fato, agora não preciso saber ou me importar como a cough é implementada.

1826
01: 24: 28.040 -> 01: 24: 30.950
É um programa bem desenhado, sem dúvida.

1827
01: 24: 30.950 -> 01: 24: 32.300
É uma linha de código.

1828
01: 24: 32,300 -> 01: 24: 33.137
É descritivo.

1829
01: 24: 33,137 -> 01: 24: 33.720
diga tosse.

1830
01: 24: 33,720 -> 01: 24: 35.990
É preciso uma entrada, o que significa que custará três vezes.

1831
01: 24: 35,990 -> 01: 24: 38.823
E o que está abaixo no arquivo, embora eu certamente pudesse trazê-lo

1832
01: 24: 38,823 -> 01: 24: 40.770
de volta para cima, é exatamente o que um cientista da computação

1833
01: 24: 40.770 -> 01: 24: 43.250
chamaria um detalhe de implementação.

1834
01: 24: 43,250 -> 01: 24: 45.620
Alguém se preocupa em como você implementa a cough,

1835
01: 24: 45,620 -> 01: 24: 48.200
mas você não precisa se preocupar em como implementar a tosse.

1836
01: 24: 48,200 -> 01: 24: 50.530
Você não precisa saber como obtemos inteiros.

1837
01: 24: 50.530 -> 01: 24: 52.930
Você não precisa se preocupar com a forma de imprimir.

1838
01: 24: 52.930 -> 01: 24: 56.140
Você só se importa se outra pessoa implementou essa função

1839
01: 24: 56,140 -> 01: 25: 00.280
para que você possa se apoiar nos  ombros deles e construir programas mais interessantes que

1840
01: 25: 00,280 -> 01: 25: 03.310
são realmente interessantes para você.

1841
01: 25: 03,310 -> 01: 25: 06.235
Deixe-me ir em frente e abrir um exemplo que se baseia nessa mesma ideia.

1842
01: 25: 06,235 -> 01: 25: 08.740


1843
01: 25: 08.740 -> 01: 25: 14.030
Em, vamos ver, positive.c, temos este exemplo aqui,

1844
01: 25: 14.030 -> 01: 25: 16.040
o que torna isso ainda mais claro.

1845
01: 25: 16.040 -> 01: 25: 20.100
Então, aqui está um programa que usa nossas duas bibliotecas, CS50 em I/O padrão.

1846
01: 25: 20,100 -> 01: 25: 22.330
Acontece que a biblioteca CS50 não

1847
01: 25: 22,330 -> 01: 25: 24.730
vem com uma função chamada get_positive_int.

1848
01: 25: 24,730 -> 01: 25: 25.772
Ele vem com get_int.

1849
01: 25: 25.772 -> 01: 25: 27.730
E você pode imaginar programas onde você realmente

1850
01: 25: 27,730 -> 01: 25: 31.450
quer um número inteiro positivo do humano, porque os números negativos para um jogo

1851
01: 25: 31.450 -> 01: 25: 33.820
ou para algum programa simplesmente não faria sentido.

1852
01: 25: 33.820 -> 01: 25: 35.380
Então, como podemos implementar isso?

1853
01: 25: 35,380 -> 01: 25: 38.350
Bem, seria bom criá-lo para que você pudesse simplesmente

1854
01: 25: 38,350 -> 01: 25: 40.930
escrever um programa de duas linhas como este, onde você chama

1855
01: 25: 40.930 -> 01: 25: 42.820
uma função chamada get_positive_int.

1856
01: 25: 42,820 -> 01: 25: 46.720
E se eu rolar para baixo, noto que há um novo recurso

1857
01: 25: 46,720 -> 01: 25: 49.810
aqui que ainda não vimos, mas é um exemplo interessante

1858
01: 25: 49,810 -> 01: 25: 52.600
de outro recurso de C. O que destaquei aqui

1859
01: 25: 52,600 -> 01: 25: 56.350
entre as linhas 15 e 24 é essa lógica.

1860
01: 25: 56,350 -> 01: 25: 58.510
Aqui está uma função chamada get_positive_int.

1861
01: 25: 58.510 -> 01: 26: 01.690
Não requer entradas, então não preciso passar nada entre parênteses.

1862
01: 26: 01,690 -> 01: 26: 03.850
Eu só quero obter qualquer número positivo inteiro.

1863
01: 26: 03,850 -> 01: 26: 06.670
Mas eu quero que essa função me devolva algo,

1864
01: 26: 06,670 -> 01: 26: 09.850
assim como get_int me devolveu um valor que eu poderia colocar em uma variável,

1865
01: 26: 09,850 -> 01: 26: 11.170
assim como get_string faz.

1866
01: 26: 11,170 -> 01: 26: 13.030
Portanto, isso não é vazio.

1867
01: 26: 13,030 -> 01: 26: 13.990
Isso é int.

1868
01: 26: 13,990 -> 01: 26: 17.290
Portanto, esta palavra à esquerda de uma função é o tipo de sua saída.

1869
01: 26: 17,290 -> 01: 26: 20.920
Esta palavra entre parênteses é o tipo de entrada, se houver.

1870
01: 26: 20,920 -> 01: 26: 24.640
E se não houver nada, basta dizer "void" em um ou nos dois lugares.

1871
01: 26: 24.640 -> 01: 26: 26.190
Agora, aqui está uma curiosidade -

1872
01: 26: 26,190 -> 01: 26: 30.280
na linha 17, não vimos isso antes, mas é apenas uma dica para o computador

1873
01: 26: 30.280 -> 01: 26: 32.425
dizendo dê-me uma variável chamada n.

1874
01: 26: 32.425 -> 01: 26: 34.300
Não tenho certeza do que vou colocar nele ainda.

1875
01: 26: 34,300 -> 01: 26: 36.580
Então você literalmente apenas diz int n ponto-e-vírgula.

1876
01: 26: 36,580 -> 01: 26: 38.405
Você não precisa atribuir nada ainda.

1877
01: 26: 38.405 -> 01: 26: 40.030
Ele tem o que chamaremos de valor de lixo.

1878
01: 26: 40,030 -> 01: 26: 42.322
Você não tem ideia do que está nele, mas isso não importa.

1879
01: 26: 42,322 -> 01: 26: 43.730
Você colocará algo nele mais tarde.

1880
01: 26: 43.730 -> 01: 26: 45.820
Então há este loop, que não vimos ainda,

1881
01: 26: 45,820 -> 01: 26: 47.800
mas em C, é chamado de loop "do-while/faça-enquanto".

1882
01: 26: 47,800 -> 01: 26: 52.120
Isso literalmente diz para fazer o que vem a seguir enquanto esta expressão booleana for verdadeira.

1883
01: 26: 52,120 -> 01: 26: 53.320
Então, o que eu quero fazer?

1884
01: 26: 53,320 -> 01: 26: 55.330
Quero obter um int do usuário, solicitando

1885
01: 26: 55,330 -> 01: 26: 58.540
ao humano por um número inteiro positivo e armazene-o em n.

1886
01: 26: 58.540 -> 01: 27: 03.010
No entanto, quero continuar fazendo isso enquanto n for menor que 1.

1887
01: 27: 03,010 -> 01: 27: 06.370
Porque se o humano digitar 0 ou -1 ou -50

1888
01: 27: 06,370 -> 01: 27: 12.040
ou qualquer coisa que não seja positiva, eu quero solicitar novamente e novamente.

1889
01: 27: 12.040 -> 01: 27: 14.530
Então, um loop do-while é legal, porque

1890
01: 27: 14.530 -> 01: 27: 17.090
fará essa primeira coisa pelo menos uma vez.

1891
01: 27: 17,090 -> 01: 27: 20.200
Em seguida, ele verificará a condição e, potencialmente, fará novamente

1892
01: 27: 20,200 -> 01: 27: 22.450
se o humano não cooperou.

1893
01: 27: 22.450 -> 01: 27: 25.900
Um loop while, se você pensar no anterior, na verdade verificou a condição primeiro.

1894
01: 27: 25,900 -> 01: 27: 29.590
Ele fazia algo Enquanto alguma expressão booleana fosse verdadeira.

1895
01: 27: 29.590 -> 01: 27: 34.210
Este aqui dá a você uma dessas iterações, uma passagem gratuita,

1896
01: 27: 34,210 -> 01: 27: 35.767
e então verifica a condição.

1897
01: 27: 35,767 -> 01: 27: 37.600
Portanto, é apenas uma forma diferente de programação,

1898
01: 27: 37.600 -> 01: 27: 40.090
mas poderíamos fazer tudo o que fizemos até agora usando

1899
01: 27: 40.090 -> 01: 27: 46.550
while loops ou mesmo for loops também.

1900
01: 27: 46.550 -> 01: 27: 50.080
Tudo bem, vamos prosseguir agora e tornar isso um pouco mais amigável.

1901
01: 27: 50,080 -> 01: 27: 54.790
Deixe-me prosseguir e pegar alguns exemplos aqui de algumas telas que

1902
01: 27: 54,790 -> 01: 27: 56.060
pode parecer familiar.

1903
01: 27: 56.060 -> 01: 27: 58.488
Então, se eu for em frente e abrir, por exemplo,

1904
01: 27: 58,488 -> 01: 28: 00.280
este slide aqui, você deve se lembrar deste jogo

1905
01: 28: 00,280 -> 01: 28: 04.000
do passado, Super Mario Brothers 1, da Nintendo muito original.

1906
01: 28: 04.000 -> 01: 28: 07.510
E há algumas telas nesse jogo que se parecem um pouco com isso.

1907
01: 28: 07.510 -> 01: 28: 09.100
Por exemplo, esses são pequenos tijolos no ar

1908
01: 28: 09,100 -> 01: 28: 11.200
que se Mario ou Luigi baterem com a cabeça,

1909
01: 28: 11,200 -> 01: 28: 13.450
tipo uma moeda ou alga outra coisa salta deles.

1910
01: 28: 13,450 -> 01: 28: 16.810
Mas esta é uma boa ideia, porque se presta a realmente fazer

1911
01: 28: 16,810 -> 01: 28: 18.535
algo um pouco programaticamente.

1912
01: 28: 18.535 -> 01: 28: 21.160
Por exemplo, como poderia escrever um programa que 

1913
01: 28: 21,160 -> 01: 28: 23.800
simplesmente imprime quatro pontos de interrogação?

1914
01: 28: 23,800 -> 01: 28: 26.920
Bem, deixe-me ir em frente e abrir, por exemplo, no código,

1915
01: 28: 26,920 -> 01: 28: 30.100
um exemplo chamado mario0.c.

1916
01: 28: 30,100 -> 01: 28: 33.087
E eu afirmo que esta pode ser uma forma de implementar este programa.

1917
01: 28: 33.087 -> 01: 28: 35.170
É muito simples e realmente não faz jus

1918
01: 28: 35,170 -> 01: 28: 39.400
aos outros gráficos na tela, mas implementa essa ideia.

1919
01: 28: 39,400 -> 01: 28: 41.800
E, de fato, em algum lugar do código de Mario,

1920
01: 28: 41,800 -> 01: 28: 43.600
provavelmente havia alguma linha de código que

1921
01: 28: 43,600 -> 01: 28: 47.950
disse ao jogo do console para imprimir ponto de interrogação, ponto de interrogação, 

1922
01: 28: 47,950 -> 01: 28: 48.970
ponto de interrogação.

1923
01: 28: 48,970 -> 01: 28: 51.760
Em C, certamente poderíamos fazer isso com quatro pontos de interrogação.

1924
01: 28: 51.760 -> 01: 28: 55.048
Ou de que outra forma poderíamos fazer algo várias vezes?

1925
01: 28: 55.048 -> 01: 28: 55.840
PÚBLICO: Com loop "for".

1926
01: 28: 55,840 -> 01: 28: 57.465
DAVID MALAN: Algo como um loop "for".

1927
01: 28: 57.465 -> 01: 29: 00.310
Então, deixe-me ir em frente e pular algumas iterações

1928
01: 29: 00,310 -> 01: 29: 05.200
para um exemplo, que vou chamar mario2.c, que faz tudo isso.

1929
01: 29: 05,200 -> 01: 29: 08.500
Então, isso é realmente muito complicado, mas observe o que está acontecendo.

1930
01: 29: 08,500 -> 01: 29: 12.010
no "main", estou dizendo, ei, me dê um número inteiro chamado n.

1931
01: 29: 12.010 -> 01: 29: 14.630
Faça o seguinte enquanto n for menor que 1.

1932
01: 29: 14.630 -> 01: 29: 18.820
Essa é apenas uma forma de perguntar qual é a largura dos blocos

1933
01: 29: 18.820 -> 01: 29: 20.140
que você deseja imprimir?

1934
01: 29: 20,140 -> 01: 29: 24.190
Então, assim que tiver essa resposta, posso prosseguir e, como antes,

1935
01: 29: 24,190 -> 01: 29: 28.940
imprimir esse número de pontos de interrogação n vezes, um de cada vez.

1936
01: 29: 28.940 -> 01: 29: 32.080
E no final, vou imprimir apenas uma nova linha.

1937
01: 29: 32.080 -> 01: 29: 35.470
Resumindo, se você deseja criar um programa, embora em texto,

1938
01: 29: 35.470 -> 01: 29: 37.760
que faz algo assim, e eu "make mario2" -

1939
01:29:37,760 --> 01:29:38,410
opa.

1940
01: 29: 38.410 -> 01: 29: 43.510
E eu "make mario2", Enter e digito ./mario2,

1941
01: 29: 43.510 -> 01: 29: 46.510
Posso fazer a largura com quatro e obter quatro pontos de interrogação.

1942
01: 29: 46.510 -> 01: 29: 49.730
Ou posso fazer 50 e ver muito mais na tela, tudo

1943
01: 29: 49,730 -> 01: 29: 51.480
usando apenas esses blocos de construção básicos.

1944
01: 29: 51.480 -> 01: 29: 54.660
Mas observe, por causa desse loop do-while, se eu não cooperar

1945
01: 29: 54.660 -> 01: 29: 58.110
e faço algo como 0 ou -1 ou -50,

1946
01: 29: 58,110 -> 01: 30: 02.160
Eu só recebo a solicitação repetidas vezes, porque n é menor que 1.

1947
01: 30: 02,160 -> 01: 30: 05.130
Esse é o tipo de lógica que você pode impor ali.

1948
01: 30: 05,130 -> 01: 30: 10.018
Mas vamos prosseguir e pular, digamos, para algo assim em Mario,

1949
01: 30: 10.018 -> 01: 30: 12.060
onde você tem muitos tijolos no subsolo.

1950
01: 30: 12,060 -> 01: 30: 16.000
E desta vez, não é apenas uma coluna ou uma fileira de tijolos.

1951
01: 30: 16.000 -> 01: 30: 17.755
Desta vez, são duas dimensões.

1952
01: 30: 17.755 -> 01: 30: 20.130
Bem, isso é interessante, porque agora como você

1953
01: 30: 20,130 -> 01: 30: 23.200
faria a impressão de bloco, bloco, bloco, bloco, bloco, bloco, bloco, bloco,

1954
01: 30: 23,200 -> 01: 30: 25.158
bloco, bloco, bloco, bloco e realmente fazer

1955
01: 30: 25,158 -> 01: 30: 26.700
em vez disso, uma estrutura bidimensional?

1956
01: 30: 26.700 -> 01: 30: 30.090
Bem, nada nos impede em C, como em Scratch,

1957
01: 30: 30.090 -> 01: 30: 33.540
de fazer algo, por exemplo, com loops.

1958
01: 30: 33.540 -> 01: 30: 35.650
Deixe-me mostrar este exemplo aqui.

1959
01: 30: 35.650 -> 01: 30: 38.070
Então, suponha que com essas primeiras linhas de código,

1960
01: 30: 38.070 -> 01: 30: 41.938
Eu perguntei ao usuário o tamanho deste bloco.

1961
01: 30: 41.938 -> 01: 30: 44.730
Então, eu quero criar algo que seja como este - bloco,

1962
01: 30: 44.730 -> 01: 30: 47.710
bloco, bloco, bloco, bloco, bloco, bloco, bloco, bloco e assim por diante.

1963
01: 30: 47.710 -> 01: 30: 51.270
Bem, posso ir em frente e solicitar um int repetidas vezes

1964
01: 30: 51.270 -> 01: 30: 53.500
e de novo até saber esse tamanho.

1965
01: 30: 53.500 -> 01: 30: 54.930
E então observe isso.

1966
01: 30: 54.930 -> 01: 30: 58.770
Isso está começando a crescer novamente, mas considere a lógica.

1967
01: 30: 58,770 -> 01: 31: 02.520
Isso agora é "for" int eu obtenho 0, i menor que n, i mais mais.

1968
01: 31: 02.520 -> 01: 31: 04.500
Então, faça o seguinte n vezes, certo?

1969
01: 31: 04,500 -> 01: 31: 08.220
Esta é uma maneira muito enigmática de dizer C, faça o que vem a seguir n vezes.

1970
01: 31: 08,220 -> 01: 31: 10.170
E a linha 16?

1971
01: 31: 10,170 -> 01: 31: 13.740
O que a linha 16 está dizendo?

1972
01: 31: 13.740 -> 01: 31: 16.710
Mesmo que esteja usando uma variável diferente.

1973
01: 31: 16,710 -> 01: 31: 18.869
Estou usando j só porque é diferente de i.

1974
01: 31: 18,869 -> 01: 31: 19.744
PÚBLICO: Mesma coisa.

1975
01: 31: 19,744 -> 01: 31: 20.786
Faça o seguinte n vezes.

1976
01: 31: 20.786 -> 01: 31: 24.180
DAVID MALAN: Sim, diz exatamente a mesma coisa - faça o quem vem a seguir n vezes.

1977
01: 31: 24,180 -> 01: 31: 26.880
No entanto, está contando usando j em vez de i,

1978
01: 31: 26,880 -> 01: 31: 30.100
só para que minha matemática não se misture incorretamente.

1979
01: 31: 30,100 -> 01: 31: 32.580
Então, se você pensar sobre o que é esse bloco de Mario,

1980
01: 31: 32.580 -> 01: 31: 35.318
isso é como imprimir linhas e colunas.

1981
01: 31: 35,318 -> 01: 31: 37.860
Como uma máquina de escrever da velha escola que precisa mudar 

1982
01: 31: 37,860 -> 01: 31: 41.250
da esquerda para a direita e de cima para baixo, de cima para baixo, da esquerda para a direita,

1983
01: 31: 41,250 -> 01: 31: 44.610
e assim por diante, apenas para imprimir blocos diferentes em linhas diferentes.

1984
01: 31: 44.610 -> 01: 31: 47.010
Então, o efeito aqui - se eu abrir mario8 -

1985
01: 31: 47,010 -> 01: 31: 48.730
deverá ser isso, faça - ops.

1986
01: 31: 48,730 -> 01: 31: 53.193
Deixe-me ir em frente e "make mario8", ./mario8.

1987
01: 31: 53,193 -> 01: 31: 54.360
Qual será o tamanho?

1988
01: 31: 54,360 -> 01: 31: 55.680
Bem, talvez três.

1989
01: 31: 55,680 -> 01: 32: 00.030
E agora imprimi três linhas e três colunas.

1990
01: 32: 00,030 -> 01: 32: 03.930
Estes representam essencialmente cada uma das minhas linhas.

1991
01: 32: 03,930 -> 01: 32: 05.830
Estou contando de i até -

1992
01:32:05,830 --> 01:32:07,450
oh.

1993
01: 32: 07,450 -> 01: 32: 10.980
Estou ensinando para mim agora, OK.

1994
01: 32: 10.980 -> 01: 32: 11.760
Vamos retroceder.

1995
01: 32: 11,760 -> 01: 32: 13.950
Aqui está o que me maravilhando um momento atrás.

1996
01: 32: 13,950 -> 01: 32: 16.770
Quando eu estava executando qual é o tamanho deste programa,

1997
01: 32: 16,770 -> 01: 32: 19.140
Eu vi uma grade de blocos de três por três.

1998
01: 32: 19,140 -> 01: 32: 21.450
E se eu executá-lo novamente, talvez com 10, eu agora

1999
01: 32: 21,450 -> 01: 32: 24.003
veja uma grade ainda maior de blocos de 10 por 10.

2000
01: 32: 24,003 -> 01: 32: 26.670
Este é um pouco mais alto do que largo, porque os caracteres "hash" são

2001
01: 32: 26,670 -> 01: 32: 27.960
mais altos do que largos.

2002
01: 32: 27,960 -> 01: 32: 30.390
E você verá que agora este programa é dinâmico.

2003
01: 32: 30,390 -> 01: 32: 31.950
Então, como isso está funcionando?

2004
01: 32: 31,950 -> 01: 32: 33.950
Bem, se eu realmente olhar para o código aqui,

2005
01: 32: 33,950 -> 01: 32: 36.750
observe que, efetivamente, o que a linha 14 está fazendo

2006
01: 32: 36,750 -> 01: 32: 39.030
e está fazendo uma linha de cada vez.

2007
01: 32: 39,030 -> 01: 32: 43.170
Ele está me dando n linhas, e cada uma dessas linhas estou pensando que é i para 0,

2008
01: 32: 43,170 -> 01: 32: 46.020
i1, i2 e assim por diante.

2009
01: 32: 46,020 -> 01: 32: 50.650
Enquanto isso, dentro de cada linha, estou usando este loop interno,

2010
01: 32: 50,650 -> 01: 32: 54.900
que é deliberadamente aninhado dentro, para fazer cada um dos caracteres

2011
01: 32: 54,900 -> 01: 32: 55.990
da esquerda para a direita.

2012
01: 32: 55,990 -> 01: 32: 58.680
Portanto, em cada linha, quero hash, hash, hash, hash.

2013
01: 32: 58,680 -> 01: 33: 00.750
Dentro de cada linha - hash, hash, hash, hash.

2014
01: 33: 00,750 -> 01: 33: 03.670
Portanto, é como implementar esse processo bidimensional.

2015
01: 33: 03,670 -> 01: 33: 06.900
Mas, novamente, usando as mesmas idéias fundamentais.

2016
01: 33: 06,900 -> 01: 33: 11.370
Apenas um loop "for" que com muito cuidado conta do zero para cima

2017
01: 33: 11,370 -> 01: 33: 16.032
até algum valor para fazer algo novamente e novamente.

2018
01: 33: 16,032 -> 01: 33: 18.240
E se você realmente pensar sobre qualquer um dos jogos de hoje

2019
01: 33: 18,240 -> 01: 33: 21.150
ou gráficos ou programas, sempre que você ver redundância,

2020
01: 33: 21,150 -> 01: 33: 24.600
seja em duas dimensões - talvez seja verticalmente em uma

2021
01: 33: 24.600 -> 01: 33: 26.712
dimensão ou horizontalmente em outra.

2022
01: 33: 26,712 -> 01: 33: 29.670
A probabilidade, de que exista  alguma repetição que estão acontecendo de novo e de novo

2023
01: 33: 29.670 -> 01: 33: 33.510
e novamente, isso pode ser reduzido em C ou em Scratch ou alguma outra linguagem

2024
01: 33: 33,510 -> 01: 33: 36.780
em última análise, em apenas linhas de código.

2025
01: 33: 36,780 -> 01: 33: 39.270
E, de fato, esta é uma alusão a uma das primeiras coisas

2026
01: 33: 39,270 -> 01: 33: 41.760
que você fará para o primeiro conjunto de problemas, o conjunto de problemas 1.

2027
01: 33: 41,760 -> 01: 33: 45.180
Você usará o CS50 Lab, que é idêntico ao CS50 Sandbox, que

2028
01: 33: 45,180 -> 01: 33: 48.090
Tenho usado até agora, mas que adiciona instruções,

2029
01: 33: 48.090 -> 01: 33: 52.170
os problemas reais a serem resolvidos, junto de sua sandbox.

2030
01: 33: 52,170 -> 01: 33: 55.470
Mas antes de provocá-lo com isso, vamos apenas

2031
01: 33: 55.470 -> 01: 34: 00.720
considerar agora que há um monte de pequenas suposições que tenho feito.

2032
01: 34: 00,720 -> 01: 34: 03.060
Como até agora, todos os erros no meu código

2033
01: 34: 03,060 -> 01: 34: 06.990
foram meus mesmos - alguns intencionais, mas várias não intencionais também, hoje.

2034
01: 34: 06,990 -> 01: 34: 10.560
Mas acontece que os próprios computadores têm limitações.

2035
01: 34: 10,560 -> 01: 34: 12.810
Geralmente, dentro do seu Mac ou PC há coisas assim.

2036
01: 34: 12,810 -> 01: 34: 14.372
Isso é chamado de memória ou RAM.

2037
01: 34: 14,372 -> 01: 34: 16.080
E você normalmente não vê isso, a menos que você

2038
01: 34: 16,080 -> 01: 34: 18.900
remova a tampa do celular ou laptop ou desktop.

2039
01: 34: 18,900 -> 01: 34: 22.680
RAM é onde todos os seus programas são armazenados durante a execução.

2040
01: 34: 22,680 -> 01: 34: 26.190
RAM é onde todos os seus programas - onde todos os seus arquivos estão

2041
01: 34: 26,190 -> 01: 34: 27.540
armazenados enquanto estão abertos.

2042
01: 34: 27.540 -> 01: 34: 30.930
É o que seu computador usa para fazer várias coisas ao mesmo tempo

2043
01: 34: 30.930 -> 01: 34: 32.440
e manter as coisas na memória.

2044
01: 34: 32.440 -> 01: 34: 35.430
No entanto, o hardware é por natureza, finito.

2045
01: 34: 35.430 -> 01: 34: 38.610
Você tem talvez um gigabyte, um bilhão de bytes de memória.

2046
01: 34: 38,610 -> 01: 34: 41.400
Talvez você tenha quatro gigabytes ou quatro bilhões de bytes de memória.

2047
01: 34: 41,400 -> 01: 34: 44.280
Você fixou quantidade de memória em seu computador,

2048
01: 34: 44,280 -> 01: 34: 48.040
o que significa que há alguma limitação fundamental no que seu computador pode

2049
01: 34: 48,040 -> 01: 34: 48.540
Fazer.

2050
01: 34: 48,540 -> 01: 34: 52.350
Não pode necessariamente contar até o infinito, porque como poderia contar até o infinito

2051
01: 34: 52,350 -> 01: 34: 57.020
se ele não pode armazenar todos os números possíveis usando uma quantidade finita de espaço?

2052
01: 34: 57,020 -> 01: 34: 59.370
Na verdade, existem alguns limites de computação

2053
01: 34: 59,370 -> 01: 35: 01.230
que apenas começamos a ver.

2054
01: 35: 01,230 -> 01: 35: 02.890
Na verdade, deixe-me ir em frente e fazer isso.

2055
01: 35: 02,890 -> 01: 35: 06.445
Deixe-me escrever um programa que irei prosseguir e chamar float.c.

2056
01: 35: 06,445 -> 01: 35: 09.570
E este será apenas um programa que terá alguns pontos flutuantes

2057
01: 35: 09.570 -> 01: 35: 11.980
valores do usuário.

2058
01: 35: 11.980 -> 01: 35: 15.000
Deixe-me ir em frente e incluir a biblioteca CS50.

2059
01: 35: 15.000 -> 01: 35: 19.420
Vamos incluir stdio.h, int main void, como antes.

2060
01: 35: 19,420 -> 01: 35: 22.488
E tudo o que quero fazer aqui com este programa é obter algumas casas decimais.

2061
01: 35: 22.488 -> 01: 35: 23.280
Então me dê um float.

2062
01: 35: 23,280 -> 01: 35: 24.420
Vamos chamá-lo de x.

2063
01: 35: 24,420 -> 01: 35: 26.808
Get_float, e pedirei ao humano x.

2064
01: 35: 26,808 -> 01: 35: 28.350
Então deixe-me ir em frente e pegar outro.

2065
01:35:28,350 --> 01:35:29,370
Vou chamá-lo de y.

2066
01:35:29,370 --> 01:35:31,380
Get_float, abre e fecha aspas y.

2067
01: 35: 31,380 -> 01: 35: 34.110
E lembre-se de que um float é apenas um número que

2068
01: 35: 34,110 -> 01: 35: 36.475
tem uma vírgula decimal, um assim chamado número real.

2069
01: 35: 36,475 -> 01: 35: 38.100
Agora vamos fazer uma divisão simples.

2070
01: 35: 38,100 -> 01: 35: 40.990
Eu afirmo que os computadores podem fazer adição, subtração e assim por diante.

2071
01: 35: 40,990 -> 01: 35: 41.920
Então vamos fazer isso.

2072
01: 35: 41,920 -> 01: 35: 46.410
Vamos apenas dizer que x dividido por y vai ser igual ao seguinte -

2073
01: 35: 46.410 -> 01: 35: 52.150
%f barra invertida n receberá x dividido por y ponto e vírgula.

2074
01: 35: 52,150 -> 01: 35: 55.110
Essa é uma calculadora muito simplista

2075
01: 35: 55,110 -> 01: 35: 57.510
que implementei, que suporta apenas divisão.
2076
01: 35: 57.510 -> 01: 36: 04.170
Deixe-me prosseguir e compilar isso digitando make floats.

2077
01: 36: 04,170 -> 01: 36: 05.820
E você verá que ele foi compilado.

2078
01: 36: 05,820 -> 01: 36: 07.980
Então ./float

2079
01: 36: 07,980 -> 01: 36: 09.570
x vai ser, digamos, 1.

2080
01: 36: 09.570 -> 01: 36: 10.960
y vai ser 10.

2081
01: 36: 10.960 -> 01: 36: 12.120
OK, viola.

2082
01: 36: 12,120 -> 01: 36: 15.501
x dividido por y é igual a 0,10000.

2083
01: 36: 15.501 -> 01: 36: 16.440
Isso é muito bom.

2084
01: 36: 16.440 -> 01: 36: 19.570
E lembre-se, se você não quiser ver todos esses zeros, você pode apenas dizer,

2085
01: 36: 19.570 -> 01: 36: 23.160
mostre-me um ponto decimal adicionando 0,1.

2086
01: 36: 23,160 -> 01: 36: 25.950
Recompile e execute-o novamente.

2087
01: 36: 25,950 -> 01: 36: 27.790
E agora faça 1, 10.

2088
01: 36: 27,790 -> 01: 36: 29.820
OK, agora é 1/10.

2089
01: 36: 29.820 -> 01: 36: 30.930
Ou é?

2090
01: 36: 30.930 -> 01: 36: 33.660
Agora que tenho a capacidade de olhar além da vírgula decimal,

2091
01: 36: 33.660 -> 01: 36: 36.900
por que não procuro alguns lugares ou um lugar.

2092
01: 36: 36.900 -> 01: 36: 40.440
Deixe-me ir em frente e ver talvez 10 casas após a vírgula.

2093
01: 36: 40.440 -> 01: 36: 48.210
Deixe-me executar novamente como make floats, ./floats, 1, 10.

2094
01: 36: 48,210 -> 01: 36: 49.920
Interessante.

2095
01: 36: 49,920 -> 01: 36: 51.627
Tudo bem, isso parece um pouco estranho.

2096
01: 36: 51,627 -> 01: 36: 52.710
Talvez tenha sido apenas um acaso.

2097
01: 36: 52,710 -> 01: 36: 54.043
Vamos olhar um pouco mais adiante.

2098
01: 36: 54,043 -> 01: 36: 56.080
Vamos ver 50 casas decimais.

2099
01: 36: 56,080 -> 01: 36: 57.887
Vamos recompilar isso.

2100
01: 36: 57.887 -> 01: 36: 59.970
E acontece que existem alguns atalhos de teclado.

2101
01: 36: 59,970 -> 01: 37: 02.100
Agora estou pressionando para cima e para baixo no meu teclado, que

2102
01: 37: 02,100 -> 01: 37: 04.302
irá percorrer todo o seu histórico de comandos

2103
01: 37: 04,302 -> 01: 37: 06.010
então você não precisa se lembrar de tudo.

2104
01: 37: 06,010 -> 01: 37: 08.130
Então, para economizar tempo, agora estou indo para cima e para baixo.

2105
01: 37: 08,130 -> 01: 37: 11.850
Deixe-me ir em frente e fazer ./floats agora, 1, 10.

2106
01: 37: 11.850 -> 01: 37: 14.820
Oh meu Deus, divisão é uma mentira.

2107
01: 37: 14.820 -> 01: 37: 18.660
Então, quando seus professores do ensino fundamental ou algo assim lhe ensinaram que 1 dividido por 10

2108
01: 37: 18.660 -> 01: 37: 24.690
é 1/10 ou 0,10000 infinitamente, aparentemente isso não é verdade.

2109
01: 37: 24,690 -> 01: 37: 28.810
De acordo com este computador, 1/10 é realmente esse valor.

2110
01: 37: 28.810 -> 01: 37: 31.500
Então, como podemos reconciliar isso?

2111
01: 37: 31,500 -> 01: 37: 36.180
Quem está certo, matemática do ensino fundamental ou computadores?

2112
01: 37: 36,180 -> 01: 37: 39.150
E o que pode explicar?

2113
01: 37: 39,150 -> 01: 37: 40.860
Alguma ideia?

2114
01: 37: 40,860 -> 01: 37: 41.850
Sim?

2115
01: 37: 41.850 -> 01: 37: 45.550
PÚBLICO: Ele armazena apenas até metade disso,

2116
01: 37: 45.550 -> 01: 37: 47.300
você não sabe o que está acontecendo lá.

2117
01: 37: 47,300 -> 01: 37: 48.800
DAVID MALAN: Sim, é uma boa maneira de colocar isso.

2118
01: 37: 48.800 -> 01: 37: 51.200
Os computadores só podem armazenar até certo ponto, então, a partir de um certo ponto,

2119
01: 37: 51,200 -> 01: 37: 52.908
você não sabe o que está acontecendo lá fora.

2120
01: 37: 52.908 -> 01: 37: 53.480
Eu gosto disso.

2121
01: 37: 53.480 -> 01: 37: 54.710
Porque isso é verdade.

2122
01: 37: 54.710 -> 01: 37: 57.120
Se você tiver apenas uma quantidade finita de hardware,

2123
01: 37: 57,120 -> 01: 38: 00.830
como uma quantidade finita de memória, em algum momento, o computador tem que decidir,

2124
01: 38: 00,830 -> 01: 38: 02.780
Não posso contar mais do que este valor.

2125
01: 38: 02,780 -> 01: 38: 06.890
Ou não posso armazenar mais do que esse número após a vírgula decimal.

2126
01: 38: 06,890 -> 01: 38: 09.290
Você pode estar usando 32 bits, o que é um float.

2127
01: 38: 09,290 -> 01: 38: 12.470
Você poderia usar mais bits, como um duplo, como descrevi anteriormente,

2128
01: 38: 12.470 -> 01: 38: 14.720
literalmente usa o dobro de bits, 64 bits.

2129
01: 38: 14,720 -> 01: 38: 19.580
Isso significa que poderíamos ir mais longe antes de ver essa imprecisão.

2130
01: 38: 19,580 -> 01: 38: 20.870
Mas você vai ver.

2131
01: 38: 20.870 -> 01: 38: 24.440
Os computadores, de fato, não são perfeitos nesse sentido.

2132
01: 38: 24,440 -> 01: 38: 26.780
Eles podem armazenar apenas uma quantidade finita de informações.

2133
01: 38: 26,780 -> 01: 38: 31.190
E então, nesse sentido, o computador está armazenando a correspondência mais próxima possível

2134
01: 38: 31,190 -> 01: 38: 34.190
para 1 dividido por 10 que pode.

2135
01: 38: 34,190 -> 01: 38: 38.090
Porque você não pode armazenar um número infinito de números 100%

2136
01: 38: 38,090 -> 01: 38: 42.080
precisamente usando uma quantidade finita de informações.
2137
01: 38: 42,080 -> 01: 38: 44.060
E vemos isso em outro contexto também.

2138
01: 38: 44,060 -> 01: 38: 48.530
Deixe-me prosseguir e escrever um outro programa aqui chamado overflow.c.

2139
01: 38: 48.530 -> 01: 38: 50.990
E veremos o mesmo problema em outro contexto.

2140
01: 38: 50,990 -> 01: 38: 54.350
Deixe-me ir em frente e incluir stdio.h.

2141
01: 38: 54,350 -> 01: 38: 57.410
Deixe-me ir em frente e fazer int main void.

2142
01: 38: 57.410 -> 01: 39: 01.190
Deixe-me ir em frente e fazer isso.

2143
01: 39: 01,190 -> 01: 39: 07.478
Vou prosseguir e dizer sem condição e fazer i vezes igual 2.

2144
01: 39: 07,478 -> 01: 39: 09.020
E deixe-me ir em frente e fazer isso.

2145
01: 39: 09,020 -> 01: 39: 11.840
Imprima o valor de i.

2146
01: 39: 11.840 -> 01: 39: 15.440
Estou fazendo o super rápido, mas acabei de escrever um programa aqui

2147
01: 39: 15.440 -> 01: 39: 17.510
isso vai começar a contar do zero.

2148
01: 39: 17.510 -> 01: 39: 19.430
Vai multiplicar i.
2149
01: 39: 19,430 -> 01: 39: 22.562
asterisco igual apenas significa duas vezes repetidas vezes.

2150
01: 39: 22,562 -> 01: 39: 25.520
E vai fazer isso para sempre, porque eu literal e deliberadamente

2151
01: 39: 25,520 -> 01: 39: 27.380
não fiz uma expressão booleana aqui.

2152
01: 39: 27,380 -> 01: 39: 29.352
Eu poderia realmente dizer algo como True,

2153
01: 39: 29,352 -> 01: 39: 30.810
mas também posso deixar em branco.

2154
01: 39: 30.810 -> 01: 39: 32.310
Então, isso significa apenas fazer isso para sempre.

2155
01: 39: 32,310 -> 01: 39: 33.590
É um loop infinito.

2156
01: 39: 33.590 -> 01: 39: 36.950
Bem, deixe-me continuar e isso vai voar para além da tela aqui.

2157
01: 39: 36,950 -> 01: 39: 40.190
Então, também vou por para dormir por um segundo no meio.

2158
01: 39: 40,190 -> 01: 39: 43.010
E, de fato, há uma função em C chamada "sleep".

2159
01: 39: 43.010 -> 01: 39: 45.230
Mas para usá-la, você realmente deve incluir

2160
01: 39: 45,230 -> 01: 39: 50.092
outro arquivo chamado unistandard.h.

2161
01: 39: 50,092 -> 01: 39: 52.550
Você só saberia disso olhando na documentação,

2162
01: 39: 52.550 -> 01: 39: 55.820
mas é uma função útil que me permite dormir um segundo de cada vez.

2163
01: 39: 55,820 -> 01: 39: 57.920
Deixe-me ir em frente "make overflow".

2164
01: 39: 57,920 -> 01: 39: 58.650
Sem erros.

2165
01: 39: 58.650 -> 01: 40: 00.650
Deixe-me aumentar o tamanho da minha tela.

2166
01: 40: 00,650 -> 01: 40: 02.600
E deixe-me ir em frente e executar overflow.

2167
01: 40: 02.600 -> 01: 40: 06.530
E veremos que a cada segundo, ele imprime um valor começando em um,

2168
01: 40: 06.530 -> 01: 40: 08.780
e então duplica, e então duplica,

2169
01: 40: 08,780 -> 01: 40: 10.760
e então o duplica novamente.

2170
01: 40: 10.760 -> 01: 40: 13.220
Então, você deve se lembrar de alguns desses valores da semana passada,

2171
01: 40: 13,220 -> 01: 40: 16.620
onde eu propus que fossem 1.024 páginas em uma lista telefônica,

2172
01: 40: 16.620 -> 01: 40: 18.893
e então ficou cada vez menor.

2173
01: 40: 18.893 -> 01: 40: 20.310
Agora estamos apenas fazendo o oposto.

2174
01: 40: 20.310 -> 01: 40: 22.970
Estamos dobrando por dois, por dois, por dois.

2175
01: 40: 22.970 -> 01: 40: 26.090
Passamos de um milhão agora, 2 milhões, 4 milhões, 8 milhões,

2176
01: 40: 26.090 -> 01: 40: 27.077
16 milhões.

2177
01: 40: 27.077 -> 01: 40: 28.160
Então, estamos chegando lá.

2178
01: 40: 28,160 -> 01: 40: 30.770
Portanto, parece que os inteiros são muito grandes.

2179
01: 40: 30.770 -> 01: 40: 35.720
Eles estão realmente usando 32 bits em um computador que aparentemente -

2180
01: 40: 35,720 -> 01: 40: 38.150
o que acabou de acontecer?

2181
01:40:38,150 --> 01:40:39,170
Another lie.

2182
01: 40: 39,170 -> 01: 40: 44.360
Se você apenas multiplicar algum número inteiro por dois para sempre, ele eventualmente se torna zero,

2183
01: 40: 44,360 -> 01: 40: 46.310
ao que parece.

2184
01: 40: 46,310 -> 01: 40: 48.153
Isso também não está certo.

2185
01: 40: 48,153 -> 01: 40: 49.070
Mas o que aconteceu?

2186
01: 40: 49,070 -> 01: 40: 51.770
E há uma espécie de ilusão nisso, tanto no nome do meu programa

2187
01: 40: 51.770 -> 01: 40: 53.240
e no erro vermelho.

2188
01: 40: 53.240 -> 01: 40: 56.750
Bem, em algum ponto, você só tem alguns bits

2189
01: 40: 56,750 -> 01: 40: 59.840
depois disso, se você continuar incrementando, incrementando, incrementando,

2190
01: 40: 59,840 -> 01: 41: 02.600
você não tem bits suficientes para carregar um, por assim dizer,

2191
01: 41: 02.600 -> 01: 41: 04.580
e lembre-se do valor ainda maior.

2192
01: 41: 04,580 -> 01: 41: 08.000
Afinal, se voltarmos a algumas de nossas discussões na semana passada para discutir agora

2193
01: 41: 08.000 -> 01: 41: 12.240
o que é chamado de imprecisão de ponto flutuante ou agora estouro de inteiro,

2194
01: 41: 12,240 -> 01: 41: 14.720
o que significa que os floats só podem ser tão precisos

2195
01: 41: 14,720 -> 01: 41: 16.830
e os inteiros só podem ser tão grandes.

2196
01: 41: 16,830 -> 01: 41: 18.670
O que você tem é o seguinte cenário.

2197
01: 41: 18.670 -> 01: 41: 21.253
123 em decimal, em nosso mundo humano -

2198
01: 41: 21,253 -> 01: 41: 23.170
claro, você pode simplesmente continuar adicionando um a ele.

2199
01: 41: 23,170 -> 01: 41: 26.630
E assim que você atinge o nove, ele rola para zero.

2200
01: 41: 26,630 -> 01: 41: 29.240
Você então carrega um, e você tem 130.

2201
01: 41: 29,240 -> 01: 41: 30.380
Isso funciona muito bem.

2202
01: 41: 30,380 -> 01: 41: 36.050
Mas é claro, mesmo em decimal, se você estiver em 999 usando apenas três dígitos

2203
01: 41: 36,050 -> 01: 41: 39.440
e você tenta adicionar mais um, você carrega um, carrega aquele,

2204
01: 41: 39,440 -> 01: 41: 41.000
você perde um.

2205
01: 41: 41.000 -> 01: 41: 41.840
Desculpe.

2206
01: 41: 41,840 -> 01: 41: 43.110
O que acontece depois?

2207
01: 41: 43,110 -> 01: 41: 47.030
Isso se torna 1, 0, 0, 0.

2208
01: 41: 47,030 -> 01: 41: 50.420
Mas se você tiver apenas três dígitos, você perde aquele inicial,

2209
01: 41: 50,420 -> 01: 41: 51.890
e você fica com apenas zero.

2210
01: 41: 51,890 -> 01: 41: 53.150
A mesma coisa acontece em binário.

2211
01: 41: 53,150 -> 01: 41: 54.690
Agora, se você mudar de contexto -

2212
01: 41: 54.690 -> 01: 41: 58.860
e este é, em binário, que número?

2213
01: 41: 58,860 -> 01: 42: 01.580
Essa é a cassa do quarto, casa do dois, uns.

2214
01: 42: 01,580 -> 01: 42: 02.420
Então é sete.

2215
01: 42: 02,420 -> 01: 42: 04.280
4 mais 2 mais 1, isso é 7.

2216
01: 42: 04,280 -> 01: 42: 06.230
Então, é claro, se você adicionar 1 a 7, você gostaria

2217
01: 42: 06,230 -> 01: 42: 10.010
para obter 8, o que lhe daria 1, 0, 0.

2218
01: 42: 10,010 -> 01: 42: 13.370
Mas se você tiver apenas três bits, três dígitos,

2219
01: 42: 13,370 -> 01: 42: 15.740
você vai transbordar, por assim dizer.

2220
01: 42: 15,740 -> 01: 42: 19.400
Você vai perder o que está carregando, de modo que o valor que está realmente armazenando

2221
01: 42: 19.400 -> 01: 42: 20.600
é apenas zero.

2222
01: 42: 20.600 -> 01: 42: 23.600
É por isso que se eu contar alto o suficiente com um número inteiro em um programa,

2223
01: 42: 23.600 -> 01: 42: 28.010
uma vez que eu alcancei os bilhões, eventualmente aquele foi levado longe demais.

2224
01: 42: 28,010 -> 01: 42: 30.620
São apenas 32 bits.

2225
01: 42: 30.620 -> 01: 42: 33.530
Não podemos colocar um número ainda maior do que esse.

2226
01: 42: 33.530 -> 01: 42: 35.240
Isso é chamado de estouro de inteiro.

2227
01: 42: 35,240 -> 01: 42: 38.340
E se você já ouviu falar do problema Y2K(bug do milenio),

2228
01: 42: 38,340 -> 01: 42: 43.340
este era um problema horrível e muito simples que os humanos criaram para si próprios

2229
01: 42: 43,340 -> 01: 42: 46.960
na época em que os computadores foram inventados em meados de 1900, na verdade.

2230
01: 42: 46,960 -> 01: 42: 50.410
Os humanos decidiram economizar espaço, muito razoável, porque o espaço era caro

2231
01: 42: 50,410 -> 01: 42: 51.260
logo no início.

2232
01: 42: 51,260 -> 01: 42: 58.452
Então, em vez de armazenar o ano de 1999 ou 1970 para 1970, o que eles fizeram?

2233
01: 42: 58,452 -> 01: 43: 00.160
Sim, eles armazenaram apenas dois dígitos, certo?

2234
01: 43: 00,160 -> 01: 43: 01.480
Tipo, oh meu Deus, não vamos usar

2235
01: 43: 01,480 -> 01: 43: 03.190
esses computadores daqui a 50 anos.

2236
01: 43: 03,190 -> 01: 43: 04.570
Vamos apenas armazenar dois dígitos.

2237
01: 43: 04.570 -> 01: 43: 06.573
Infelizmente, não foi esse o caso.

2238
01: 43: 06,573 -> 01: 43: 09.490
E havia muito código e muitos computadores por aí

2239
01: 43: 09.490 -> 01: 43: 12.040
que ainda estavam em execução em 1999.

2240
01: 43: 12,040 -> 01: 43: 17.080
Mas se você estiver armazenando apenas dois dígitos e você adicionar mais um ao valor

2241
01: 43: 17,080 -> 01: 43: 20.020
ao ano, o que você gostaria que fosse 2.000 era

2242
01: 43: 20,020 -> 01: 43: 25.120
interpretado erroneamente em muitos sistemas como 1900, neste ponto as coisas quebraram.

2243
01: 43: 25,120 -> 01: 43: 27.580
E o mundo gastou milhões de dólares, presumivelmente,

2244
01: 43: 27.580 -> 01: 43: 30.160
fazendo os programadores começarem a usar mais memória

2245
01: 43: 30,160 -> 01: 43: 32.650
para corrigir este problema em antecipação ao que foi chamado

2246
01: 43: 32,650 -> 01: 43: 35.860
Y2K(bug do milênio) para resolver esse problema.

2247
01: 43: 35,860 -> 01: 43: 38.890
E no final, o mundo não acabou em 1999, o que foi ótimo.

2248
01: 43: 38,890 -> 01: 43: 40.930
Mas foi muito real e muito caro

2249
01: 43: 40.930 -> 01: 43: 43.570
problema por causa dessa falta de previsão.

2250
01: 43: 43.570 -> 01: 43: 46.400
Acontece que há outros exemplos disso também.

2251
01: 43: 46,400 -> 01: 43: 50.980
Neste, outro, por exemplo, quase acabou com Boeing 787.

2252
01: 43: 50,980 -> 01: 43: 53.737
Então, a Boeing não tem estádo na grande mídia recentemente.

2253
01: 43: 53.737 -> 01: 43: 55.570
E mesmo alguns anos atrás, eles tinham o que

2254
01: 43: 55.570 -> 01: 43: 58.150
parecia ser um bug de software muito simples.

2255
01: 43: 58,150 -> 01: 44: 01.300
Retratado aqui é um modelo de avião 787.

2256
01: 44: 01,300 -> 01: 44: 04.210
E o artigo do The New York Times explica o seguinte -

2257
01: 44: 04,210 -> 01: 44: 09.130
"Um avião modelo 787 que é acionado continuamente por 248 dias

2258
01: 44: 09,130 ​​-> 01: 44: 12.070
pode perder toda a corrente alternada, energia elétrica,

2259
01: 44: 12,070 -> 01: 44: 14.380
devido às unidades de controle do gerador simultaneamente

2260
01: 44: 14,380 -> 01: 44: 15.940
entrando no modo de segurança.

2261
01: 44: 15.940 -> 01: 44: 17.920
Esta condição é causada por um contador de software

2262
01: 44: 17,920 -> 01: 44: 20.920
interno aos contadores que irão entrar em overflow

2263
01: 44: 20,920 -> 01: 44: 24.550
após 248 dias de alimentação contínua.

2264
01: 44: 24.550 -> 01: 44: 26.920
A Boeing, segundo o comunicado, está em processo

2265
01: 44: 26,920 -> 01: 44: 30.550
de desenvolver uma atualização de software que remediará a condição de segurança. "

2266
01: 44: 30.550 -> 01: 44: 31.578
Então o que isso quer dizer?

2267
01: 44: 31,578 -> 01: 44: 33.370
Bem, se você realmente pesquisar os números,

2268
01: 44: 33,370 -> 01: 44: 41.560
248 dias é aproximadamente o valor de 2 elevado à 32ª potência,

2269
01: 44: 41,560 -> 01: 44: 44.467
mais ou menos, em 1/100 de segundo.

2270
01: 44: 44,467 -> 01: 44: 47.050
O que quer dizer que a Boeing, em alguma peça crucial de hardware

2271
01: 44: 47,050 -> 01: 44: 51.640
em seus aviões 787 de verdade, estavam usando números inteiros

2272
01: 44: 51.640 -> 01: 44: 56.140
que contavam tanto que após o 248º dia do avião sendo

2273
01: 44: 56,140 -> 01: 44: 59.230
ligado iria realmente transbordar, o resultado do qual

2274
01: 44: 59,230 -> 01: 45: 01.900
é que a energia no avião poderia ser cortada totalmente.

2275
01: 45: 01,900 -> 01: 45: 05.140
E então a solução, se você ler toda a linguagem técnica e jargão

2276
01: 45: 05,140 -> 01: 45: 09.970
ali, eles literalmente tiveram que reiniciar seus aviões a cada 248 dias

2277
01: 45: 09,970 -> 01: 45: 13.270
para redefinir essa variável de volta a zero.

2278
01: 45: 13,270 -> 01: 45: 16.870
Isso acontece ainda hoje no mundo real com questões como essa.

2279
01: 45: 16,870 -> 01: 45: 19.540
E assim você começará a notar essas tendências sempre que as pessoas falarem

2280
01: 45: 19.540 -> 01: 45: 21.760
sobre erros de hardware ou de software.

2281
01: 45: 21,760 -> 01: 45: 24.700
Muito honestamente, você pode normalmente reduzi-los a problemas

2282
01: 45: 24,700 -> 01: 45: 26.690
que vocês mesmos criaram.

2283
01: 45: 26.690 -> 01: 45: 30.310
E deixe-me ir em frente e provar apenas algumas coisas, alguns recursos

2284
01: 45: 30,310 -> 01: 45: 31.390
agora à frente.

2285
01: 45: 31,390 -> 01: 45: 34.450
Acontece que agora que temos a capacidade de escrever código,

2286
01: 45: 34.450 -> 01: 45: 37.630
nossos programas, é claro, podem fazer várias coisas, dizer ou imprimir

2287
01: 45: 37.630 -> 01: 45: 38.657
coisas na tela.

2288
01: 45: 38.657 -> 01: 45: 40.990
Nós, é claro, podemos fazer algo assim em um programa

2289
01: 45: 40,990 -> 01: 45: 43.900
podemos chamar "figlet", que na verdade vem com alguns sistemas.

2290
01: 45: 43,900 -> 01: 45: 46.630
E posso dizer algo como, este é CS50,

2291
01: 45: 46.630 -> 01: 45: 49.540
e imprimi-lo no que é chamado de arte ASCII usando caracteres

2292
01: 45: 49,540 -> 01: 45: 51.707
na tela, isso parecem com letras

2293
01: 45: 51,707 -> 01: 45: 55.520
e criar uma arte bastante bonita, embora da velha escola, na tela.

2294
01: 45: 55.520 -> 01: 45: 58.210
Claro, se você escrever código e entender

2295
01: 45: 58.210 -> 01: 46: 01.450
não apenas como os números e letras são representados, mas também os sons,

2296
01: 46: 01,450 -> 01: 46: 04.270
por nossa conversa da semana passada, você pode fazer coisas ainda mais poderosas,

2297
01: 46: 04,270 -> 01: 46: 08.900
como esta nota, que literalmente terminaremos hoje.

2298
01: 46: 08,900 -> 01: 46: 10.217
LOCUTOR 2: Este é o CS50.

2299
01: 46: 10,217 -> 01: 46: 11.550
DAVID MALAN: É isso para o CS50.

2300
01: 46: 11.550 -> 01: 46: 13.210
Nos veremos na próxima semana.

2301
01: 46: 13,210 -> 01: 46: 15.060
[Traduzido por Ricardo Vicentini. Solicite revisões em: https://github.com/ricardovicentini/cs502020SubtitlesPt-BR]

