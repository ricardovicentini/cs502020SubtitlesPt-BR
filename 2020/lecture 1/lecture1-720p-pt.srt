0
00: 00: 00.000 -> 00: 00: 00.994


1
00: 00: 00,994 -> 00: 00: 03.976
[MÚSICA, TOCANDO]

2
00: 00: 03,976 -> 00: 01: 23.496


3
00: 01: 23,496 -> 00: 01: 27.907
DAVID MALAN: Muito bem, este é o CS50, e este é um dia muito emocionante,

4
00: 01: 27,907 -> 00: 01: 29.990
porque hoje vamos aprender um nova linguagem.

5
00: 01: 29,990 -> 00: 01: 33.020
E isso não é algo que você pode dizer que acontece com você todos os dias.

6
00: 01: 33,020 -> 00: 01: 35.810
E essa linguagem vai se parecer um pouco com isso.

7
00: 01: 35,810 -> 00: 01: 37.220
Hoje, apresentamos C -

8
00: 01: 37,220 -> 00: 01: 41.690
uma linguagem muito tradicional, muito antiga, puramente baseada em texto,

9
00: 01: 41,690 -> 00: 01: 45.230
mas pode fazer tudo o que você pode fazer no Scratch e ainda mais,

10
00: 01: 45,230 -> 00: 01: 47.810
mas sem a interface amigável que estávamos

11
00: 01: 47,810 -> 00: 01: 49.370
acostumados nos últimos dias.

12
00: 01: 49,370 -> 00: 01: 52.490
Embora, no entanto isso possa parecer muito enigmático para você à primeira vista,

13
00: 01: 52,490 -> 00: 01: 55.280
mesmo que haja algumas palavras em inglês ou parecidas com o inglês nisso,

14
00: 01: 55,280 -> 00: 01: 58.200
tenha certeza de que dentro de alguns dias, certamente dentro de algumas semanas,

15
00: 01: 58,200 -> 00: 02: 00.658
você será capaz de entender cada caractere nesta tela,

16
00: 02: 00,658 -> 00: 02: 02.520
cada linha de código e muito mais.

17
00: 02: 02,520 -> 00: 02: 06.157
Mas ouso dizer que qualquer curso como este pode ser um pouco assustador, especialmente

18
00: 02: 06,157 -> 00: 02: 07.490
se você não tem experiência anterior.

19
00: 02: 07,490 -> 00: 02: 10.759
Mas lembre-se da semana passada, de que, de fato, a norma, o caso comum

20
00: 02: 10,759 -> 00: 02: 13.490
2/3 dos alunos do CS50 - talvez você entre eles -

21
00: 02: 13,490 -> 00: 02: 16.250
nunca fizeram um curso de ciência da computação antes.

22
00: 02: 16,250 -> 00: 02: 21.462
Então, o que parece assim hoje, perceba, será exatamente assim no final das contas.

23
00: 02: 21,462 -> 00: 02: 24.170
Na verdade, embora o código pareça diferente - opa.

24
00: 02: 24,170 -> 00: 02: 25.670
Mesmo que o código pareça diferente,

25
00: 02: 25,670 -> 00: 02: 27.830
as ideias hoje serão absolutamente

26
00: 02: 27,830 -> 00: 02: 30.410
as mesmas da semana passada no Scratch.

27
00: 02: 30,410 -> 00: 02: 33.500
Veremos funções e condições e expressões booleanas, loops,

28
00: 02: 33,500 -> 00: 02: 35.390
e outros recursos ao longo do caminho.

29
00: 02: 35,390 -> 00: 02: 37.800
Mas talvez me remeta a este maravilhoso hack do MIT

30
00: 02: 37,800 -> 00: 02: 42.350
em 1991, uma expressão do MIT, é de que, ter uma educação do MIT

31
00: 02: 42,350 -> 00: 02: 44.630
é como beber água de uma mangueira de incêndio.

32
00: 02: 44,630 -> 00: 02: 46.910
E no espírito dos hacks do MIT, como são chamados,

33
00: 02: 46,910 -> 00: 02: 51.140
alguns alunos conectaram uma mangueira de incêndio real a uma fonte de água real

34
00: 02: 51,140 -> 00: 02: 53.480
com uma placa na parede que diz exatamente isso.

35
00: 02: 53,480 -> 00: 02: 56.240
E este é o tipo de curso, como acontece com muitos cursos introdutórios,

36
00: 02: 56,240 -> 00: 02: 58.990
onde parece que você está realmente sendo atingido no rosto com muitas

37
00: 02: 58,990 -> 00: 03: 04.010
informações, muito mais idéias do que você pode carregar de uma vez.

38
00: 03: 04,010 -> 00: 03: 09.652
Mas perceba que você será capaz de absorver ainda mais material com o tempo.

39
00: 03: 09,652 -> 00: 03: 11.360
E o objetivo da aula, em última análise, é

40
00: 03: 11,360 -> 00: 03: 14.240
para apresentar a você tantos conceitos e habilidades práticas

41
00: 03: 14,240 -> 00: 03: 16.040
quantos possam ser úteis mais tarde.

42
00: 03: 16,040 -> 00: 03: 20.960
E então perceba que no final do semestre você vai se sentir muito menos assim

43
00: 03: 20,960 -> 00: 03: 24.630
e muito mais como algo em que você teve sucesso.

44
00: 03: 24,630 -> 00: 03: 27.880
Então, sem mais delongas, vamos introduzir esta linguagem chamada C.

45
00: 03: 27,880 -> 00: 03: 30.380
À esquerda aqui, lembre-se de que isso talvez era o mais simples

46
00: 03: 30,380 -> 00: 03: 31.910
programa que poderíamos escrever no Scratch.

47
00: 03: 31,910 -> 00: 03: 35.330
E tudo o que este programa fez foi compelir um gato, ou qualquer sprite,

48
00: 03: 35,330 -> 00: 03: 36.760
a dizer olá na tela.

49
00: 03: 36,760 -> 00: 03: 38.960
Hoje, para alcançar esse mesmo resultado, 

50
00: 03: 38,960 -> 00: 03: 42.650
vamos começar a escrever código parecido com este, usando apenas um teclado -

51
00: 03: 42,650 -> 00: 03: 44.690
menos controles gráficos para o usuário.

52
00: 03: 44,690 -> 00: 03: 47.910
Mas vamos ver por que o da esquerda é realmente equivalente ao da direita.

53
00: 03: 47,910 -> 00: 03: 50.390
Então, vamos decompô-lo, digamos, nesta única peça do quebra-cabeça.

54
00: 03: 50,390 -> 00: 03: 53.330
Isso, é claro, fez o que -

55
00: 03: 53,330 -> 00: 03: 55.815
isso representava o quê no contexto de um programa Scratch?

56
00: 03: 55,815 -> 00: 03: 57.440
Qual foi o papel desta peça do quebra-cabeças?

57
00: 03: 57,440 -> 00: 03: 58.700
PÚBLICO: Como começar.

58
00: 03: 58,700 -> 00: 03: 59.850
DAVID MALAN: Sim, para começar.

59
00: 03: 59,850 -> 00: 04: 01.892
Então, para a parte principal do seu programa começar,

60
00: 04: 01,892 -> 00: 04: 05.600
você tem que anexá-lo a esta peça do quebra-cabeça com uma bandeira verde.

61
00: 04: 05,600 -> 00: 04: 08.693
E veremos em C que não é tão simples.

62
00: 04: 08,693 -> 00: 04: 11.360
Mas é algo que você pode simplesmente copiar e colar por enquanto.

63
00: 04: 11,360 -> 00: 04: 15.040
E dentro de alguns dias isso fará mais sentido caractere por caractere.

64
00: 04: 15,040 -> 00: 04: 17.720
Int main void e, em seguida, as chaves abertas,

65
00: 04: 17,720 -> 00: 04: 20.029
é seguido por esta chave fechada

66
00: 04: 20,029 -> 00: 04: 22.940
sugere que todo o código que vamos escrever hoje em diante

67
00: 04: 22,940 -> 00: 04: 26.240
vai ficar entre essas duas chaves opostas

68
00: 04: 26,240 -> 00: 04: 28.770
que envolve de uma peça do quebra-cabeça como esta.

69
00: 04: 28,770 -> 00: 04: 31.785
Mesmo que isso não faça muito sentido hoje ou por alguns dias,

70
00: 04: 31,785 -> 00: 04: 34.160
perceba que é funcionalmente equivalente a apenas dizer

71
00: 04: 34,160 -> 00: 04: 38.070
que a bandeira verde foi clicada, aqui está a parte principal do meu programa.

72
00: 04: 38,070 -> 00: 04: 40.197
Agora, o que um programa pode realmente fazer por você?

73
00: 04: 40,197 -> 00: 04: 43.280
Bem, você pode ter algo como dizer "olá, mundo" no Scratch que apenas

74
00: 04: 43,280 -> 00: 04: 45.030
literalmente imprime isso na tela.

75
00: 04: 45,030 -> 00: 04: 48.260
Então, vamos considerar como você implementaria isso em C,

76
00: 04: 48,260 -> 00: 04: 50.930
sendo uma linguagem baseada em texto ou teclado.

77
00: 04: 50,930 -> 00: 04: 55.490
Bem, não há um verbo ou função chamada "say"/"diga" em C. Em vez disso,

78
00: 04: 55,490 -> 00: 04: 57.410
é chamado de "print"/"imprima", ou não exatamente "print".

79
00: 04: 57,410 -> 00: 05: 00.680
Na verdade, é chamado de "printf", onde f significa formatado

80
00: 05: 00,680 -> 00: 05: 03.860
para que você possa imprimir o texto formatado, como veremos em breve.

81
00: 05: 03,860 -> 00: 05: 07.400
Então, você segue e coloca, ao lado de printf, dois parênteses - um

82
00: 05: 07,400 -> 00: 05: 09.830
parênteses de abertura e o parênteses de fechamento.

83
00: 05: 09,830 -> 00: 05: 14.180
E isso é uma espécie de reminiscência desta forma oval em que usamos anteriormente

84
00:05:14,180 -> 00:05:15.770
colocando a entrada em primeiro lugar.

85
00: 05: 15,770 -> 00: 05: 19.210
E a entrada que colocamos na semana passada foi apenas "diga: olá, mundo".

86
00: 05: 19,210 -> 00: 05: 21.770
Então, literalmente, em C, você vai escrever "hello world"

87
00: 05: 21,770 -> 00: 05: 24.200
entre esses dois parênteses.

88
00: 05: 24,200 -> 00: 05: 25.850
Mas C é um pouco mais minucioso.

89
00: 05: 25,850 -> 00: 05: 28.850
Você não pode simplesmente começar a escrever palavras entre parênteses.

90
00: 05: 28,850 -> 00: 05: 32.870
Sempre que você tiver caracteres, palavras, sentenças ou frases,

91
00: 05: 32,870 -> 00: 05: 36.290
você precisa realmente encapsular esse texto com aspas duplas,

92
00: 05: 36,290 -> 00: 05: 37.090
como neste caso.

93
00: 05: 37,090 -> 00: 05: 40.340
Então você só tem que envolver o que quer que você queira dizer ou imprimir

94
00: 05: 40,340 -> 00: 05: 41.540
com aspas duplas aqui.

95
00: 05: 41,540 -> 00: 05: 44.480
E a última coisa com C que é tão fácil de esquecer no início,

96
00: 05: 44,480 -> 00: 05: 47.520
como você sem dúvida irá, é que você precisa terminar seu pensamento.

97
00: 05: 47,520 -> 00: 05: 51.000
Assim como em uma redação de inglês, você normalmente termina uma frase com um ponto,

98
00: 05: 51.000 -> 00: 05: 52.850
Em C você termina seu pensamento

99
00: 05: 52,850 -> 00: 05: 55.730
Mas não com um ponto, e sim com um ponto e vírgula, geralmente

100
00: 05: 55,730 -> 00: 05: 57.560
no final de uma linha de código.

101
00: 05: 57.560 -> 00: 06: 00.882
Mas veremos quais tipos de linhas de código exigem isso.

102
00: 06: 00,882 -> 00: 06: 02.840
À esquerda, temos uma ideia da semana passada.

103
00: 06: 02,840 -> 00: 06: 06.930
À direita, temos uma ideia desta semana, como veremos em breve no meu computador,

104
00: 06: 06,930 -> 00: 06: 08.930
mas elas são funcionalmente equivalentes.

105
00: 06: 08,930 -> 00: 06: 10.440
Elas fazem a mesma coisa.

106
00: 06: 10,440 -> 00: 06: 13.940
Então, como vamos deste programa Scratch

107
00: 06: 13,940 -> 00: 06: 15.540
para este programa Scratch?

108
00:06:15,540 --> 00:06:18,770
Vamos em frente e pontuar uma ultima coisa.

109
00:06:18,770 --> 00:06:20,840
Precisamos de uma última linha de código, que é apenas

110
00:06:20,840 --> 00:06:24,090
surgiu na tela, que é incluir stdio.h.

111
00:06:24,090 --> 00:06:25,320
Bem, o que isso significa?

112
00:06:25,320 --> 00:06:28,010
Acontece que o Scratch é super amigável.

113
00:06:28,010 --> 00:06:30,600
Você tem todas essas categorias de peças coloridas

114
00:06:30,600 --> 00:06:32,670
à esquerda, e elas estão disponíveis para você

115
00:06:32,670 --> 00:06:35,220
a partir do momento que você começa a usar o Scratch.

116
00:06:35,220 --> 00:06:38,910
No C, quando você quer usar alguma função-- ou alguma peça de quebra-cabeças,

117
00:06:38,910 --> 00:06:39,790
Se quiser--

118
00:06:39,790 --> 00:06:42,240
você tem que tipicamente dizer com antecedência ao computador

119
00:06:42,240 --> 00:06:47,110
Onde essa função está implementada, onde ela está salva.

120
00:06:47,110 --> 00:06:50,340
E isso será reconhecido como uma sintaxe encriptada, e dizendo,

121
00:06:50,340 --> 00:06:52,880
Ei, computador, olhe no arquivo que nós vamos

122
00:06:52,880 --> 00:06:56,640
começar chamando stdio.h, seja lá o que isso signifique

123
00:06:56,640 --> 00:06:58,933
com o objetivo de acessar esta função.

124
00:06:58,933 --> 00:07:00,350
Bem, novamente, este é uma assunto muito extenso.

125
00:07:00,350 --> 00:07:02,400
Está é a nossa primeira mangueira de incêndio de hoje.

126
00:07:02,400 --> 00:07:04,620
Mas a linha importante de código para a proposta de hoje

127
00:07:04,620 --> 00:07:07,470
realmente é essa que está mais para baixo ali no meio.

128
00:07:07,470 --> 00:07:11,040
Então, como faço para escrever meu primeiro programa em C,

129
00:07:11,040 --> 00:07:15,210
Igual na semana passada, quando escrevemos nosso primeiro programa no Scratch?

130
00:07:15,210 --> 00:07:18,540
Bem, considere que a primeira coisa que fizemos no Scratch

131
00:07:18,540 --> 00:07:22,950
era abrir um programa, uma ferramenta - scratch.mit.edu.

132
00: 07: 22,950 -> 00: 07: 25.530
Você pode programar, na verdade, em seu próprio Mac, ou PC,

133
00: 07: 25,530 -> 00: 07: 27.510
não importa qual sistema operacional você está usando.

134
00: 07: 27,510 -> 00: 07: 30.630
Mas, francamente, tende a ser muito irritante e muito sujeito

135
00: 07: 30,630 -> 00: 07: 32.640
a dores de cabeça se todos nós

136
00: 07: 32,640 -> 00: 07: 36.900
tentarmos instalar o software necessário em todos os nossos Macs e PCs individualmente.

137
00: 07: 36,900 -> 00: 07: 39.420
Invariavelmente, todos nós temos diferentes versões das coisas,

138
00: 07: 39,420 -> 00: 07: 41.500
e nossos computadores não funcionam exatamente da mesma forma.

139
00: 07: 41,500 -> 00: 07: 44.440
Portanto, nas primeiras semanas do CS50, usamos uma ferramentas baseadas em nuvem -

140
00: 07: 44,440 -> 00: 07: 48.270
CS50 Sandbox, que reside em sandbox.cs50.io.

141
00: 07: 48,270 -> 00: 07: 51.360
E você usará ela para seu primeiro desafio na próxima semana.

142
00: 07: 51,360 -> 00: 07: 54.280
Este é um ambiente de programação semelhante em espírito ao Scratch,

143
00: 07: 54,280 -> 00: 07: 55.530
mas isso não usa Scratch.

144
00:07:55,530 --> 00:07:57,000
Isto não usa peças de quebra-cabeça.

145
00:07:57,000 --> 00:07:59,730
Ao invés usa C, que é uma linguagem de texto

146
00:07:59,730 --> 00:08:01,530
Que vamos começar a ver agora.

147
00:08:01,530 --> 00:08:04,410
Então há duas partis principais no ambiente deste programa.

148
00:08:04,410 --> 00:08:07,350
Aqui no topo, será onde escrevo meu código real.

149
00:08:07,350 --> 00:08:09,250
Literalmente, em um momento, clicarei naquele sinal de mais,

150
00:08:09,250 --> 00:08:10,708
e vou criar um novo arquivo.

151
00:08:10,708 --> 00:08:13,390
E vou começar a escrever o código nesse arquivo e salvá-lo.

152
00: 08: 13,390 -> 00: 08: 16.038
E então, na metade inferior deste ambiente de programação

153
00: 08: 16,038 -> 00: 08: 18.330
é o que vamos chamar uma janela de terminal.

154
00: 08: 18,330 -> 00: 08: 20.880
Uma janela de terminal é uma espécie de interface das antigas

155
00: 08: 20,880 -> 00: 08: 24.780
através do qual você pode executar comandos digitando-os literalmente em um prompt

156
00: 08: 24,780 -> 00: 08: 25.980
e pressione Enter.

157
00: 08: 25,980 -> 00: 08: 27.330
Tão diferente do Scratch -

158
00: 08: 27,330 -> 00: 08: 29.700
e francamente, ao contrário do Mac OS e do Windows hoje em dia -

159
00: 08: 29,700 -> 00: 08: 32.610
onde você aponta e clica e arrasta e assim por diante, interagindo

160
00: 08: 32,610 -> 00: 08: 35.460
com uma interface gráfica de usuário, muito de nossa programação

161
00: 08: 35,460 -> 00: 08: 38.620
no início vai envolver comandos de digitação.

162
00: 08: 38,620 -> 00: 08: 40.380
Então, vamos tornar isso mais real.

163
00: 08: 40,380 -> 00: 08: 44.580
O objetivo em questão, novamente, é, simplesmente, implementar um programa em C

164
00: 08: 44,580 -> 00: 08: 47.580
que diz olá para o mundo, que funcionalmente será

165
00: 08: 47,580 -> 00: 08: 49.950
semelhante ao programa Scratch à esquerda.

166
00: 08: 49,950 -> 00: 08: 53.295
Mas agora precisamos implementá-lo usando a linguagem certa.

167
00: 08: 53,295 -> 00: 08: 55.170
Então, neste ambiente de programação, vou

168
00: 08: 55,170 -> 00: 08: 59.610
seguir em frente e clicar aqui no sinal de mais para criar um novo arquivo ou guia.

169
00: 08: 59,610 -> 00: 09: 03.090
Por convenção, irei prosseguir e nomear meu arquivo com algo como hello.c.

170
00: 09: 03,090 -> 00: 09: 05.550
Olá só porque quero que este programa diga olá,

171
00: 09: 05,550 -> 00: 09: 07.170
mas eu poderia chamá-lo do que quiser.

172
00: 09: 07,170 -> 00: 09: 10.920
E ponto c porque a convenção, nesta linguagem de programação C,

173
00: 09: 10.920 -> 00: 09: 14.640
é nomear seus arquivos que contêm seu código com este

174
00: 09: 14,640 -> 00: 09: 18.740
ponto c, bem como você tem ponto doc ou ponto docx para Microsoft Word,

175
00: 09: 18,740 -> 00: 09: 22.342
ponto gif para arquivos gráficos e similares.

176
00: 09: 22,342 -> 00: 09: 24.300
Então, vou prosseguir e clicar em Criar arquivo.

177
00: 09: 24,300 -> 00: 09: 27.750
E você verá agora que tenho um prompt piscando na linha 1--

178
00: 09: 27,750 -> 00: 09: 31.530
ele numerará automaticamente minhas linhas - em uma guia chamada hello.c.

179
00: 09: 31,530 -> 00: 09: 33.000
É aqui que posso escrever código.

180
00: 09: 33.000 -> 00: 09: 37.210
Agora, embora o código que estou prestes a escrever seja, francamente, bastante enigmático -

181
00: 09: 37,210 -> 00: 09: 41.400
include stdio.h, int main void.

182
00: 09: 41,400 -> 00: 09: 44.220
E então aqui, vou fazer printf, aspas, aspas,

183
00: 09: 44,220 -> 00: 09: 46.650
ponto e vírgula "hello world".

184
00: 09: 46,650 -> 00: 09: 50.008
Acabei de escrever meu primeiro programa em C.

185
00: 09: 50,008 -> 00: 09: 52.050
Vou prosseguir e aumentar o zoom no canto superior esquerdo.

186
00: 09: 52,050 -> 00: 09: 54.120
São seis linhas de código no total.

187
00: 09: 54,120 -> 00: 09: 57.720
E você verá que incluí stdio.h, o que quer que isso signifique,

188
00: 09: 57,720 -> 00: 09: 59.850
int main void, o que quer que isso signifique.

189
00: 09: 59,850 -> 00: 10: 02.610
E então, realmente, a essência deste programa está na linha 5 -

190
00: 10: 02,610 -> 00: 10: 07.050
print ou printf para formatação, "olá, mundo."

191
00: 10: 07,050 -> 00: 10: 10.050
Portanto, lembre-se de que int main void é semelhante em espírito à

192
00: 10: 10,050 -> 00: 10: 11.580
quando a bandeira verde foi clicada.

193
00: 10: 11,580 -> 00: 10: 13.980
E printf é semelhante ao bloco "diga".

194
00: 10: 13,980 -> 00: 10: 16.350
E essa linha de cima de código, só precisamos dela,

195
00: 10: 16,350 -> 00: 10: 19.320
porque o computador não vai entender printf

196
00: 10: 19,320 -> 00: 10: 22.630
a menos que eu diga para incluir esse arquivo.

197
00: 10: 22,630 -> 00: 10: 26.850
Tudo bem, agora eu proclamo que escrevi algum código.

198
00: 10: 26,850 -> 00: 10: 28.110
Como faço para executá-lo?

199
00: 10: 28,110 -> 00: 10: 32.390
Bem, como você executa um programa no seu Mac ou PC?

200
00: 10: 32,390 -> 00: 10: 34.590
O que você normalmente faz?

201
00: 10: 34,590 -> 00: 10: 36.180
Você clica duas vezes, certo?

202
00: 10: 36,180 -> 00: 10: 39.730
Infelizmente, não parece haver nada óbvio para clicar duas vezes aqui.

203
00: 10: 39,730 -> 00: 10: 41.370
Na verdade, não há nenhum ícone na minha tela.

204
00: 10: 41,370 -> 00: 10: 44.100
E, de fato, ainda não existe um programa em si.

205
00: 10: 44,100 -> 00: 10: 47.760
Porque os computadores, lembre-se da semana passada, não entendem inglês.

206
00: 10: 47,760 -> 00: 10: 49.740
Eles não entendem tecnicamente C, em si.

207
00: 10: 49,740 -> 00: 10: 52.440
Veja qual é a linguagem que os computadores falam e entendem?

208
00: 10: 52,440 -> 00: 10: 53.235
PÚBLICO: Binário.

209
00: 10: 53,235 -> 00: 10: 55.110
DAVID MALAN: Sim, binário, zeros e uns.

210
00: 10: 55,110 -> 00: 10: 56.943
E, no entanto, isso claramente não são zeros e uns.

211
00: 10: 56,943 -> 00: 11: 00.030
E, francamente, nenhum de nós se divertiria se a programação estivesse envolvida,

212
00: 11: 00,030 -> 00: 11: 03.240
hoje em dia, literalmente escrevendo zeros e uns, que, de algum modo,

213
00: 11: 03,240 -> 00: 11: 06.450
se fazia necessário muito tempo atrás.

214
00: 11: 06,450 -> 00: 11: 09.510
Mas hoje em dia, parece que existe uma solução para esse problema.

215
00: 11: 09,510 -> 00: 11: 12.660
Por mais enigmático que pareça para a maioria de nós nesta sala,

216
00: 11: 12,660 -> 00: 11: 15.540
pelo menos você pode imaginar eventualmente ficar confortável,

217
00: 11: 15,540 -> 00: 11: 18.700
provavelmente, com esta sintaxe, uma vez que você aprenda as regras e a sintaxe

218
00: 11: 18,700 -> 00: 11: 19.530
e assim por diante.

219
00: 11: 19,530 -> 00: 11: 22.260
Mas precisamos converter isso de alguma forma para zeros e uns.

220
00: 11: 22,260 -> 00: 11: 25.110
E como fazer isso talvez não seja óbvio.

221
00: 11: 25,110 -> 00: 11: 31.110
Então, se quisermos converter um código como este em zeros e uns

222
00: 11: 31,110 -> 00: 11: 34.770
que o computador entenda, deve haver alguma etapa intermediária.

223
00: 11: 34,770 -> 00: 11: 38.370
Eu realmente preciso, no meu Mac ou PC ou neste ambiente baseado em nuvem,

224
00: 11: 38,370 -> 00: 11: 43.200
um programa que vai ter como entrada meu código-fonte, que

225
00: 11: 43.200 -> 00: 11: 45.650
é aquela linguagem chamada C, e vai produzir

226
00: 11: 45,650 -> 00: 11: 48.000
como saída o que é chamado de código de máquina.

227
00: 11: 48.000 -> 00: 11: 53.400
Portanto, o código-fonte é algo como C ou Python ou Java ou C ++ e talvez outros

228
00: 11: 53,400 -> 00: 11: 54.660
idiomas que você já ouviu falar.

229
00: 11: 54,660 -> 00: 11: 58.170
É uma sintaxe semelhante ao inglês, na qual você escreve programas.

230
00: 11: 58,170 -> 00: 12: 02.760
Código de máquina são os zeros e uns que todo computador realmente entende.

231
00: 12: 02,760 -> 00: 12: 05.970
Então, para ir do código-fonte ao código de máquina,

232
00: 12: 05,970 -> 00: 12: 08.773
deve haver algum tipo de algoritmo ou, mais especificamente,

233
00: 12: 08,773 -> 00: 12: 10.690
um software que faz essa conversão.

234
00: 12: 10,690 -> 00: 12: 14.230
E esse software é o que vamos começar a chamar de compilador.

235
00: 12: 14,230 -> 00: 12: 17.790
Então, vamos escrever código literalmente apenas digitando comandos em um teclado.

236
00: 12: 17,790 -> 00: 12: 20.160
Vamos salvar esses comandos em um arquivo,

237
00: 12: 20,160 -> 00: 12: 21.900
assim como você salvou seu código no Scratch.

238
00: 12: 21,900 -> 00: 12: 24.990
Mas antes que eu possa executar meu programa e fazer o equivalente a clicar duas vezes

239
00: 12: 24,990 -> 00: 12: 28.200
nele, preciso executá-lo por meio de um compilador

240
00: 12: 28,200 -> 00: 12: 30.640
e produzir sua saída, que é de zeros e uns.

241
00: 12: 30,640 -> 00: 12: 33.000
Então, como faço isso?

242
00: 12: 33.000 -> 00: 12: 35.640
Este é o primeiro dos comandos mais esotéricos,

243
00: 12: 35,640 -> 00: 12: 38.880
mas acontece que é relativamente simples de fazer.

244
00: 12: 38,880 -> 00: 12: 40.680
No topo do meu ambiente de programação -

245
00: 12: 40,680 -> 00: 12: 43.380
novamente, tenho meu código aqui no canto superior esquerdo.

246
00: 12: 43,380 -> 00: 12: 45.780
E se eu rolar para baixo, eu tenho isso, de novo,

247
00: 12: 45,780 -> 00: 12: 47.322
o chamado terminal.

248
00: 12: 47,322 -> 00: 12: 49.530
E o cifrão é apenas uma convenção humana estranha.

249
00: 12: 49,530 -> 00: 12: 51.930
O cifrão significa apenas digite algo aqui.

250
00: 12: 51,930 -> 00: 12: 54.540
Esse é o seu prompt, ou shell.

251
00: 12: 54,540 -> 00: 12: 59.700
Mas o cursor piscando está apenas me convidando a digitar um comando neste prompt.

252
00: 12: 59,700 -> 00: 13: 04.740
O primeiro comando que vou digitar é o chamado Clang para linguagem C.

253
00: 13: 04,740 -> 00: 13: 09.210
Clang é o nome de um programa que existe para compilar código.

254
00: 13: 09,210 -> 00: 13: 10.650
Que Alguém escreveu.

255
00: 13: 10,650 -> 00: 13: 14.100
Outra pessoa online criou este programa chamado Clang - todo um grupo de pessoas,

256
00: 13: 14,100 -> 00: 13: 14.640
de fato.

257
00: 13: 14,640 -> 00: 13: 18.210
Disponibilizado gratuitamente para mim e para você baixar em seus próprios Macs ou PCs

258
00: 13: 18,210 -> 00: 13: 19.990
ou este ambiente de sandbox.

259
00: 13: 19,990 -> 00: 13: 23.110
E podemos usar o Clang para converter o código-fonte em código de máquina.

260
00: 13: 23,110 -> 00: 13: 26.940
Então, vou prosseguir e executar o Clang hello.c.

261
00: 13: 26,940 -> 00: 13: 29.860
Ainda não pressionei Enter, mas no momento em que pressiono Enter,

262
00: 13: 29,860 -> 00: 13: 31.360
vamos ver algo acontecer.

263
00: 13: 31,360 -> 00: 13: 33.720
Deixe-me ir até este pequeno ícone de pasta aqui,

264
00: 13: 33,720 -> 00: 13: 37.020
e você pode realmente ver todos os arquivos na minha sandbox atual,

265
00: 13: 37,020 -> 00: 13: 38.710
por assim dizer, meu ambiente de programação.

266
00: 13: 38,710 -> 00: 13: 41.752
Claro, há apenas um, porque o único arquivo que criei até agora

267
00: 13: 41,752 -> 00: 13: 43.170
é chamado de hello.c.

268
00: 13: 43,170 -> 00: 13: 45.720
Mas observe o que acontece no momento em que pressiono Enter,

269
00: 13: 45,720 -> 00: 13: 47.940
depois de digitar Clang hello.c.

270
00: 13: 47,940 -> 00: 13: 50.610


271
00: 13: 50,610 -> 00: 13: 54.150
Então, claramente, algo mais existe agora, e é

272
00: 13: 54,150 -> 00: 13: 56.490
um nome realmente estúpido e muito enigmático.

273
00: 13: 56,490 -> 00: 14: 02.520
É a.out, mas talvez você possa adivinhar o que há dentro desse novo arquivo.

274
00: 14: 02,520 -> 00: 14: 03.842
O que pode estar dentro dele?

275
00: 14: 03,842 -> 00: 14: 04.800
PÚBLICO: Código de máquina.

276
00: 14: 04,800 -> 00: 14: 06.133
DAVID MALAN: Sim, código de máquina.

277
00: 14: 06,133 -> 00: 14: 09.540
Portanto, significa saída do assembly, mas que significa apenas código de máquina.

278
00: 14: 09,540 -> 00: 14: 13.110
Portanto, dentro deste arquivo há um monte de zeros e uns

279
00: 14: 13,110 -> 00: 14: 16.437
que correspondem a este código, mas em binário,

280
00: 14: 16,437 -> 00: 14: 18.270
na linguagem que o computador pode entender.

281
00: 14: 18,270 -> 00: 14: 20.640
Então, literalmente, o que acabei de fazer foi isso -

282
00: 14: 20,640 -> 00: 14: 24.450
Tomei como entrada um código semelhante a este, escrito em C.

283
00: 14: 24,450 -> 00: 14: 28.148
Executei-o como entrada no compilador e produzi esta saída, zeros e uns.

284
00: 14: 28,148 -> 00: 14: 29.940
E esses zeros e uns eram automaticamente

285
00: 14: 29,940 -> 00: 14: 35.113
salvo para mim dentro de um arquivo que, por convenção humana, é chamado a.out.

286
00: 14: 35,113 -> 00: 14: 37.530
Tudo bem, mas alguém propôs antes, que para executar um programa,

287
00: 14: 37,530 -> 00: 14: 40.088
normalmente, em seu Mac e PC, basta clicar duas vezes nele.

288
00: 14: 40,088 -> 00: 14: 41.880
Mas realmente não há nada para clicar duas vezes.

289
00: 14: 41,880 -> 00: 14: 44.940
E, na verdade, se eu clicar duas vezes nisso, vai ficar muito estranho,

290
00: 14: 44,940 -> 00: 14: 46.380
e o computador não vai entender.

291
00: 14: 46,380 -> 00: 14: 48.930
Porque são zeros e uns que não devem ser clicados.

292
00: 14: 48,930 -> 00: 14: 52.598
Eles devem ser executados neste prompt de comando.

293
00: 14: 52,598 -> 00: 14: 53.890
Então, deixe-me ir em frente e fazer isso.

294
00: 14: 53,890 -> 00: 14: 54.807
Isso também é enigmático.

295
00: 14: 54,807 -> 00: 14: 58.740
Mas vou prosseguir e fazer ./a.out.

296
00: 14: 58,740 -> 00: 15: 02.190
E isso, por mais estranho que pareça à primeira vista,

297
00: 15: 02,190 -> 00: 15: 07.890
é como digo ao computador, execute o programa a.out no meu diretório atual.

298
00: 15: 07,890 -> 00: 15: 11.010
Então, esse ponto que digitei primeiro significa que está literalmente bem aqui,

299
00: 15: 11,010 -> 00: 15: 13.260
na minha pasta atual, como se você estivesse clicando duas vezes

300
00: 15: 13,260 -> 00: 15: 14.730
nele no seu Mac ou PC.

301
00: 15: 14,730 -> 00: 15: 19.650
E /a.out significa olhar neste diretório e executar o programa no arquivo chamado

302
00: 15: 19,650 -> 00: 15: 20.860
a.out.

303
00: 15: 20,860 -> 00: 15: 23.150
Deixe-me ir em frente e pressione Enter.

304
00: 15: 23,150 -> 00: 15: 25.980
E voila, olá mundo.

305
00: 15: 25,980 -> 00: 15: 29.610
Então você ficou muito impressionado na semana passada, pelo que me lembro, quando fiz o gato dizer:

306
00: 15: 29,610 -> 00: 15: 30.580
Olá Mundo.

307
00: 15: 30,580 -> 00: 15: 32.510
Aqui, parecemos menos do que desapontados.

308
00: 15: 32,510 -> 00: 15: 36.360
Mas olá, mundo agora é meu programa em C que faz exatamente a mesma coisa.

309
00: 15: 36,360 -> 00: 15: 39.870
Mas, admito, parece um pouco estúpido no momento.

310
00: 15: 39,870 -> 00: 15: 40.950
Parece um pouco bugado.

311
00: 15: 40,950 -> 00: 15: 44.373
O que o incomoda, mesmo que você nunca tenha programado antes?

312
00: 15: 44,373 -> 00: 15: 45.290
PÚBLICO: Cifrão.

313
00: 15: 45,290 -> 00: 15: 46.748
DAVID MALAN: Sim, o cifrão.

314
00: 15: 46,748 -> 00: 15: 48.660
Eu não quis dizer olá, mundo cifrão,

315
00: 15: 48,660 -> 00: 15: 50.868
mas aquele cifrão é como um artefato, certo?

316
00: 15: 50,868 -> 00: 15: 52.482
O que significa mesmo o cifrão?

317
00: 15: 52,482 -> 00: 15: 53.190
PÚBLICO: Prompt.

318
00: 15: 53,190 -> 00: 15: 54.150
DAVID MALAN: É apenas esse prompt.

319
00: 15: 54,150 -> 00: 15: 57.270
Ele está esperando por outro comando, e é por isso que meu cursor está piscando aqui.

320
00: 15: 57,270 -> 00: 15: 58.603
Mas parece estúpido, certo?

321
00: 15: 58,603 -> 00: 16: 01.538
Poderíamos argumentar que essa era minha intenção, mas, francamente, eu estaria mentindo.

322
00: 16: 01,538 -> 00: 16: 03.330
Isso não faz exatamente o que eu quero que faça.

323
00: 16: 03,330 -> 00: 16: 05.380
E isso porque, ao contrário do Scratch -

324
00: 16: 05,380 -> 00: 16: 06.930
que, novamente, é mais amigável -

325
00: 16: 06,930 -> 00: 16: 12.220
C, e muitas linguagens como esta, literalmente farão apenas o que você lhes disser para fazer.

326
00: 16: 12,220 -> 00: 16: 16.972
Em nenhum momento eu disse ao computador para mover o cursor para uma nova linha.

327
00: 16: 16,972 -> 00: 16: 18.180
Eu não terminei esse pensamento.

328
00: 16: 18,180 -> 00: 16: 20.340
Eu disse, olá, vírgula, mundo e é isso.

329
00: 16: 20,340 -> 00: 16: 23.650
Nunca enviei um comando ao computador para realmente mover o cursor,

330
00: 16: 23,650 -> 00: 16: 24.660
mas eu posso.

331
00: 16: 24,660 -> 00: 16: 26.830
Então, deixe-me voltar ao meu código aqui.

332
00: 16: 26,830 -> 00: 16: 30.300
E acontece que em C, se você disser ao computador

333
00: 16: 30,300 -> 00: 16: 33.240
imprimir olá, vírgula, mundo, isso é literalmente tudo o que 

334
00: 16: 33,240 -> 00: 16: 34.620
vai imprimir para você.

335
00: 16: 34,620 -> 00: 16: 36.810
Se você deseja imprimir uma nova linha, você precisa

336
00: 16: 36,810 -> 00: 16: 40.950
usar um comando especial, um caractere especial denominado caractere de nova linha,

337
00: 16: 40,950 -> 00: 16: 43.650
que é representado pela barra invertida n.

338
00: 16: 43,650 -> 00: 16: 44.672
Agora, por que isso?

339
00: 16: 44,672 -> 00: 16: 46.380
Bem, é realmente porque embora você

340
00: 16: 46,380 -> 00: 16: 49.590
pode ficar inclinado a pressionar Enter, simplesmente assim

341
00: 16: 49,590 -> 00: 16: 51.900
como você esperaria que o computador fizesse,

342
00: 16: 51,900 -> 00: 16: 54.210
mesmo que você nunca tenha programado antes, isso provavelmente

343
00: 16: 54,210 -> 00: 16: 55.950
deve começar a incomodá-lo.

344
00: 16: 55,950 -> 00: 16: 57.270
Parece um pouco estranho.

345
00: 16: 57,270 -> 00: 16: 59.460
Parece um pouco confuso, essa linha está aqui

346
00: 16: 59,460 -> 00: 17: 00.930
e a segunda linha está aqui.

347
00: 17: 00,930 -> 00: 17: 03.180
Então, o que os humanos decidiram anos atrás foi: vamos

348
00:17:03,180 --> 00:17:06,750
apenas ter uma instrução simples, barra invertida n,

349
00: 17: 06,750 -> 00: 17: 10.170
que diz ao computador para mover essa nova linha para baixo.

350
00: 17: 10,170 -> 00: 17: 11.670
Então, deixe-me ir em frente e diminuir o zoom agora.

351
00: 17: 11,670 -> 00: 17: 14.010
Na sandbox, ele salva automaticamente como o Google Docs,

352
00: 17: 14,010 -> 00: 17: 16.589
então você não precisa ir para Arquivo, Salvar ou qualquer coisa assim.

353
00: 17: 16,589 -> 00: 17: 23.440
Se eu prosseguir agora e executar novamente este programa ./a.out Enter, ainda não foi corrigido.

354
00: 17: 23,440 -> 00: 17: 25.319
Deixe-me ir em frente e aumentar o zoom.

355
00: 17: 25,319 -> 00: 17: 27.210
Observe que o sintoma ainda está lá.

356
00: 17: 27,210 -> 00: 17: 28.260
Por quê?

357
00: 17: 28,260 -> 00: 17: 31.050
Que erro eu cometi?

358
00: 17: 31,050 -> 00: 17: 32.700
Sim, não o recompilei.

359
00: 17: 32,700 -> 00: 17: 36.120
Então, novamente, o computador vai começar a te levar muito, muito ao pé da letra

360
00: 17: 36,120 -> 00: 17: 38.580
agora que você está programando ele para fazer coisas.

361
00: 17: 38,580 -> 00: 17: 41.340
E se você quiser executar a nova versão do seu código,

362
00: 17: 41,340 -> 00: 17: 44.880
você vai literalmente ter que fazer algo como Clang

363
00: 17: 44,880 -> 00: 17: 48.360
e então hello.c, Enter.

364
00: 17: 48,360 -> 00: 17: 49.810
E nada parece acontecer.

365
00: 17: 49,810 -> 00: 17: 52.552
E, francamente, e ironicamente, quando você não vê nenhum resultado,

366
00: 17: 52,552 -> 00: 17: 53.760
isso geralmente é uma coisa boa.

367
00: 17: 53,760 -> 00: 17: 56.340
Quando você vê a saída, geralmente é uma lista de, tipo, cinco erros

368
00: 17: 56,340 -> 00: 17: 58.560
que você cometeu ou mensagens de erro que veremos em breve.

369
00: 17: 58,560 -> 00: 18: 00.120
Mas ainda temos a.out.

370
00: 18: 00,120 -> 00: 18: 02.200
É apenas uma versão mais recente disso.

371
00: 18: 02,200 -> 00: 18: 06.930
Então, se eu prosseguir e aumentar o zoom agora e fizer isso-- ./a.out, Enter--

372
00: 18: 06,930 -> 00: 18: 10.070
agora tenho uma versão mais impressionante de hello world.

373
00: 18: 10,070 -> 00: 18: 12.450
Eu acabei de limpar ele um pouco.

374
00: 18: 12,450 -> 00: 18: 14.190
Tudo bem, deixe-me fazer uma pausa por um momento

375
00: 18: 14,190 -> 00: 18: 18.490
e veja se há alguma dúvida sobre essa mecânica até agora.

376
00: 18: 18,490 -> 00: 18: 19.066
Sim?

377
00: 18: 19,066 -> 00: 18: 20.440
PÚBLICO: Por que a linha 2 está vazia?

378
00: 18: 20,440 -> 00: 18: 21.940
DAVID MALAN: Diga um pouco mais alto.

379
00: 18: 21,940 -> 00: 18: 23.640
PÚBLICO: Por que a linha 2 está vazia?

380
00: 18: 23,640 -> 00: 18: 24.330
DAVID MALAN: Por que a linha 2 está vazia?

381
00: 18: 24,330 -> 00: 18: 25.540
Oh, pergunta realmente boa.

382
00: 18: 25,540 -> 00: 18: 29.678
A linha 2 está vazia porque decidi estéticamente

383
00: 18: 29,678 -> 00: 18: 30.720
ter uma aparência um pouco melhor.

384
00: 18: 30,720 -> 00: 18: 32.553
Muito parecido com uma redação de inglês, você pode dar

385
00:18:32,553 --> 00:18:34,500
Enter, só para separar seus parágrafos,

386
00: 18: 34,500 -> 00: 18: 36.810
assim, os programadores geralmente separam seus códigos, apenas

387
00: 18: 36,810 -> 00: 18: 39.300
para torná-lo um pouco mais fácil de digerir para que não

388
00: 18: 39,300 -> 00: 18: 41.610
pareça apenas um grande amontoado de código.

389
00: 18: 41,610 -> 00: 18: 44.680
Mas não é necessário e eu poderia omitir.

390
00: 18: 44,680 -> 00: 18: 46.880
Outras perguntas?

391
00: 18: 46,880 -> 00: 18: 49.036
Sim?

392
00: 18: 49,036 -> 00: 18: 51.940
PÚBLICO: Você pode renomear a.out para ter mais de um

393
00: 18: 51,940 -> 00: 18: 52.898
arquivo em seu diretório?

394
00: 18: 52,898 -> 00: 18: 54.315
DAVID MALAN: Boa pergunta.

395
00: 18: 54,315 -> 00: 18: 57.750
Você pode renomear a.out para ter mais de um arquivo ou programa

396
00: 18: 57.750 -> 00: 18: 58.740
no mesmo diretório?

397
00: 18: 58,740 -> 00: 18: 59.430
Absolutamente.

398
00: 18: 59,430 -> 00: 19: 00.990
Então deixe-me fazer isso agora.

399
00: 19: 00,990 -> 00: 19: 04.350
Acontece que quando você executa comandos em um computador como o Clang,

400
00: 19: 04,350 -> 00: 19: 08.100
você não precisa apenas dizer o nome do programa e o nome do arquivo.

401
00: 19: 08,100 -> 00: 19: 10.380
Você pode adicionar opções adicionais, também conhecidas

402
00: 19: 10,380 -> 00: 19: 12.180
como argumentos de linha de comando.

403
00: 19: 12,180 -> 00: 19: 14.280
E aqui também é um pouco arcaico.

404
00: 19: 14,280 -> 00: 19: 19.020
Você tem que saber o que é possível para digitar essas coisas.

405
00: 19: 19,020 -> 00: 19: 20.640
Mas acontece que com o Clang -

406
00: 19: 20,640 -> 00: 19: 22.740
e se você ler a documentação, verá -

407
00: 19: 22,740 -> 00: 19: 25.920
você pode realmente dizer -o para a saída.

408
00: 19: 25,920 -> 00: 19: 28.140
E então você pode especificar qualquer nome que você

409
00: 19: 28,140 -> 00: 19: 31.860
deseja para o arquivo no qual seu código de máquina será salvo.

410
00: 19: 31,860 -> 00: 19: 33.000
Portanto, observe o que acontece agora.

411
00: 19: 33.000 -> 00: 19: 35.550
Quando pressiono Enter agora, observe o canto superior esquerdo,

412
00: 19: 35,550 -> 00: 19: 37.710
onde eu tenho a.out e hello.c.

413
00: 19: 37,710 -> 00: 19: 40.930
Agora eu também tenho hello.

414
00: 19: 40,930 -> 00: 19: 45.210
E agora posso prosseguir e dizer ./hello em vez de a.out,

415
00: 19: 45,210 -> 00: 19: 48.137
e o resultado agora será o mesmo.

416
00: 19: 48,137 -> 00: 19: 50.970
E deixe-me aproveitar essa oportunidade para pontuar outra coisa.

417
00: 19: 50,970 -> 00: 19: 53.570
Mesmo que vejamos essa interface gráfica aqui,

418
00: 19: 53,570 -> 00: 19: 55.320
isso é apenas conveniente, porque você e eu

419
00: 19: 55,320 -> 00: 19: 59.310
geralmente estão familiarizados com essa interface de nossos próprios Macs e PCs.

420
00: 19: 59,310 -> 00: 20: 04.590
Mas posso fazer tudo por meio deste prompt de comando o que posso fazer por meio do meu mouse.

421
00: 20: 04,590 -> 00: 20: 07.350
Na verdade, neste ambiente de programação,

422
00: 20: 07,350 -> 00: 20: 10.200
Posso digitar um comando chamado ls para listar.

423
00: 20: 10,200 -> 00: 20: 13.800
É uma notação abreviada, porque anos atrás, os humanos decidiram, bem,

424
00: 20: 13,800 -> 00: 20: 17.830
por que digitar L-I-S-T se podemos apenas digitar ls, que soa quase a mesma coisa.

425
00: 20: 17,830 -> 00: 20: 22.320
E assim nasceu o comando ls, que simplesmente exibe

426
00: 20: 22,320 -> 00: 20: 26.340
uma lista de todos os arquivos da pasta ou diretório atual.

427
00: 20: 26,340 -> 00: 20: 30.570
E vemos a mesma coisa - a.out, hello e hello.c.

428
00: 20: 30,570 -> 00: 20: 33.720
E você pode talvez inferir ou adivinhar, o que o asterisco

429
00: 20: 33,720 -> 00: 20: 36.060
quer dizer depois de a.out e hello, talvez?

430
00: 20: 36,060 -> 00: 20: 37.033
PÚBLICO: Executável.

431
00: 20: 37,033 -> 00: 20: 38.950
DAVID MALAN: É executável, o que significa apenas

432
00: 20: 38,950 -> 00: 20: 42.660
há um código de máquina lá que pode ser executado pelo computador,

433
00: 20: 42,660 -> 00: 20: 45.773
enquanto hello.c não tem esse asterisco ou estrela depois dele,

434
00: 20: 45,773 -> 00: 20: 47.190
o que significa apenas que é o código-fonte.

435
00: 20: 47,190 -> 00: 20: 50.340
Assim, você pode até mesmo distinguir visualmente o código-fonte do código de máquina

436
00: 20: 50,340 -> 00: 20: 51.600
do código de máquina.

437
00: 20: 51,600 -> 00: 20: 54.630
Agora, suponha que eu não queira que a.out exista mais,

438
00: 20: 54,630 -> 00: 20: 56.130
porque parece um nome estúpido.

439
00: 20: 56,130 -> 00: 20: 58.230
Nunca vou lembrar que programa ele é.

440
00: 20: 58,230 -> 00: 21: 02.520
Bem, você pode digitar outros comandos, como rm, para remover, a.out.

441
00: 21: 02,520 -> 00: 21: 03.660
E então pressione Enter.

442
00: 21: 03,660 -> 00: 21: 04.980
E isso é um pouco arcaico.

443
00: 21: 04,980 -> 00: 21: 07.540
Ele diz para remover o arquivo comum a.out.

444
00: 21: 07,540 -> 00: 21: 10.890
Observe que o prompt agora está piscando após esse ponto de interrogação.

445
00: 21: 10.890 -> 00: 21: 15.060
Posso prosseguir e digitar Y para sim ou yes para sim.

446
00: 21: 15,060 -> 00: 21: 17.010
Observe que nada parece ter acontecido.

447
00: 21: 17,010 -> 00: 21: 20.730
Mas como posso verificar quais arquivos existem agora nesta pasta?

448
00: 21: 20,730 -> 00: 21: 24.790
Sim, então apenas digito ls de novo, e agora estou com esses dois arquivos.

449
00: 21: 24,790 -> 00: 21: 27.450
Acontece que também existem outros comandos que podemos digitar.

450
00: 21: 27,450 -> 00: 21: 34.140
E há comandos como ls e rm.

451
00: 21: 34,140 -> 00: 21: 36.690
Há mkdir para criar um diretório.

452
00: 21: 36,690 -> 00: 21: 38.683
Existe rmdir para remover o diretório.

453
00: 21: 38,683 -> 00: 21: 41.100
E a qualquer momento que você precisar saber ou usar um desses comandos,

454
00: 21: 41,100 -> 00: 21: 43.080
faremos questão de informá-lo no seu desafio.

455
00: 21: 43,080 -> 00: 21: 46.320
Mas perceba tudo o que você pode fazer com o mouse

456
00: 21: 46,320 -> 00: 21: 50.610
e aquela interface gráfica, você também pode fazer nesta linha de comando.

457
00: 21: 50,610 -> 00: 21: 53.640
Tudo bem, então vamos aumentar um pouco as coisas

458
00: 21: 53,640 -> 00: 21: 55.950
e fazer algo um pouco mais interessante,

459
00: 21: 55,950 -> 00: 21: 58.350
voltando para o lado a lado aqui.

460
00: 21: 58,350 -> 00: 22: 02.000
Até agora, tudo o que fizemos foi imprimir hello world.

461
00: 22: 02.000 -> 00: 22: 04.620
Mas lembre-se, na semana passada, o segundo programa que escrevemos

462
00: 22: 04,620 -> 00: 22: 06.450
foi um pouco mais dinâmico e interativo.

463
00: 22: 06,450 -> 00: 22: 10.200
O que fizemos na semana passada como nosso segundo programa no Scratch, se você se lembrar?

464
00: 22: 10,200 -> 00: 22: 12.400
PÚBLICO: Solicitamos ao usuário seu nome.

465
00: 22: 12,400 -> 00: 22: 14.692
DAVID MALAN: Sim, solicitamos ao usuário o nome dele.

466
00: 22: 14.692 -> 00: 22: 17.550
E então dissemos olá, David, ou olá, Brian, ou quem quer que seja

467
00: 22: 17,550 -> 00: 22: 19.133
estava realmente executando o programa.

468
00: 22: 19,133 -> 00: 22: 21.300
Então aquele programa parecia um pouco com isso.
469
00: 22: 21,300 -> 00: 22: 25.590
Essas duas linhas de código foram anexadas ao bloco "quando a bandeira verde for clicada".

470
00: 22: 25,590 -> 00: 22: 28.170
Este bloco azul aqui no topo era uma função,

471
00: 22: 28,170 -> 00: 22: 32.940
e essa função retornou um argumento, retornou uma resposta.

472
00: 22: 32,940 -> 00: 22: 35.170
Ele retornou a resposta que o usuário havia digitado.

473
00: 22: 35,170 -> 00: 22: 38.130
E isso foi útil, porque usamos a resposta do usuário

474
00: 22: 38,130 -> 00: 22: 42.600
para juntá-los, ou concatenar esquerda e direita, com a palavra hello.

475
00: 22: 42,600 -> 00: 22: 45.160
E então dissemos o resultado disso.

476
00: 22: 45,160 -> 00: 22: 46.255
Então, como fazemos isso em C?

477
00: 22: 46,255 -> 00: 22: 48.630
Bem, é aqui que as coisas vão se complicar rapidamente.

478
00: 22: 48,630 -> 00: 22: 51.570
Mas, novamente, é tudo uma questão de seguir certas regras e padrões que

479
00: 22: 51,570 -> 00: 22: 54.190
vão ficar cada vez mais familiares com o tempo.

480
00: 22: 54,190 -> 00: 22: 57.990
Em C, pelo menos no CS50 Sandbox, o equivalente mais próximo

481
00: 22: 57,990 -> 00: 23: 03.810
para a função "ask/pergunte" no Scratch será uma função C chamada get_string.

482
00: 23: 03,810 -> 00: 23: 06.180
Uma string é apenas uma expressão de programadores

483
00: 23: 06,180 -> 00: 23: 09.750
para uma palavra ou frase ou sentença.

484
00: 23: 09,750 -> 00: 23: 14.470
Portanto, texto, o oposto de números ou algum outro dado.

485
00: 23: 14,470 -> 00: 23: 19.680
Portanto, get_string é o análogo mais próximo da função ask.

486
00: 23: 19,680 -> 00: 23: 22.830
Entre os parênteses, o que implica que aqui está

487
00: 23: 22,830 -> 00: 23: 24.840
onde você pode fornecer alguma entrada, eu posso seguir

488
00: 23: 24,840 -> 00: 23: 27.673
e fornecer o prompt que o usuário verá na tela -

489
00: 23: 27,673 -> 00: 23: 30.217
por exemplo, qual é o seu nome, abre aspas, fecha aspas.

490
00: 23: 30,217 -> 00: 23: 31.050
Agora, por que as aspas?

491
00: 23: 31,050 -> 00: 23: 34.050
Eu acabei de afirmar que sempre que você passar uma string -

492
00: 23: 34,050 -> 00: 23: 36.450
uma palavra, uma frase, caracteres alfanuméricos -

493
00: 23: 36,450 -> 00: 23: 38.460
você tem que colocá-los entre aspas duplas

494
00: 23: 38,460 -> 00: 23: 40.380
à esquerda e aspas duplas à direita.

495
00: 23: 40,380 -> 00: 23: 44.994
E para ser claro, por que eu tenho esse encantamento estranho aqui, barra invertida n?

496
00: 23: 44,994 -> 00: 23: 45.786
PÚBLICO: Nova linha.

497
00: 23: 45,786 -> 00: 23: 47.970
DAVID MALAN: Sim, ele apenas move o cursor para a nova linha.

498
00: 23: 47,970 -> 00: 23: 48.540
Por quê?

499
00: 23: 48,540 -> 00: 23: 50.207
Só porque parece um pouco mais bonito.

500
00: 23: 50,207 -> 00: 23: 51.000
Não é necessário.

501
00: 23: 51.000 -> 00: 23: 54.370
E, de fato, um momento atrás, meu próprio computador me solicitou a resposta sim ou não,

502
00: 23: 54,370 -> 00: 23: 56.780
e não moveu o cursor para a próxima linha.

503
00: 23: 56,780 -> 00: 23: 59.470
Isso porque aquele programador decidiu não se preocupar em fazer isso.

504
00: 23: 59,470 -> 00: 24: 02.120
Mas irei em frente e manterei as coisas limpas fazendo isso.

505
00: 24: 02,120 -> 00: 24: 07.150
Agora, uma vez que eu pergunto ao usuário por seu nome por meio desta função get_string,

506
00: 24: 07,150 -> 00: 24: 08.680
Eu preciso fazer algo com isso.

507
00: 24: 08,680 -> 00: 24: 12.220
E em C, a maneira como você faz isso é literalmente

508
00: 24: 12,220 -> 00: 24: 15.837
dê a si mesmo uma variável, que é um pedaço de armazenamento para um valor.

509
00: 24: 15,837 -> 00: 24: 18.670
E vou prosseguir e chamá-la de resposta, assim como foi feito no Scratch.

510
00: 24: 18,670 -> 00: 24: 21.040
Mas em C, posso chamar isso do que quiser.

511
00: 24: 21,040 -> 00: 24: 22.565
Eu poderia chamá-la de xyz.

512
00: 24: 22,565 -> 00: 24: 25.690
Nenhuma delas é muito descritiva, então vou chamá-la de resposta.

513
00: 24: 25,690 -> 00: 24: 27.100
Você pode usar qualquer palavra.

514
00: 24: 27,100 -> 00: 24: 28.990
Mas C é um pouco diferente.

515
00: 24: 28,990 -> 00: 24: 34.480
C é da velha guarda, e você tem que ser super explícito quanto ao tipo de valor

516
00: 24: 34,480 -> 00: 24: 37.630
que está obtendo e, portanto, armazenando na variável.

517
00: 24: 37,630 -> 00: 24: 40.040
Então, à esquerda do nome da variável,

518
00: 24: 40,040 -> 00: 24: 43.810
Tenho que dizer ao computador o tipo de valor que preciso armazenar

519
00: 24: 43,810 -> 00: 24: 45.010
vai ser uma string.

520
00: 24: 45,010 -> 00: 24: 49.180
E veremos em um momento, que há outros tipos de valores.

521
00: 24: 49,180 -> 00: 24: 53.860
Existem números e muito mais, mas por enquanto, vamos apenas armazenar uma string.

522
00: 24: 53,860 -> 00: 24: 56.760
E há uma coisa faltando nesta linha de código.

523
00: 24: 56,760 -> 00: 24: 57.700
PÚBLICO: Ponto e vírgula.

524
00: 24: 57,700 -> 00: 24: 58.600
DAVID MALAN: Ponto e vírgula, certo?

525
00: 24: 58,600 -> 00: 25: 00.392
Fim do pensamento, e esse foi um grande pensamento,

526
00: 25: 00,392 -> 00: 25: 02.200
mas um ponto-e-vírgula finaliza esse pensamento.

527
00: 25: 02,200 -> 00: 25: 04.700
Agora, este sinal de igual é um pouco diferente da álgebra,

528
00: 25: 04,700 -> 00: 25: 07.750
se você pensar em seus dias de matemática, onde poderia dizer que x é igual a y.

529
00: 25: 07,750 -> 00: 25: 11.440
Quando x é igual a y, isso significa, literalmente, x é a mesma coisa que y.

530
00: 25: 11,440 -> 00: 25: 14.740
Mas aqui, o sinal de igual nas linguagens de programação

531
00: 25: 14,740 -> 00: 25: 17.990
normalmente é o tipo de movimento da direita para a esquerda.

532
00: 25: 17,990 -> 00: 25: 20.560
Este sinal de igual não significa tecnicamente igual.

533
00: 25: 20,560 -> 00: 25: 24.070
Significa atribuir, ou o operador de atribuição.

534
00: 25: 24,070 -> 00: 25: 27.200
Mova algo da direita para a esquerda.

535
00: 25: 27,200 -> 00: 25: 31.600
Então, se esta função get_string, assim como a função ask,

536
00: 25: 31,600 -> 00: 25: 35.140
pede ao usuário o nome dele e devolve um valor,

537
00: 25: 35,140 -> 00: 25: 37.930
você quer colocar esse nome em uma variável

538
00: 25: 37,930 -> 00: 25: 40.192
chamada de resposta, da direita para a esquerda.

539
00: 25: 40,192 -> 00: 25: 42.650
Então, embora nós - assim como escrevemos da direita para a esquerda,

540
00: 25: 42,650 -> 00: 25: 45.710
então você pensa sobre isso executando da direita para a esquerda.

541
00: 25: 45,710 -> 00: 25: 48.310
Então, neste ponto da história, agora temos

542
00: 25: 48,310 -> 00: 25: 52.960
em algum lugar da memória do computador, em uma chamada variável, a resposta do usuário

543
00: 25: 52,960 -> 00: 25: 54.130
ao seu nome.

544
00: 25: 54,130 -> 00: 25: 55.540
O que eu quero fazer com isso?

545
00: 25: 55,540 -> 00: 25: 58.093
Bem, em C, não há uma função de junção, então vamos

546
00: 25: 58,093 -> 00: 26: 00.010
ter que fazer isso um pouco diferente.

547
00: 26: 00,010 -> 00: 26: 03.613
Mas existe um tipo de função "say/diga", e como essa função foi chamada?

548
00: 26: 03,613 -> 00: 26: 04.340
PÚBLICO: Printf.

549
00:26:04,340 --> 00:26:05,173
DAVID MALAN: Printf.

550
00: 26: 05,173 -> 00: 26: 08.440
Então, printf é a função que pode ser acessada sempre que você quiser imprimir ou dizer algo

551
00: 26: 08,440 -> 00: 26: 09.320
na tela.

552
00: 26: 09,320 -> 00: 26: 10.993
Então, vou prosseguir e usar printf.

553
00: 26: 10,993 -> 00: 26: 13.660
E vou usar parênteses, porque parênteses significam, aqui

554
00: 26: 13,660 -> 00: 26: 18.670
com estas entradas, também conhecidas como argumentos ou parâmetros na programação.

555
00: 26: 18,670 -> 00: 26: 21.100
Mas esses são sinônimos para nossos propósitos.

556
00: 26: 21,100 -> 00: 26: 23.350
E agora isso não é um tanto óbvio, certo?

557
00: 26: 23,350 -> 00: 26: 29.180
Porque eu não quero apenas colocar, abre fecha aspas, "oi, vírgula, resposta".

558
00: 26: 29,180 -> 00: 26: 29.680
Por quê?

559
00: 26: 29,680 -> 00: 26: 34.480
Por que seria incorreto abre, fecha aspas, olá, vírgula, resposta?

560
00: 26: 34,480 -> 00: 26: 35.155
O que é isso?

561
00: 26: 35,155 -> 00: 26: 36.400
PÚBLICO: Vai apenas imprimir "resposta".

562
00: 26: 36,400 -> 00: 26: 39.323
DAVID MALAN: Certo, vai literalmente dizer olá, vírgula, resposta, certo?

563
00: 26: 39,323 -> 00: 26: 40.490
E não é isso que queremos.

564
00: 26: 40,490 -> 00: 26: 41.530
Não queremos dizer "Olá, resposta".

565
00: 26: 41,530 -> 00: 26: 43.450
Queremos dizer olá David ou olá Brian,

566
00: 26: 43,450 -> 00: 26: 45.280
ou quem quer esteja rodando este programa.

567
00: 26: 45,280 -> 00: 26: 49.900
Então, de alguma forma, preciso juntar a palavra hello com a entrada do usuário.

568
00: 26: 49,900 -> 00: 26: 53.335
E a maneira de fazer isso no printf é um pouco diferente do Scratch.

569
00: 26: 53,335 -> 00: 26: 55.550
Você usa o que é chamado de "placeholder/espaço reservado".

570
00: 26: 55,550 -> 00: 26: 57.550
Então você literalmente escreve a sentença ou frase

571
00: 26: 57.550 -> 00: 27: 00.220
que você quer dizer ou imprimir na tela,

572
00: 27: 00,220 -> 00: 27: 03.340
mas onde quer que você ainda não saiba o valor com antecedência,

573
00: 27: 03,340 -> 00: 27: 08.570
você coloca um espaço reservado usando um sinal de porcentagem e, em seguida, um s para representar sua string.

574
00: 27: 08,570 -> 00: 27: 11.320
E isso porque, é claro, se estou escrevendo este programa hoje,

575
00: 27: 11,320 -> 00: 27: 13.840
Não tenho ideia de quem vai executá-lo amanhã.

576
00: 27: 13,840 -> 00: 27: 15.910
Quero colocar dinamicamente um "placeholder/marcador de posição"

577
00: 27: 15,910 -> 00: 27: 19.400
então se alguém rodar este programa amanhã ou no dia seguinte,

578
00: 27: 19,400 -> 00: 27: 21.070
seu nome é inserido dinamicamente.

579
00: 27: 21,070 -> 00: 27: 23.410
Eu, claro, não sei o nome deles hoje.

580
00: 27: 23,410 -> 00: 27: 26.350
Portanto, entre aspas, aspas, "olá, vírgula, %s".

581
00: 27: 26,350 -> 00: 27: 30.130
E esse %s é apenas um espaço reservado para tudo o que eu quiser inserir lá.

582
00: 27: 30,130 -> 00: 27: 32.590
"barra invertida n", é claro, significa apenas nova linha.

583
00: 27: 32,590 -> 00: 27: 35.590
Portanto, a única coisa nova aqui é esse percentual s.

584
00: 27: 35,590 -> 00: 27: 39.490
Agora, acontece que funções em C, assim como em Scratch,

585
00: 27: 39,490 -> 00: 27: 40.990
podem não ter argumentos.

586
00:27:40,990 --> 00:27:42,550
Ou podem ter argumentos.

587
00:27:42,550 --> 00:27:44,650
Ou podem ter 2 ou mais argumentos.

588
00: 27: 44,650 -> 00: 27: 49.310
E se elas tiverem dois ou mais, basta separá-los com vírgulas.

589
00: 27: 49,310 -> 00: 27: 50.450
Então, a maneira como printf funciona -

590
00: 27: 50,450 -> 00: 27: 53.200
e você só saberia disso, novamente, sendo ensinado ou lendo

591
00: 27: 53,200 -> 00: 27: 55.720
a documentação - é que você pode, sim,

592
00: 27: 55,720 -> 00: 27: 59.560
fornecer apenas uma única string como entrada -

593
00: 27: 59,560 -> 00: 28: 00.910
entre aspas, alguma coisa.

594
00: 28: 00,910 -> 00: 28: 03.010
Mas se você tiver alguns "placeholders/marcadores" lá,

595
00: 28: 03,010 -> 00: 28: 06.520
você pode dizer ao computador o que concatenar adicionando uma vírgula

596
00: 28: 06,520 -> 00: 28: 10.570
e, em seguida, o nome do valor ou variável que você deseja conectar.

597
00: 28: 10,570 -> 00: 28: 14.120
Portanto, agora, essas duas linhas de código são equivalentes a estas aqui.

598
00: 28: 14,120 -> 00: 28: 15.870
Mas, novamente, embora à primeira vista,

599
00: 28: 15,870 -> 00: 28: 17.620
pode parecer especialmente enigmático, se você apenas

600
00: 28: 17,620 -> 00: 28: 19.480
decompô-lo em componentes individuais

601
00: 28: 19,480 -> 00: 28: 23.020
da direita para a esquerda e de fora para dentro,

602
00: 28: 23,020 -> 00: 28: 28.150
você pode genericamente supor até mesmo o que um novo código que você nunca viu antes

603
00: 28: 28,150 -> 00: 28: 29.860
está fazendo.

604
00: 28: 29,860 -> 00: 28: 33.880
Alguma dúvida sobre essas duas linhas do Scratch ou C?

605
00: 28: 33,880 -> 00: 28: 34.594
Sim?

606
00: 28: 34,594 -> 00: 28: 36.570
PÚBLICO: Você pode adicionar [INAUDÍVEL]?

607
00: 28: 36,570 -> 00: 28: 40.220


608
00: 28: 40,220 -> 00: 28: 41.220
DAVID MALAN: Com certeza.

609
00: 28: 41,220 -> 00: 28: 42.450
Você pode adicionar outras variáveis?

610
00: 28: 42,450 -> 00: 28: 46.290
Se eu tivesse mais variáveis ​​neste programa, graças a mais linhas de código,

611
00: 28: 46,290 -> 00: 28: 49.740
Eu poderia apenas fazer vírgula, outra coisa, vírgula, outra coisa, vírgula.

612
00: 28: 49,740 -> 00: 28: 52.620
E eu poderia ter apenas um "placeholder" nesta 

613
00: 28: 52,620 -> 00: 28: 56.340
expressão para todas as variáveis ​​que desejo inserir.

614
00: 28: 56,340 -> 00: 28: 57.670
E eles vão da esquerda para a direita.

615
00: 28: 57,670 -> 00: 29: 00.510
Então, se eu tivesse dois sinais de "%" aqui, o primeiro

616
00: 29: 00,510 -> 00: 29: 01.890
viria após a primeira vírgula.

617
00: 29: 01,890 -> 00: 29: 04.481
O segundo viria após a segunda vírgula.

618
00: 29: 04,481 -> 00: 29: 06.485
PÚBLICO: Então você precisa de %s [INAUDÍVEL] ??

619
00: 29: 06,485 -> 00: 29: 07.360
DAVID MALAN: Correto.

620
00: 29: 07,360 -> 00: 29: 10.962
Você precisa de um %s para qualquer "placeholder" que deseja inserir, se for uma string.

621
00: 29: 10,962 -> 00: 29: 13.420
E veremos outros "placeholders" em apenas um momento.

622
00: 29: 13,420 -> 00: 29: 14.720
Boa pergunta.

623
00: 29: 14,720 -> 00: 29: 16.464
Outras perguntas?

624
00: 29: 16,464 -> 00: 29: 17.230
Não?

625
00: 29: 17,230 -> 00: 29: 18.440
Oh, sim, la trás.

626
00: 29: 18,440 -> 00: 29: 20.705
PÚBLICO: Existe outra maneira de concatenar strings?

627
00: 29: 20,705 -> 00: 29: 23.080
DAVID MALAN: Existe outra maneira de concatenar strings?

628
00: 29: 23,080 -> 00: 29: 26.533
Resposta curta - sim, de muitas maneiras, nenhuma delas fácil.

629
00: 29: 26,533 -> 00: 29: 29.200
Então, vamos chegar a isso, na verdade, em algumas semanas.

630
00: 29: 29,200 -> 00: 29: 33.290
Printf, por enquanto, é de longe a maneira mais fácil de fazer isso.

631
00: 29: 33,290 -> 00: 29: 34.175
Outras perguntas?

632
00: 29: 34,175 -> 00: 29: 36.550
Se eu não enxergar as mãos de vocês, é porque há tanto brilho.

633
00: 29: 36,550 -> 00: 29: 37.510
Apenas chame.

634
00: 29: 37,510 -> 00: 29: 38.200
Por aqui.

635
00: 29: 38,200 -> 00: 29: 40.550
OK, vocês três.

636
00: 29: 40,550 -> 00: 29: 41.571
Aqui à direita.

637
00: 29: 41,571 -> 00: 29: 43.890
PÚBLICO: [INAUDÍVEL].

638
00: 29: 43,890 -> 00: 29: 44.640
DAVID MALAN: Claro.

639
00: 29: 44,640 -> 00: 29: 45.420
O que é uma string?

640
00: 29: 45,420 -> 00: 29: 50.530
Uma string é uma sequência de zero ou mais caracteres entre aspas duplas.

641
00: 29: 50,530 -> 00: 29: 54.060
Colocado de outra forma, é uma palavra, uma frase, uma sentença, um parágrafo - zero

642
00: 29: 54,060 -> 00: 29: 58.883
ou mais caracteres, letras do alfabeto, entre aspas duplas.

643
00: 29: 58,883 -> 00: 29: 59.550
Outras perguntas?

644
00: 29: 59,550 -> 00: 30: 01.100
Sim?

645
00: 30: 01,100 -> 00: 30: 07.083
PÚBLICO: O que aconteceria se sua barra invertida estivesse fora das aspas.

646
00: 30: 07,083 -> 00: 30: 08.500
DAVID MALAN: Boa pergunta.

647
00: 30: 08,500 -> 00: 30: 11.270
O que aconteceria se sua barra invertida n estivesse fora das aspas?

648
00: 30: 11,270 -> 00: 30: 12.210
Bem, deixe-me fazer isso.

649
00: 30: 12,210 -> 00: 30: 14.210
E, francamente, esse é o instinto certo de se ter.

650
00: 30: 14,210 -> 00: 30: 17.250
A qualquer momento, a frente, que você tenha as mesmas perguntas instintivas,

651
00: 30: 17,250 -> 00: 30: 17.880
apenas tente.

652
00: 30: 17,880 -> 00: 30: 19.770
Você não pode fazer mal ao computador.

653
00: 30: 19,770 -> 00: 30: 22.170
Então deixe-me ir em frente e acidentalmente, se vocês me permitem,

654
00: 30: 22,170 -> 00: 30: 24.510
coloque a barra invertida n fora das aspas,

655
00: 30: 24,510 -> 00: 30: 25.978
é o que eu acho que foi sua pergunta.

656
00: 30: 25,978 -> 00: 30: 27.520
Tudo bem, então vamos ver o que acontece.

657
00: 30: 27,520 -> 00: 30: 29.490
Então, vou agora e executar o Clang.

658
00: 30: 29,490 -> 00: 30: 31.470
Eu sei como fazer um nome personalizado agora,

659
00: 30: 31,470 -> 00: 30: 34.380
então vou adotar essa convenção. -o hello.

660
00: 30: 34,380 -> 00: 30: 36.720
E agora vou dizer hello.c

661
00: 30: 36,720 -> 00: 30: 38.940
que eu acho que vai quebrar.

662
00: 30: 38,940 -> 00: 30: 41.910
E, de fato, algo, de fato, quebrou aqui.

663
00: 30: 41,910 -> 00: 30: 43.420
Vamos ver qual é o erro.

664
00: 30: 43,420 -> 00: 30: 48.210
Portanto, é um pouco arcaico também, mas hello.c, dois pontos 5, dois pontos 26.

665
00: 30: 48,210 -> 00: 30: 49.240
O que está acontecendo lá?

666
00: 30: 49,240 -> 00: 30: 50.370
Bem, deixe-me diminuir o zoom.

667
00: 30: 50,370 -> 00: 30: 53.110
Sempre que você cometer um erro em seu código como este,

668
00: 30: 53,110 -> 00: 30: 57.870
O Clang vai tentar ajudá-lo a descobrir onde está esse erro ou bug.

669
00: 30: 57,870 -> 00: 31: 02.760
Portanto, hello.c Dois pontos 5 significa procurar na linha 5 por seu erro.

670
00: 31: 02,760 -> 00: 31: 07.930
Então, veja, ele diz erro - esperado parênteses de fechamento bem por aqui.

671
00: 31: 07,930 -> 00: 31: 11.500
Então é um pouco estranho, porque não, eu não quero fechar parênteses,

672
00: 31: 11,500 -> 00: 31: 12.000
Eu acho.

673
00: 31: 12.000 -> 00: 31: 13.170
Eu quero a nova linha.

674
00: 31: 13,170 -> 00: 31: 16.080
Portanto, não é perfeitamente capaz de dizer a você, ei,

675
00: 31: 16,080 -> 00: 31: 18.450
essa "\n" deve estar entre as aspas.

676
00: 31: 18,450 -> 00: 31: 21.780
Mas pode pelo menos ajudá-lo a descobrir onde está o erro.

677
00: 31: 21,780 -> 00: 31: 24.000
Então, está em algum lugar por aí, ao qual

678
00: 31: 24.000 -> 00: 31: 26.850
sua própria memória ou sua própria pesquisa no Google deve funcionar para descobrir,

679
00: 31: 26,850 -> 00: 31: 29.717
oh, isso tem que estar entre as aspas.

680
00: 31: 29,717 -> 00: 31: 30.300
Boa pergunta.

681
00: 31: 30,300 -> 00: 31: 31.883
Houve uma terceira pergunta lá atrás?

682
00: 31: 31,883 -> 00: 31: 32.430
Sim?

683
00: 31: 32,430 -> 00: 31: 32.930
Não?

684
00: 31: 32,930 -> 00: 31: 33.480
ESTÁ BEM.

685
00: 31: 33,480 -> 00: 31: 37.860
Tudo bem, então vamos prosseguir agora e fazer a transição para alguns outros recursos

686
00: 31: 37,860 -> 00: 31: 39.360
que podemos fazer, também -

687
00: 31: 39,360 -> 00: 31: 42.630
ou seja, implementar o mesmo programa que acabei de fazer.

688
00: 31: 42,630 -> 00: 31: 45.600
Vou fechar este arquivo e criar um novo chamado,

689
00: 31: 45,600 -> 00: 31: 49.173
digamos, string.c, porque agora estou fazendo experiências com strings.

690
00: 31: 49,173 -> 00: 31: 50.590
E vou começar como antes -

691
00: 31: 50,590 -> 00: 31: 55.260
incluir stdio.h int main void.

692
00: 31: 55,260 -> 00: 32: 01.470
E então vou prosseguir aqui e dizer string resposta get_string,

693
00: 32: 01,470 -> 00: 32: 07.020
entre aspas, qual é o seu nome, ponto de interrogação, "\n", ponto e vírgula.

694
00: 32: 07,020 -> 00: 32: 09.448
E, à parte, tudo que eu digito no teclado

695
00: 32: 09,448 -> 00: 32: 11.490
hoje vamos postar no site do curso depois.

696
00: 32: 11,490 -> 00: 32: 15.010
Portanto, não há necessidade de digitar cada pequeno caractere, se você não quiser.

697
00: 32: 15,010 -> 00: 32: 18.448
E então vou dizer printf, abre aspas fecha aspas, olá, resposta.

698
00: 32: 18,448 -> 00: 32: 20.490
Não "resposta", porque afirmamos que isso era ruim.

699
00: 32: 20,490 -> 00: 32: 22.440
Isso diria literalmente resposta.

700
00: 32: 22,440 -> 00: 32: 24.750
Eu quero fazer um placeholder, %s.

701
00: 32: 24,750 -> 00: 32: 29.920
E agora "\n", vírgula, resposta, ponto e vírgula.

702
00: 32: 29,920 -> 00: 32: 32.910
Então Acho que transcrevi o código do slide

703
00: 32: 32,910 -> 00: 32: 37.920
em meu ambiente de programação agora em um arquivo chamado string.c.

704
00: 32: 37,920 -> 00: 32: 39.300
Então, deixe-me ir em frente e diminuir o zoom.

705
00: 32: 39,300 -> 00: 32: 41.790
E se eu quiser compilar este programa, convertê-lo

706
00: 32: 41,790 -> 00: 32: 46.795
do código-fonte ao código de máquina, que comando posso digitar aqui?

707
00: 32: 46,795 -> 00: 32: 47.295
Então, Clang.

708
00: 32: 47,295 -> 00: 32: 50.150


709
00: 32: 50,150 -> 00: 32: 51.210
Então string.c.

710
00: 32: 51,210 -> 00: 32: 53.590
Mas isso vai me dar um programa, por padrão, chamado

711
00: 32: 53,590 -> 00: 32: 56.030
a.out, o que é muito inútil.

712
00: 32: 56,030 -> 00: 32: 58.670
Então, deixe-me ir em frente e dizer -o string, apenas para

713
00: 32: 58,670 -> 00: 33: 00.230
que meu programa seja chamado de string

714
00: 33: 00,230 -> 00: 33: 02.090
Mas eu poderia chamá-lo do que eu quiser.

715
00: 33: 02,090 -> 00: 33: 04.975
Eu poderia chamá-lo de programa dois, se preferir.

716
00: 33: 04,975 -> 00: 33: 06.350
Deixe-me ir em frente e pressione Enter.

717
00: 33: 06,350 -> 00: 33: 10.220
E ai meu Deus, há mais erros do que linhas

718
00: 33: 10,220 -> 00: 33: 12.320
de código, o que é um pouco preocupante.

719
00: 33: 12,320 -> 00: 33: 15.530
E esta segunda camada é onde você deve se consolar, pois isso significa apenas

720
00: 33: 15,530 -> 00: 33: 17.113
o computador ficou confuso, certo?

721
00: 33: 17,113 -> 00: 33: 20.480
Você não é tão ruim em programação que gera mais erros do que linhas

722
00: 33: 20,480 -> 00: 33: 21.860
de código que você mesmo escreveu.

723
00: 33: 21,860 -> 00: 33: 25.370
É que o computador ficou realmente confuso em algum momento,

724
00: 33: 25,370 -> 00: 33: 28.670
e meio que começa a tropeçar em si mesmo, por assim dizer, conceitualmente.

725
00: 33: 28,670 -> 00: 33: 31.910
Ele não sabe onde está o erro, então começa a interpretar mal o código correto

726
00: 33: 31,910 -> 00: 33: 33.020
como código incorreto.

727
00: 33: 33,020 -> 00: 33: 38.100
Portanto, o ponto de partida é sempre a primeira mensagem de erro.

728
00: 33: 38,100 -> 00: 33: 41.450
Então, você notará que eu já rolei até o comando

729
00: 33: 41,450 -> 00: 33: 44.570
que digitei, que estava bem aqui, como destaquei.

730
00: 33: 44,570 -> 00: 33: 47.270
Concentre-se no primeiro erro que você vê e talvez nos outros

731
00: 33: 47,270 -> 00: 33: 50.985
são apenas erros fantasmas, confusões que surgiram em seu lugar.

732
00: 33: 50,985 -> 00: 33: 53.360
Então, deixe-me ir em frente e ampliar essa parte da tela

733
00: 33: 53,360 -> 00: 33: 55.700
e ver se não podemos diagnosticar esse problema.

734
00: 33: 55,700 -> 00: 33: 59.420
O comando que executei foi Clang -o string string.c.

735
00: 33: 59,420 -> 00: 34: 02.480
Isso significa apenas que minha entrada é meu código-fonte em string.c.

736
00: 34: 02,480 -> 00: 34: 06.500
Quero que minha saída seja um código de máquina em um arquivo chamado string.

737
00: 34: 06,500 -> 00: 34: 09.409
Tudo bem, string.c linha 5 é onde o erro começa,

738
00: 34: 09,409 -> 00: 34: 11.540
então esse parece ser um local familiar.

739
00: 34: 11,540 -> 00: 34: 13.820
Uso de identificador "string" não declarado.

740
00: 34: 13,820 -> 00: 34: 19.960
Você quis dizer - antecipação - stdin?

741
00: 34: 19,960 -> 00: 34: 21.280
Não, não quis.

742
00: 34: 21,280 -> 00: 34: 22.600
Eu quis dizer string neste caso.

743
00: 34: 22,600 -> 00: 34: 25.159
Então, aqui também, o computador ficou confuso,

744
00: 34: 25,159 -> 00: 34: 28.179
e mesmo que seja uma útil mensagem em verde na verdade não é útil.

745
00: 34: 28,179 -> 00: 34: 29.679
Não, eu quero uma string.

746
00: 34: 29,679 -> 00: 34: 31.270
Eu não quero "standard n".

747
00: 34: 31,270 -> 00: 34: 34.060
Mas a razão para isso é que, tecnicamente,

748
00: 34: 34,060 -> 00: 34: 37.420
pelo menos neste ponto da história, não existe essa tal de string,

749
00: 34: 37,420 -> 00: 34: 41.699
S-T-R-I-N-G em C. Na verdade, é uma espécie de rodinhas de apoio

750
00: 34: 41,699 -> 00: 34: 44.949
vamos usar por apenas algumas semanas até que, para sua pergunta anterior,

751
00: 34: 44,949 -> 00: 34: 48.340
vamos mostrar o que realmente está acontecendo sob o capô do computador,

752
00: 34: 48,340 -> 00: 34: 51.130
por assim dizer, quando se trata de implementar uma string.

753
00: 34: 51,130 -> 00: 34: 56.620
Então string é algo que o curso CS50 oferece a você

754
00: 34: 56,620 -> 00: 35: 01.570
em um arquivo chamado CS50.h.

755
00: 35: 01,570 -> 00: 35: 06.355
Assim como existe um arquivo chamado "stardard I/O"-

756
00: 35: 06,355 -> 00: 35: 10.330
onde I/O significa apenas "input/output" entrada/saída, como imprimir e obter entrada.

757
00: 35: 10,330 -> 00: 35: 16.060
Assim como existe um arquivo chamado stdio.h, no qual printf foi inventado,

758
00: 35: 16,060 -> 00: 35: 19.420
todas essas outras funções que posso usar neste programa,

759
00: 35: 19,420 -> 00: 35: 25.000
como get_string, está armazenado em um arquivo chamado CS50.h.

760
00: 35: 25.000 -> 00: 35: 28.150
Então, meu problema surgiu um momento atrás, ao compilar este código,

761
00: 35: 28,150 -> 00: 35: 30.640
porque o computador não tinha ideia do que é uma string.

762
00: 35: 30,640 -> 00: 35: 34.870
E não tem ideia - veremos o que é a função get_string.

763
00: 35: 34,870 -> 00: 35: 37.570
Deixe-me ir em frente e recompilar isso agora.

764
00: 35: 37,570 -> 00: 35: 46.130
Vou prosseguir e fazer Clang -o string string.c e aumentar o zoom.

765
00: 35: 46,130 -> 00: 35: 46.630
Aqui vamos nós.

766
00: 35: 46,630 -> 00: 35: 47.820
Enter.

767
00: 35: 47,820 -> 00: 35: 49.930
OK, progresso.

768
00: 35: 49,930 -> 00: 35: 51.100
Ainda é um bug.

769
00: 35: 51,100 -> 00: 35: 53.230
Ainda há um erro, porque o vermelho não pode

770
00: 35: 53,230 -> 00: 35: 54.850
significa qualquer coisa boa neste contexto.

771
00: 35: 54,850 -> 00: 35: 56.590
E, de fato, é um erro.

772
00: 35: 56,590 -> 00: 35: 58.940
Mas são muito menos erros.

773
00: 35: 58,940 -> 00: 36: 02.080
Portanto, este é o último comando que precisamos apresentar agora.

774
00: 36: 02,080 -> 00: 36: 04.240
Observe o que a mensagem de erro está dizendo.

775
00: 36: 04,240 -> 00: 36: 07.450
Depois de executar o Clang -o string string.c, há

776
00: 36: 07,450 -> 00: 36: 09.490
ainda é um problema na minha função principal.

777
00: 36: 09,490 -> 00: 36: 11.170
Qual é o problema?

778
00: 36: 11,170 -> 00: 36: 13.480
Referência indefinida para get_string.

779
00: 36: 13,480 -> 00: 36: 18.490
Portanto, ao usar a biblioteca CS50, você precisa fazer duas coisas.

780
00: 36: 18,490 -> 00: 36: 21.100
Em seu código-fonte, você tem que dizer ao computador

781
00: 36: 21,100 -> 00: 36: 23.800
para incluir este arquivo CS50.h, onde, novamente,

782
00: 36: 23,800 -> 00: 36: 26.860
funções como get_string e a palavra string

783
00: 36: 26,860 -> 00: 36: 28.870
são realmente implementados para você.

784
00: 36: 28,870 -> 00: 36: 32.170
Mas ao compilar seu código, você precisa, de forma um tanto redundante

785
00: 36: 32,170 -> 00: 36: 37.060
mas por diferentes razões, dizer ao computador para adicionar todo o código

786
00: 36: 37,060 -> 00: 36: 40.600
que a equipe do CS50 escreveu para implementar get_string e string

787
00: 36: 40,600 -> 00: 36: 44.110
e outras funções como esta.

788
00: 36: 44,110 -> 00: 36: 50.530
Então escrever Clang -o string string.c, como antes,

789
00: 36: 50,530 -> 00: 36: 54.400
mas preciso dizer ao computador esta instrução especial

790
00: 36: 54,400 -> 00: 36: 56.410
para vinculá-lo ao CS50.

791
00: 36: 56,410 -> 00: 36: 59.320
E isso fará mais sentido em apenas algumas semanas.

792
00: 36: 59,320 -> 00: 37: 02.620
Mas isso é apenas um -l para link e CS50.

793
00: 37: 02,620 -> 00: 37: 04.720
E tudo isso diz que o computador o que é isso -

794
00: 37: 04,720 -> 00: 37: 10.550
os zeros e uns para o meu programa real virão de string.c certo

795
00: 37: 10,550 -> 00: 37: 11.050
aqui.

796
00: 37: 11,050 -> 00: 37: 12.400
Este é meu código-fonte.

797
00: 37: 12,400 -> 00: 37: 16.780
Mas a equipe do CS50, anos atrás, também escreveu código em C para

798
00: 37: 16,780 -> 00: 37: 19.420
fornecer funções como get_string, para

799
00: 37: 19,420 -> 00: 37: 22.390
fornecer variáveis ​​como strings.

800
00: 37: 22,390 -> 00: 37: 27.070
Os zeros e uns da biblioteca CS50 são armazenados em outro lugar na nuvem.

801
00: 37: 27,070 -> 00: 37: 29.920
Eles precisam estar ligados aos seus.

802
00: 37: 29,920 -> 00: 37: 34.000
Então, assim como seu código está neste arquivo, nosso código está nesse arquivo.

803
00: 37: 34.000 -> 00: 37: 37.330
E assim, dizendo ao computador para incluí-lo em seu código-fonte

804
00: 37: 37,330 -> 00: 37: 40.980
e vinculá-lo a este comando é apenas a maneira arcaica de dizer,

805
00: 37: 40,980 -> 00: 37: 46.930
combine meu código com o código do CS50 em um programa que eu possa realmente executar.

806
00: 37: 46,930 -> 00: 37: 49.180
Agora, tudo isso, francamente é muito rápido

807
00: 37: 49,180 -> 00: 37: 53.170
tornando-se muito opressor, eu acho, e muito desnecessariamente complicado.

808
00: 37: 53,170 -> 00: 37: 56.200
Portanto, há uma maneira melhor do que essa.

809
00: 37: 56,200 -> 00: 38: 00.310
Acontece que, seguindo em frente, se você gostaria de compilar seu código,

810
00: 38: 00,310 -> 00: 38: 01.720
você não precisa se lembrar.

811
00: 38: 01,720 -> 00: 38: 03.935
Você não precisa se lembrar de -l CS50.

812
00: 38: 03,935 -> 00: 38: 07.060
Você não precisa se lembrar de nenhum desses comandos, espero que apenas das ideias.

813
00: 38: 07,060 -> 00: 38: 12.130
Em vez disso, você pode dizer, faça-me um programa chamado string e pronto.

814
00: 38: 12,130 -> 00: 38: 15.970
Toda essa saída é gerada automaticamente para você

815
00: 38: 15,970 -> 00: 38: 18.610
quando você disser ao computador, "make/faça" meu programa.

816
00: 38: 18,610 -> 00: 38: 24.130
E o programa "make" descobrirá quais argumentos de linha de comando usar,

817
00: 38: 24,130 -> 00: 38: 26.800
que nome dar ao arquivo, quais bibliotecas

818
00: 38: 26,800 -> 00: 38: 29.650
ou código que outras pessoas escreveram para serem ligados no seu.

819
00: 38: 29,650 -> 00: 38: 32.500
Portanto, de agora em diante, quando você quiser compilar seu programa,

820
00: 38: 32,500 -> 00: 38: 36.460
literalmente, diga apenas  "make" e o nome do programa.

821
00: 38: 36,460 -> 00: 38: 38.680
Mas não é "make string.c".

822
00: 38: 38,680 -> 00: 38: 41.260
É só "make" e o nome do programa.

823
00: 38: 41,260 -> 00: 38: 43.180
Make, este outro programa, descobrirá

824
00: 38: 43,180 -> 00: 38: 46.630
que você quis dizer algo chamado string.c.

825
00: 38: 46,630 -> 00: 38: 48.910
E posso retroceder e fazer isso para hello também.

826
00: 38: 48,910 -> 00: 38: 50.770
make hello.

827
00: 38: 50,770 -> 00: 38: 53.150
Oh, eu nunca corrigi o problema de antes.

828
00: 38: 53,150 -> 00: 38: 56.660
Então, deixe-me entrar em hello.c abrindo esse arquivo.

829
00: 38: 56,660 -> 00: 38: 59.740
Deixe-me consertar isso para a posteridade.

830
00: 38: 59,740 -> 00: 39: 02.110
Salvar este arquivo ou deixe o arquivo ser salvo automaticamente.

831
00: 39: 02,110 -> 00: 39: 03.310
Agora make hello.

832
00: 39: 03,310 -> 00: 39: 06.100
E viola, fez a mesma coisa pra mim agora.

833
00: 39: 06,100 -> 00: 39: 06.820
Sim?

834
00: 39: 06,820 -> 00: 39: 09.543
PÚBLICO: make é algo padrão... [INAUDÍVEL] ?..

835
00: 39: 09,543 -> 00: 39: 10.960
DAVID MALAN: Boa pergunta.

836
00: 39: 10,960 -> 00: 39: 13.300
"make é algo padrão ou específico do CS50?

837
00: 39: 13,300 -> 00: 39: 16.280
Não é uma coisa específica do CS50.

838
00: 39: 16,280 -> 00: 39: 19.460
É uma ferramenta padrão que existe em Macs, PCs e computadores

839
00: 39: 19,460 -> 00: 39: 21.410
geralmente executando Unix ou Linux.

840
00: 39: 21,410 -> 00: 39: 24.020
E, de fato, a ferramenta sandbox que estamos usando

841
00: 39: 24,020 -> 00: 39: 26.480
é em si um computador na nuvem, embora apenas

842
00: 39: 26,480 -> 00: 39: 30.960
tem essas duas janelas, guias no topo e a janela do terminal embaixo.

843
00: 39: 30,960 -> 00: 39: 32.960
Ao fazer login no CS50 Sandbox, você tem acesso

844
00: 39: 32,960 -> 00: 39: 36.620
ao seu próprio servidor na nuvem executando um sistema operacional chamado Linux.

845
00: 39: 36,620 -> 00: 39: 41.600
E Clang e make e outras ferramentas que veremos, como ls e rm,

846
00: 39: 41,600 -> 00: 39: 43.700
todos existem nesse sistema operacional.

847
00: 39: 43,700 -> 00: 39: 46.580
Eles não são específicos do CS50.

848
00: 39: 46,580 -> 00: 39: 47.768
Sim?

849
00: 39: 47,768 -> 00: 39: 51.235
PÚBLICO: Com isso, hello seria código de máquina, não [INAUDÍVEL] ??

850
00: 39: 51,235 -> 00: 39: 52.110
DAVID MALAN: Correto.

851
00:39:52,110 --> 00:39:53,520
Hello é o código de máquina.

852
00: 39: 53,520 -> 00: 39: 55.756
Hello.c é o código-fonte.

853
00: 39: 55,756 -> 00: 39: 57.244
PÚBLICO: Então [INAUDÍVEL]?

854
00: 39: 57,244 -> 00: 40: 00.915


855
00: 40: 00,915 -> 00: 40: 01.790
DAVID MALAN: Correto.

856
00: 40: 01,790 -> 00: 40: 06.110
Make é um programa inteligente projetado para tornar nossas vidas mais fáceis, sem trocadilhos,

857
00: 40: 06,110 -> 00: 40: 11.210
onde se você fizer "make hello", ele procurará um arquivo chamado hello.c.

858
00: 40: 11,210 -> 00: 40: 14.450
E se o encontrar, criará o programa chamado hello

859
00: 40: 14,450 -> 00: 40: 16.630
do código-fonte ao código de máquina, respectivamente.

860
00: 40: 16,630 -> 00: 40: 17.267
Sim?

861
00: 40: 17,267 -> 00: 40: 18.698
PÚBLICO: [INAUDÍVEL].

862
00: 40: 18,698 -> 00: 40: 22.498


863
00: 40: 22,498 -> 00: 40: 23.540
DAVID MALAN: Não exatamente.

864
00: 40: 23,540 -> 00: 40: 27.770
Portanto, make é um programa que vem com um sistema operacional chamado Linux,

865
00: 40: 27,770 -> 00: 40: 29.150
e também vem com Mac OS.

866
00: 40: 29,150 -> 00: 40: 31.160
E hoje em dia, também vem com o Windows.

867
00: 40: 31,160 -> 00: 40: 34.040
É um programa que você pode executar digitando seu nome,

868
00: 40: 34,040 -> 00: 40: 37.147
não que você execute clicando duas vezes em um ícone.

869
00: 40: 37,147 -> 00: 40: 37.730
Boa pergunta.

870
00: 40: 37,730 -> 00: 40: 38.882
Sim?

871
00: 40: 38,882 -> 00: 40: 39.854
PÚBLICO: [INAUDÍVEL]?

872
00: 40: 39,854 -> 00: 40: 43.755


873
00: 40: 43,755 -> 00: 40: 44.880
DAVID MALAN: Boa pergunta.

874
00: 40: 44,880 -> 00: 40: 46.610
Isso significa que o make está armazenado no seu computador

875
00: 40: 46,610 -> 00: 40: 47.930
ou no computador baseado em nuvem?

876
00: 40: 47,930 -> 00: 40: 49.350
No computador baseado em nuvem.

877
00: 40: 49,350 -> 00: 40: 52.100
Então, até esse ponto do semestre, e nas primeiras semanas,

878
00: 40: 52,100 -> 00: 40: 55.310
tudo o que fizermos será na nuvem em um ambiente padronizado

879
00: 40: 55,310 -> 00: 40: 58.670
chamado CS50 Sandbox e, em breve, algo chamado CS50 Lab.

880
00: 40: 58,670 -> 00: 41: 02.780
Mas é projetado para ser uma representação de um computador Linux padrão

881
00: 41: 02,780 -> 00: 41: 04.210
e também um Mac ou PC.

882
00: 41: 04,210 -> 00: 41: 05.960
Mas o software tende a ser um pouco diferente,

883
00: 41: 05,960 -> 00: 41: 09.470
então padronizamos no Linux, que é um sistema operacional muito popular

884
00: 41: 09,470 -> 00: 41: 12.140
no mundo do desenvolvimento de software.

885
00: 41: 12,140 -> 00: 41: 15.265
Tudo bem, então vamos dar uma olhada em algumas outras equivalências e então

886
00: 41: 15,265 -> 00: 41: 18.015
comparações e começar a escrever programas mais interessantes do que estes

887
00: 41: 18,015 -> 00: 41: 19.220
que apenas dizem olá, mundo.

888
00: 41: 19,220 -> 00: 41: 22.400
Então, aqui está, novamente, um resumo de como você tecnicamente

889
00: 41: 22,400 -> 00: 41: 25.070
deve converter seu código fonte em código de máquina

890
00: 41: 25,070 -> 00: 41: 28.580
usando um programa chamado Clang com um argumento de linha de comando,

891
00: 41: 28,580 -> 00: 41: 33.322
um parâmetro especial, -o hello, para nomear o arquivo de outra forma.

892
00: 41: 33,322 -> 00: 41: 35.780
E honestamente, ninguém nunca vai se lembrar desse comando.

893
00: 41: 35,780 -> 00: 41: 37.905
E mesmo se você fizer isso, é muito entediante digitar.

894
00: 41: 37,905 -> 00: 41: 40.250
É por isso que programas como o make existem, que

895
00: 41: 40,250 -> 00: 41: 42.142
apenas automatize exatamente o mesmo processo.

896
00: 41: 42,142 -> 00: 41: 43.850
Mas eles ainda estão fazendo a mesma coisa -

897
00: 41: 43,850 -> 00: 41: 46.700
compilar seu código-fonte em código de máquina.

898
00: 41: 46,700 -> 00: 41: 48.500
E para executar o programa depois disso, você diz

899
00: 41: 48,500 -> 00: 41: 50.920
ponto, que se refere apenas à sua pasta atual,

900
00: 41: 50,920 -> 00: 41: 54.140
porque veremos que você pode ter várias pastas em um servidor, e hello

901
00: 41: 54,140 -> 00: 41: 55.510
é o nome do programa.

902
00: 41: 55,510 -> 00: 41: 58.760
Tudo bem, vamos dar uma olhada em alguns outros tipos de recursos do Scratch

903
00: 41: 58,760 -> 00: 42: 00.510
e ver como ficam em C,

904
00: 42: 00,510 -> 00: 42: 04.560
e então começaremos a implementar alguns programas em C mais manualmente.

905
00: 42: 04,560 -> 00: 42: 07.130
Portanto, considere este exemplo aqui, que foi um exemplo

906
00: 42: 07,130 -> 00: 42: 11.450
de que tipo de característica no Scratch?

907
00: 42: 11,450 -> 00: 42: 13.300
Isso fez o quê por nós?

908
00: 42: 13,300 -> 00: 42: 14.260
PÚBLICO: Variável.

909
00: 42: 14,260 -> 00: 42: 16.000
DAVID MALAN: Este foi um exemplo de variável.

910
00: 42: 16.000 -> 00: 42: 18.167
E essa variável, neste caso, foi chamada de contador.

911
00: 42: 18,167 -> 00: 42: 21.130
E nós a inicializamos como-- isto é, nós o definimos igual a-- zero.

912
00: 42: 21,130 -> 00: 42: 24.220
Em C, do lado direito, se quisermos obter este mesmo resultado

913
00: 42: 24,220 -> 00: 42: 27.190
de hoje em diante, você vai literalmente dizer o nome da variável,

914
00: 42: 27,190 -> 00: 42: 30.490
como contador, mas você pode chamá-lo do que quiser, igual a zero.

915
00: 42: 30,490 -> 00: 42: 33.198
Porque lembre-se de que o sinal de igual é o operador de atribuição.

916
00: 42: 33,198 -> 00: 42: 34.990
Então, o que está à direita vai ser

917
00: 42: 34,990 -> 00: 42: 37.210
copiado para o que estiver à esquerda.

918
00: 42: 37,210 -> 00: 42: 41.200
No entanto, isso não é suficiente, porque quando você declara uma variável

919
00: 42: 41,200 -> 00: 42: 44.230
e você diz, ei, computador, preciso de algum armazenamento para algum valor,

920
00: 42: 44,230 -> 00: 42: 47.950
você tem que dizer ao computador qual é o tipo dessa variável.

921
00: 42: 47,950 -> 00: 42: 52.000
Vimos que strings são variáveis ​​que armazenam várias palavras.

922
00: 42: 52.000 -> 00: 42: 55.000
Mas, neste caso, queremos armazenar um número.

923
00: 42: 55.000 -> 00: 42: 58.390
E em C, esse tipo de número é chamado de int ou integer,

924
00: 42: 58,390 -> 00: 43: 00.070
mas I-N-T para abreviar.

925
00: 43: 00,070 -> 00: 43: 02.147
Há uma coisa faltando nesta linha de código.

926
00: 43: 02,147 -> 00: 43: 02.980
PÚBLICO: Ponto e vírgula.

927
00: 43: 02,980 -> 00: 43: 03.610
DAVID MALAN: Ponto e vírgula.

928
00: 43: 03,610 -> 00: 43: 04.840
Apenas termina o pensamento.

929
00: 43: 04,840 -> 00: 43: 05.830
Então, o que isso faz?

930
00: 43: 05,830 -> 00: 43: 10.270
Ei, computador, me dê uma variável cujo tipo seja itneger ou int.

931
00: 43: 10,270 -> 00: 43: 15.280
Chame esse contador de variável e armazene o valor zero nessa variável

932
00: 43: 15,280 -> 00: 43: 19.970
por padrão. Acontece que podemos fazer outras operações desse tipo em variáveis.

933
00: 43: 19,970 -> 00: 43: 23.460
Por exemplo, aqui temos o recurso de incrementação do Scratch.

934
00: 43: 23,460 -> 00: 43: 27.080
Altere o contador em um adicionando 1 à variável.

935
00: 43: 27,080 -> 00: 43: 28.510
Então, como fazemos isso em C?

936
00: 43: 28,510 -> 00: 43: 30.800
Em C, você faria algo assim.

937
00: 43: 30,800 -> 00: 43: 35.110
E isso é um pouco paradoxal se você está vindo da álgebra,

938
00: 43: 35,110 -> 00: 43: 38.110
porque como poderia counter ser igual a counter mais 1?

939
00: 43: 38,110 -> 00: 43: 39.560
Mas aqui isso não é igualdade.

940
00: 43: 39,560 -> 00: 43: 41.780
Esta é uma atribuição da direita para a esquerda.

941
00: 43: 41,780 -> 00: 43: 43.780
Portanto, no lado esquerdo, você está dizendo counter.

942
00: 43: 43,780 -> 00: 43: 45.190
Esse é o nome da sua variável.

943
00: 43: 45,190 -> 00: 43: 47.500
No lado direito, você está dizendo counter mais 1,

944
00: 43: 47,500 -> 00: 43: 49.390
qualquer que seja essa resposta aritmética.

945
00: 43: 49,390 -> 00: 43: 53.260
E você está copiando o contador mais 1 no contador.

946
00: 43: 53,260 -> 00: 43: 56.420
Ainda estou sentindo falta de alguma coisa aqui, que é aquele ponto e vírgula.

947
00: 43: 56,420 -> 00: 44: 00.580
Mas não preciso dizer int neste exemplo.

948
00: 44: 00,580 -> 00: 44: 05.200
Neste ponto da história, presume-se que counter já exista

949
00: 44: 05,200 -> 00: 44: 08.020
e que usei uma linha de código como a anterior

950
00: 44: 08,020 -> 00: 44: 10.270
em outro lugar no meu programa.

951
00: 44: 10,270 -> 00: 44: 13.330
Porque isso diz ao computador uma vez, dê-me uma variável chamada counter,

952
00: 44: 13,330 -> 00: 44: 14.950
e deixe-me armazenar ints nela.

953
00: 44: 14,950 -> 00: 44: 17.110
Esta linha de código assume que counter já exista,

954
00: 44: 17,110 -> 00: 44: 20.410
e, portanto, não especificamos a palavra int novamente.

955
00: 44: 20,410 -> 00: 44: 22.060
Você especifica apenas uma vez.

956
00: 44: 22,060 -> 00: 44: 24.040
Agora, precisamos do ponto-e-vírgula, como propus.

957
00: 44: 24,040 -> 00: 44: 26.680
Mas, francamente, esta é uma operação tão comum na programação,

958
00: 44: 26,680 -> 00: 44: 28.930
como veremos, apenas para incrementar uma variável.

959
00: 44: 28,930 -> 00: 44: 31.280
Acontece que há outras maneiras de fazer isso.

960
00: 44: 31,280 -> 00: 44: 33.520
Você pode, em vez disso, equivalentemente dizer isso -

961
00: 44: 33,520 -> 00: 44: 36.250
counter mais igual 1 ponto-e-vírgula.

962
00: 44: 36,250 -> 00: 44: 37.800
É literalmente a mesma coisa.

963
00: 44: 37,800 -> 00: 44: 39.550
E se isso for muito para você,

964
00: 44: 39,550 -> 00: 44: 42.910
você pode literalmente apenas dizer counter mais mais ponto-e-vírgula,

965
00: 44: 42,910 -> 00: 44: 44.500
e isso também faz a mesma coisa.

966
00: 44: 44,500 -> 00: 44: 47.650
Isso é conhecido em programação como sintaxe adocicada.

967
00: 44: 47,650 -> 00: 44: 51.110
Ela não adiciona nenhuma funcionalidade que você não poderia fazer de outra maneira.

968
00: 44: 51,110 -> 00: 44: 53.800
Mas faz isso de uma forma mais bonita, geralmente mais sucinta.

969
00: 44: 53,800 -> 00: 44: 56.680
E é mais comum escrever linhas de código como esta.

970
00: 44: 56,680 -> 00: 44: 58.430
Tudo bem, vamos considerar outro exemplo.

971
00: 44: 58,430 -> 00: 45: 01.750
Isso foi chamado de quê no Scratch?

972
00: 45: 01,750 -> 00: 45: 03.980
Sim, uma condição, uma decisão que você tem que tomar.

973
00: 45: 03,980 -> 00: 45: 06.310
Portanto, se algo for verdade, faça isso.

974
00: 45: 06,310 -> 00: 45: 08.720
Em C, podemos convertê-lo da seguinte maneira.

975
00: 45: 08,720 -> 00: 45: 11.260
Se x menor que y entre parênteses -

976
00: 45: 11,260 -> 00: 45: 15.300
que não é bem a forma angular que temos aqui em verde, mas em C,

977
00: 45: 15,300 -> 00: 45: 16.780
você usa parênteses aqui.

978
00: 45: 16,780 -> 00: 45: 20.380
Portanto, se x for menor que y, abre parênteses, fecha parênteses,

979
00: 45: 20,380 -> 00: 45: 21.970
então vá em frente e faça o seguinte.

980
00: 45: 21,970 -> 00: 45: 25.720
E assim como esta peça amarela ou laranja do quebra-cabeça parece que está

981
00: 45: 25,720 -> 00: 45: 29.920
abraçando a peça roxa do quebra-cabeça, esta chave aberta também

982
00: 45: 29,920 -> 00: 45: 32.830
e esta chave fechada, por assim dizer, está meio que lá

983
00: 45: 32,830 -> 00: 45: 36.050
pronta para abraçar ou encapsular uma ou mais linhas de código.

984
00: 45: 36,050 -> 00: 45: 37.090
Qual é a linha de código?

985
00: 45: 37,090 -> 00: 45: 42.640
Pode ser algo assim - printf x é menor que y barra invertida n.

986
00: 45: 42,640 -> 00: 45: 47.080
Então, novamente, nova sintaxe, mas vimos as chaves antes

987
00: 45: 47,080 -> 00: 45: 48.490
no contexto de principal.

988
00: 45: 48,490 -> 00: 45: 52.280
E vimos parênteses antes no contexto de entradas.

989
00: 45: 52,280 -> 00: 45: 54.520
Portanto, este é apenas um tipo de padrão que iremos

990
00: 45: 54,520 -> 00: 45: 58.530
comece a seguir em C sempre que quisermos fazer algo condicionalmente.

991
00: 45: 58,530 -> 00: 46: 01.000
OK, no Scratch, vimos algo assim -

992
00: 46: 01.000 -> 00: 46: 04.300
se x for menor que y, então digamos que x seja menor que y.

993
00: 46: 04,300 -> 00: 46: 06.730
Caso contrário, conclua que x não é menor que y.

994
00: 46: 06,730 -> 00: 46: 11.380
Em C, quase parece o mesmo, mas você mesmo deve montar o bloco "else"

995
00: 46: 11,380 -> 00: 46: 15.010
com dois conjuntos de chaves, meio que dois caracteres prontos para abraçar

996
00: 46: 15,010 -> 00: 46: 16.600
as linhas de código entre eles.

997
00: 46: 16,600 -> 00: 46: 19.660
E podemos apenas inserir agora, literalmente, as traduções para o printf

998
00: 46: 19,660 -> 00: 46: 25.060
dizendo que printf x é menor que y ou printf x não é menor que y.

999
00: 46: 25,060 -> 00: 46: 28.450
Agora, observe, há apenas dois pontos e vírgulas neste exemplo.

1000
00: 46: 28,450 -> 00: 46: 33.430
Geralmente, você não termina coisas como condições com ponto e vírgula.

1001
00: 46: 33,430 -> 00: 46: 37.690
Você termina funções ou linhas que envolvem funções com ponto e vírgula.

1002
00: 46: 37,690 -> 00: 46: 39.850
E essa não é uma regra que vale para tudo, mas você

1003
00: 46: 39,850 -> 00: 46: 42.490
não quer linhas de código - você não quer ponto e vírgula

1004
00: 46: 42,490 -> 00: 46: 43.870
após cada linha de código.

1005
00: 46: 43,870 -> 00: 46: 45.855
Você geralmente quer depois de alguma ação.

1006
00: 46: 45,855 -> 00: 46: 48.730
E você começará a notar esse padrão, embora talvez não seja

1007
00: 46: 48,730 -> 00: 46: 50.560
óbvio no início.

1008
00: 46: 50,560 -> 00: 46: 52.260
Certo, que tal esse?

1009
00: 46: 52,260 -> 00: 46: 55.090
If, else if, else if.

1010
00: 46: 55.090 -> 00: 46: 58.900
Agora, observe que estamos apenas reutilizando o bloco if-else if e depois outro

1011
00: 46: 58,900 -> 00: 47: 00.250
bloco if aqui.

1012
00: 47: 00,250 -> 00: 47: 02.500
Acontece que em C, é quase um pouco mais fácil.

1013
00: 47: 02,500 -> 00: 47: 04.120
Você pode literalmente apenas dizer isso -

1014
00: 47: 04,120 -> 00: 47: 07.060
se x for menor que y, faça isso com chaves.

1015
00: 47: 07,060 -> 00: 47: 10.220
Caso contrário, se x for maior do que y, faça isso entre chaves.

1016
00: 47: 10,220 -> 00: 47: 14.160
Caso contrário, se x for igual a y, faça isso entre chaves.

1017
00: 47: 14,160 -> 00: 47: 16.050
E o que você quer fazer em cada caso?

1018
00: 47: 16,050 -> 00: 47: 20.560
Printf's diferentes com base nas mensagens que queremos exibir.

1019
00: 47: 20,560 -> 00: 47: 23.220
Mas há uma curiosidade aqui.

1020
00: 47: 23,220 -> 00: 47: 26.550
Quase parece um erro de digitação.

1021
00: 47: 26,550 -> 00: 47: 28.278
Sim, o duplo sinal de igual.

1022
00: 47: 28,278 -> 00: 47: 29.070
Mas não é um bug.

1023
00: 47: 29,070 -> 00: 47: 29.940
Não é um engano.

1024
00: 47: 29,940 -> 00: 47: 35.070
Por que estou usando dois iguais aqui em vez de um único sinal de igual,

1025
00: 47: 35,070 -> 00: 47: 36.990
como no Scratch?

1026
00: 47: 36,990 -> 00: 47: 37.980
Deixe-me detalhar aqui.

1027
00: 47: 37,980 -> 00: 47: 38.687
Sim?

1028
00: 47: 38,687 -> 00: 47: 42.335
PÚBLICO: [INAUDÍVEL].

1029
00: 47: 42,335 -> 00: 47: 43.210
DAVID MALAN: Exatamente.

1030
00: 47: 43,210 -> 00: 47: 46.420
Eu disse anteriormente que o único sinal de igual é usado para atribuição da direita

1031
00: 47: 46,420 -> 00: 47: 47.140
para a esquerda.

1032
00: 47: 47,140 -> 00: 47: 49.120
E honestamente, esta é apenas uma situação humana, onde

1033
00: 47: 49,120 -> 00: 47: 50.590
nós nos colocamos em um canto.

1034
00: 47: 50,590 -> 00: 47: 53.050
Já usamos o sinal de igual para atribuição.

1035
00: 47: 53,050 -> 00: 47: 56.570
Então, presumivelmente, algum humano percebeu: "A, nossa, como vamos fazer a pergunta,

1036
00: 47: 56,570 -> 00: 47: 57.808
isso é igual a isso?"

1037
00: 47: 57.808 -> 00: 47: 59.350
Bem, já usamos esse símbolo.

1038
00: 47: 59,350 -> 00: 48: 01.510
Então, os humanos, décadas atrás, decidiram, tudo bem,

1039
00: 48: 01,510 -> 00: 48: 05.200
vamos resolver esse problema usando apenas dois sinais de iguais lado a lado.

1040
00: 48: 05,200 -> 00: 48: 07.690
Portanto, este é o chamado operador de igualdade.
1041
00: 48: 07,690 -> 00: 48: 09.633
Um único sinal de igual é apenas a atribuição.

1042
00: 48: 09,633 -> 00: 48: 12.550
Este é, sem dúvida, um dos erros mais comuns de se cometer no início,

1043
00: 48: 12,550 -> 00: 48: 15.730
especialmente se você usa Scratch ou outras linguagens de antemão.

1044
00: 48: 15,730 -> 00: 48: 18.880
E você só consegue desenvolver a memória muscular ao longo do tempo.

1045
00: 48: 18,880 -> 00: 48: 22.030
Depois que você cometer esse erro algumas vezes, ele desaparecerá.

1046
00: 48: 22,030 -> 00: 48: 24.010
Tudo bem, mas acontece que este programa,

1047
00: 48: 24,010 -> 00: 48: 26.530
embora indiscutivelmente correto - ou este código, embora correto,

1048
00: 48: 26,530 -> 00: 48: 30.340
em que vai fazer isso ou isso ou aquilo - e eu acho que aqueles

1049
00: 48: 30,340 -> 00: 48: 31.960
são as três situações possíveis.

1050
00: 48: 31,960 -> 00: 48: 37.090
Se você tiver dois inteiros, x e y, x é menor que y, maior que y,

1051
00: 48: 37,090 -> 00: 48: 38.530
ou igual a y.

1052
00: 48: 38,530 -> 00: 48: 42.490
Mas uma dessas questões tecnicamente não precisa ser feita.

1053
00: 48: 42,490 -> 00: 48: 45.400
Há tecnicamente três expressões booleanas aqui, certo -

1054
00: 48: 45,400 -> 00: 48: 49.098
x menor que y, x maior que y, x é igual a y.

1055
00: 48: 49,098 -> 00: 48: 50.890
Uma expressão booleana, lembre-se, é uma pergunta

1056
00: 48: 50,890 -> 00: 48: 56.170
que tem uma resposta sim / não ou uma resposta verdadeiro / falso ou uma resposta 1/0.

1057
00: 48: 56,170 -> 00: 48: 59.560
Mas não preciso fazer três perguntas aqui, preciso?

1058
00: 48: 59,560 -> 00: 49: 00.920
Acho que vi sua mão.

1059
00: 49: 00,920 -> 00: 49: 01.654
Por que não?

1060
00: 49: 01,654 -> 00: 49: 05.920
PÚBLICO: Bem, porque se x for menor que [INAUDÍVEL] ..

1061
00: 49: 05,920 -> 00: 49: 09.975


1062
00: 49: 09,975 -> 00: 49: 10.850
DAVID MALAN: Exatamente.

1063
00: 49: 10.850 -> 00: 49: 14.570
Esta terceira pergunta, esta expressão booleana, x é igual a y,

1064
00: 49: 14,570 -> 00: 49: 16.700
nem é preciso dizer logicamente.

1065
00: 49: 16,700 -> 00: 49: 19.655
Porque se x não é menor que, e não é maior que,

1066
00: 49: 19,655 -> 00: 49: 22.280
se for apenas [INAUDÍVEL] o único outro cenário que consigo pensar

1067
00: 49: 22,280 -> 00: 49: 24.020
é que é igual a y.

1068
00: 49: 24,020 -> 00: 49: 28.550
Portanto, podemos realmente simplificar o código Scratch e o código C

1069
00: 49: 28,550 -> 00: 49: 31.978
apenas por ter essa condição "else" abaixo.

1070
00: 49: 31,978 -> 00: 49: 33.770
Então, conversaremos nas próximas semanas,

1071
00: 49: 33,770 -> 00: 49: 36.230
sobre diferentes qualidades de código.

1072
00: 49: 36,230 -> 00: 49: 38.480
Acertividade, tal como, isso faz o que deveria fazer?

1073
00: 49: 38,480 -> 00: 49: 42.770
mas também a qualidade do design, como você escreveu este código tão eficientemente quanto

1074
00: 49: 42,770 -> 00: 49: 45.530
possível, o mais rápido possível, de uma forma que

1075
00: 49: 45,530 -> 00: 49: 49.160
usa a menor quantidade de memória e a menor quantidade de CPU,

1076
00: 49: 49,160 -> 00: 49: 50.420
o cérebro do computador?

1077
00: 49: 50,420 -> 00: 49: 54.047
E isso é apenas uma alusão a esse tipo de capacidade.

1078
00: 49: 54,047 -> 00: 49: 55.880
Tudo bem, apenas mais algumas comparações

1079
00: 49: 55,880 -> 00: 49: 58.070
antes de voltarmos a escrever algum código.

1080
00: 49: 58,070 -> 00: 49: 59.397
Que tal algo como isso?

1081
00: 49: 59,397 -> 00: 50: 02.480
No Scratch, nós, é claro, chamamos isso de loop - um ciclo que acontece novamente

1082
00: 50: 02,480 -> 00: 50: 03.740
e novamente e novamente.

1083
00: 50: 03,740 -> 00: 50: 08.120
E um loop como este pode ser implementado em C não da mesma maneira,

1084
00: 50: 08,120 -> 00: 50: 09.080
mas assim.

1085
00: 50: 09,080 -> 00: 50: 11.480
Acontece que a palavra mais próxima da palavra

1086
00: 50: 11,480 -> 00: 50: 14.820
"forever/para sempre" no Scratch é a palavra "while/enquanto".

1087
00: 50: 14,820 -> 00: 50: 17.900
Isso meio que sugere a ideia de fazer algo repetidamente.

1088
00: 50: 17,900 -> 00: 50: 20.330
Esta foi a palavra que os humanos escolheram anos atrás.

1089
00: 50: 20,330 -> 00: 50: 22.280
Mas você não diz apenas "while/enquanto".

1090
00: 50: 22,280 -> 00: 50: 26.090
Você tem que dizer não só o que você quer fazer para sempre,

1091
00: 50: 26,090 -> 00: 50: 29.910
mas você precisa responder a uma expressão booleana.

1092
00: 50: 29,910 -> 00: 50: 32.540
Então, em C, se você deseja implementar um loop,

1093
00: 50: 32,540 -> 00: 50: 36.090
você precisa literalmente ser capaz de dizer enquanto algo é verdade.

1094
00: 50: 36,090 -> 00: 50: 40.850
Você precisa fazer uma pergunta cuja resposta seja um sim ou verdadeiro ou 1.

1095
00: 50: 40,850 -> 00: 50: 42.980
Todos esses são equivalentes a um programador.

1096
00: 50: 42,980 -> 00: 50: 46.130
Então, o que é um exemplo de uma expressão, uma expressão booleana,

1097
00: 50: 46,130 -> 00: 50: 49.990
isso é sempre verdade, se meu objetivo é fazer algo para sempre?

1098
00: 50: 49,990 -> 00: 50: 51.173
PÚBLICO: Cinco é igual a cinco.

1099
00: 50: 51,173 -> 00: 50: 53.340
DAVID MALAN: cinco é igual a cinco, certo.

1100
00: 50: 53,340 -> 00: 50: 55.220
Eu poderia fazer quatro é igual a quatro.

1101
00: 50: 55,220 -> 00: 50: 56.930
Eu poderia fazer dois é maior que um.

1102
00: 50: 56,930 -> 00: 50: 59.030
Eu poderia fazer um é menor do que dois.

1103
00: 50: 59,030 -> 00: 51: 01.640
Eu poderia chegar a um número infinito de expressões booleanas

1104
00: 51: 01,640 -> 00: 51: 03.800
que logicamente são sempre verdadeiros.

1105
00: 51: 03,800 -> 00: 51: 07.070
Mas a maneira mais simples é dizer literalmente a "true/verdadeiro".

1106
00: 51: 07,070 -> 00: 51: 09.050
É um pouco hackeado, mas talvez seja

1107
00: 51: 09,050 -> 00: 51: 12.440
a pergunta mais simples que você pode fazer, porque é "true", por definição,

1108
00: 51: 12,440 -> 00: 51: 16.520
Acontece que é sempre "verdadeiro", assim como falso é sempre falso.

1109
00: 51: 16,520 -> 00: 51: 19.310
E então posso literalmente apenas dizer enquanto verdadeiro para

1110
00: 51: 19,310 -> 00: 51: 24.008
induzir um loop infinito, por assim dizer, que faz algo para sempre.

1111
00: 51: 24,008 -> 00: 51: 26.300
Tudo bem, vamos tentar outro tipo de construção de loop.

1112
00: 51: 26,300 -> 00: 51: 28.192
Este foi um loop que fez algo 50 vezes.

1113
00: 51: 28,192 -> 00: 51: 30.275
Neste, agora temos que ser um pouco mais espertos,

1114
00: 51: 30,275 -> 00: 51: 32.360
e temos que ligar as coisas.

1115
00: 51: 32,360 -> 00: 51: 35.120
Então, se eu quiser fazer algo 50 vezes, aqui está uma maneira.

1116
00: 51: 35,120 -> 00: 51: 37.850
Por que não me dou uma variável e a chamo de contador?

1117
00: 51: 37,850 -> 00: 51: 40.760
Mas eu poderia chamá-lo do que quiser e inicializá-lo como zero.

1118
00: 51: 40,760 -> 00: 51: 42.980
Então, deixe-me ir em frente - sabe de uma coisa?

1119
00: 51: 42,980 -> 00: 51: 44.510
Counter é realmente muito prolixo.

1120
00: 51: 44,510 -> 00: 51: 46.490
A maioria dos programadores, quando estão apenas contando,

1121
00: 51: 46,490 -> 00: 51: 49.557
eles, por convenção, apenas usam a letra i, i para inteiro.

1122
00: 51: 49,557 -> 00: 51: 51.140
Mas você pode chamá-lo do que quiser.

1123
00: 51: 51,140 -> 00: 51: 53.810
Vou chamá-lo de int i igual a zero.

1124
00: 51: 53,810 -> 00: 51: 56.990
Em seguida, vou prosseguir e fazer o seguinte.

1125
00: 51: 56,990 -> 00: 51: 59.840
"while" a seguinte expressão seja verdadeira, deixe-me apenas

1126
00: 51: 59,840 -> 00: 52: 01.790
fazer uma pergunta de novo e de novo...

1127
00: 52: 01,790 -> 00: 52: 06.170
Enquanto i for menor que 50, vou em frente dizendo, "hello world".

1128
00: 52: 06,170 -> 00: 52: 09.300
Então posso imprimir, olá, mundo.

1129
00: 52: 09,300 -> 00: 52: 12.260
Mas ainda não terminei de construir essa lógica.

1130
00: 52: 12,260 -> 00: 52: 14.330
Inicializei uma variável com zero.

1131
00: 52: 14,330 -> 00: 52: 18.380
Vou, repetidamente, fazer a pergunta: i é menor que 50?

1132
00: 52: 18,380 -> 00: 52: 21.530
Mas para que isso funcione logicamente, que outro pedaço de lógica

1133
00: 52: 21,530 -> 00: 52: 24.360
eu preciso adicionar ao código?

1134
00: 52: 24,360 -> 00: 52: 25.916
Sim?

1135
00: 52: 25,916 -> 00: 52: 27.810
PÚBLICO: Você tem que aumentar i em um.

1136
00: 52: 27,810 -> 00: 52: 29.530
DAVID MALAN: Sim, tenho que incrementar i, certo?

1137
00: 52: 29,530 -> 00: 52: 30.770
Então, mesmo que você não se lembre -

1138
00: 52: 30,770 -> 00: 52: 33.130
e tudo bem - a sintaxe para fazer isso, você vai

1139
00: 52: 33,130 -> 00: 52: 35.090
precisar de uma linha de código como esta.

1140
00: 52: 35,090 -> 00: 52: 38.710
Então, logicamente, você vai fazer o seguinte - definir i igual a zero,

1141
00: 52: 38,710 -> 00: 52: 41.120
e, em seguida, faça o seguinte enquanto i for menor que 50.

1142
00: 52: 41,120 -> 00: 52: 42.430
Bem, i é menor que 50?

1143
00: 52: 42,430 -> 00: 52: 45.200
Obviamente, porque 0 é menor que 50.

1144
00: 52: 45,200 -> 00: 52: 46.660
Então você imprime, olá, mundo.

1145
00: 52: 46,660 -> 00: 52: 48.820
E então, como vocês disseram, precisamos incrementar i.

1146
00: 52: 48,820 -> 00: 52: 51.290
Portanto, agora i é igual a i mais 1.

1147
00: 52: 51,290 -> 00: 52: 53.980
Portanto, neste ponto da história, i é igual a 1.

1148
00: 52: 53,980 -> 00: 52: 57.430
E agora a forma como o código funciona, muito parecido com o nosso pseudo código da semana passada,

1149
00: 52: 57,430 -> 00: 53: 00.220
é você meio que implicitamente voltar a esta linha.

1150
00:53:00,220 --> 00:53:04,010
Last week, in pseudocode, I literally said, go back to line 3.

1151
00:53:04,010 --> 00:53:09,460
Here, it happens automatically by nature of how C interprets these lines of code

1152
00:53:09,460 --> 00:53:10,720
in these curly braces.

1153
00:53:10,720 --> 00:53:12,980
And I can actually simplify this as follows.

1154
00:53:12,980 --> 00:53:14,568
I can say i plus plus.

1155
00:53:14,568 --> 00:53:17,110
Now, it's not quite as pretty as Scratch, where you just say,

1156
00:53:17,110 --> 00:53:18,760
repeat the following 50 times.

1157
00:53:18,760 --> 00:53:22,630
But using the principles of last week now translated to C,

1158
00:53:22,630 --> 00:53:24,760
you can kind of wire together your own logic that

1159
00:53:24,760 --> 00:53:27,610
does something any number of times.

1160
00:53:27,610 --> 00:53:30,430
And there's one other way to do this, just so you've seen it here.

1161
00:53:30,430 --> 00:53:33,850
It turns out that a more common way to do something a fixed number of times

1162
00:53:33,850 --> 00:53:36,430
is using a different preposition-- the word for.

1163
00:53:36,430 --> 00:53:38,710
And a for loop looks like this.

1164
00:53:38,710 --> 00:53:43,180
A for loop does something, like print out hello world, again and again,

1165
00:53:43,180 --> 00:53:44,740
but it's even more mechanical.

1166
00:53:44,740 --> 00:53:48,580
But it automates into one line of code the exact same logic

1167
00:53:48,580 --> 00:53:50,020
we just implemented.

1168
00:53:50,020 --> 00:53:52,362
After the word for, you can put parentheses.

1169
00:53:52,362 --> 00:53:54,070
And then inside of those parentheses, you

1170
00:53:54,070 --> 00:53:56,740
can say something like, give me a variable called counter

1171
00:53:56,740 --> 00:53:58,180
and initialize it to zero.

1172
00:53:58,180 --> 00:53:59,410
Or that's a little wordy.

1173
00:53:59,410 --> 00:54:00,760
Let's just use i.

1174
00:54:00,760 --> 00:54:04,540
So that is identical, logically, to what we did a moment ago.

1175
00:54:04,540 --> 00:54:09,190
But the for loop actually takes one, two, three inputs inside

1176
00:54:09,190 --> 00:54:10,000
of its parentheses.

1177
00:54:10,000 --> 00:54:12,520
It's a little funky in terms of its syntax.

1178
00:54:12,520 --> 00:54:15,790
The second input to the for loop is the Boolean expression

1179
00:54:15,790 --> 00:54:20,380
you want to ask again and again and again, so is i less than 50?

1180
00:54:20,380 --> 00:54:22,900
And the last thing that you can do in a for loop

1181
00:54:22,900 --> 00:54:27,410
is this third input, where you can do your update of one or more variables.

1182
00:54:27,410 --> 00:54:32,830
So if I do i equals i plus 1 or, more succinctly, i plus equals 1,

1183
00:54:32,830 --> 00:54:36,700
or even more so tersely, i plus plus, I have now

1184
00:54:36,700 --> 00:54:40,210
whittled down to just four lines of code what I previously

1185
00:54:40,210 --> 00:54:42,440
did in a few more lines of code.

1186
00:54:42,440 --> 00:54:43,660
These are both correct.

1187
00:54:43,660 --> 00:54:45,800
They both do exactly the same thing.

1188
00:54:45,800 --> 00:54:49,580
And even though the for loop is a little non-obvious-- because this is step one,

1189
00:54:49,580 --> 00:54:52,090
this is step two, this is step three, then

1190
00:54:52,090 --> 00:54:54,265
in increments-- it achieves the same result.

1191
00:54:54,265 --> 00:54:56,890
And you'll play with this over time in the next couple of weeks

1192
00:54:56,890 --> 00:54:58,510
when doing something again and again.

1193
00:54:58,510 --> 00:55:02,830
But it's just a more succinct way of achieving that same goal.

1194
00:55:02,830 --> 00:55:06,940
Any questions, then, on while loops or for loops here?

1195
00:55:06,940 --> 00:55:09,990


1196
00:55:09,990 --> 00:55:15,180
All right, so let's look at one final set of definitions.

1197
00:55:15,180 --> 00:55:18,510
It turns out that in C, we have a whole list of data types

1198
00:55:18,510 --> 00:55:20,210
besides just strings and besides ints.

1199
00:55:20,210 --> 00:55:22,260
And we'll see these and use these over time.

1200
00:55:22,260 --> 00:55:26,320
You can have a bool, so to speak, which is literally the value true or false.

1201
00:55:26,320 --> 00:55:29,620
And we use that implicitly earlier when I just said while true.

1202
00:55:29,620 --> 00:55:34,140
You can have a char, or character, which is a single character, not two or more

1203
00:55:34,140 --> 00:55:34,920
or a phrase.

1204
00:55:34,920 --> 00:55:39,390
It's just like the letter Y or N if you're asking the question yes or no.

1205
00:55:39,390 --> 00:55:42,720
You can have an int, of course, which is an integer, a string, which

1206
00:55:42,720 --> 00:55:44,940
is one or more characters inside of double quotes.

1207
00:55:44,940 --> 00:55:47,670
So it's bigger than an individual char, typically.

1208
00:55:47,670 --> 00:55:49,650
And then there's a few other data types--

1209
00:55:49,650 --> 00:55:50,700
int and long.

1210
00:55:50,700 --> 00:55:52,890
So int is typically a certain size.

1211
00:55:52,890 --> 00:55:55,260
You can only count so high with an int.

1212
00:55:55,260 --> 00:55:58,110
Typically, you can count as high as 4 billion with an int,

1213
00:55:58,110 --> 00:56:00,610
and that's not big enough for certain applications.

1214
00:56:00,610 --> 00:56:03,330
Today's biggest companies like Facebook and Microsoft and Google

1215
00:56:03,330 --> 00:56:06,240
have many more pieces of data than 4 billion.

1216
00:56:06,240 --> 00:56:10,030
So there exist things called long, which actually use more bits.

1217
00:56:10,030 --> 00:56:12,640
They're wider values, so they can count even higher.

1218
00:56:12,640 --> 00:56:14,940
A float is a floating point value, which is

1219
00:56:14,940 --> 00:56:18,390
a fancy way of saying a real number, something that has a decimal point.

1220
00:56:18,390 --> 00:56:23,130
And a double is just a real number that can have even more digits

1221
00:56:23,130 --> 00:56:24,790
after the decimal point.

1222
00:56:24,790 --> 00:56:26,370
So we'll see those before long.

1223
00:56:26,370 --> 00:56:28,950
Well, what other features does the CS50 the library provide?

1224
00:56:28,950 --> 00:56:31,320
It gives you not only the function get_string,

1225
00:56:31,320 --> 00:56:35,567
we'll see a few others like get_int or get_float or get_double or get_char.

1226
00:56:35,567 --> 00:56:37,650
These are all functions that will prompt the human

1227
00:56:37,650 --> 00:56:42,360
with the blinking prompt for certain values that they might want to provide.

1228
00:56:42,360 --> 00:56:44,540
And then for placeholders, let's round this out.

1229
00:56:44,540 --> 00:56:48,090
Printf, recall, had a placeholder for percent s for a string.

1230
00:56:48,090 --> 00:56:50,580
Turns out there's a few other placeholders, as well.

1231
00:56:50,580 --> 00:56:53,520
If you want to plug in an int, we're going to start using percent i.

1232
00:56:53,520 --> 00:56:55,920
If you want to plug in a float-- that is, a real number--

1233
00:56:55,920 --> 00:56:57,350
you're going to use percent f.

1234
00:56:57,350 --> 00:57:00,390
And there's a couple of other format codes, as well.

1235
00:57:00,390 --> 00:57:02,430
But we've seen just one of those thus far.

1236
00:57:02,430 --> 00:57:05,010
And then in terms of arithmetic operations,

1237
00:57:05,010 --> 00:57:07,290
you can do a lot of mathematics very simply.

1238
00:57:07,290 --> 00:57:09,540
And we'll do just a couple of examples, literally just

1239
00:57:09,540 --> 00:57:13,320
by using the characters that you might be inclined to type on the screen.

1240
00:57:13,320 --> 00:57:18,603
So, in short, suppose that we want to go ahead and write one program of our own.

1241
00:57:18,603 --> 00:57:21,270
We can use any number of these functions-- get_int and get_float

1242
00:57:21,270 --> 00:57:22,240
and get_more.

1243
00:57:22,240 --> 00:57:24,990
But before that, let's go ahead and take a five-minute break here,

1244
00:57:24,990 --> 00:57:26,865
because that was quite the fire hose, indeed.

1245
00:57:26,865 --> 00:57:30,570
Cookies await in the lobby outside, and we'll resume in five minutes.

1246
00:57:30,570 --> 00:57:36,420
So we are back, and now we begin focusing not just on comparisons

1247
00:57:36,420 --> 00:57:39,090
of C with Scratch, but on actually writing

1248
00:57:39,090 --> 00:57:42,960
some code from Scratch but in C. And the goal at hand

1249
00:57:42,960 --> 00:57:46,050
really is to begin to develop the muscle memory via which

1250
00:57:46,050 --> 00:57:49,860
you can start with literally empty files and start to fill it

1251
00:57:49,860 --> 00:57:54,090
with C implementations of your ideas.

1252
00:57:54,090 --> 00:57:57,660
So rest assured that all of the examples we're about to do live

1253
00:57:57,660 --> 00:57:59,670
are already pre-baked online, so you'll be

1254
00:57:59,670 --> 00:58:02,580
able to download all of these examples from the course's website.

1255
00:58:02,580 --> 00:58:05,632
In Brian's super section will you be able to explore them in more detail.

1256
00:58:05,632 --> 00:58:07,590
And later this week will you have opportunities

1257
00:58:07,590 --> 00:58:11,020
hands-on to work on these same types of programs, as well.

1258
00:58:11,020 --> 00:58:16,140
For now, the overarching goal is exposure and concepts and the beginning

1259
00:58:16,140 --> 00:58:18,270
of developing that muscle memory.

1260
00:58:18,270 --> 00:58:21,947
So with that said, let me go ahead and create a new file called int.c,

1261
00:58:21,947 --> 00:58:24,780
the purpose of which is going to be to get an integer from the user,

1262
00:58:24,780 --> 00:58:28,530
much like a bit ago I got a string from the user.

1263
00:58:28,530 --> 00:58:30,630
I'm going to go ahead and, as before, I'm

1264
00:58:30,630 --> 00:58:32,410
going to include some familiar files.

1265
00:58:32,410 --> 00:58:35,012
So I'm going to go ahead and include preemptively CS50.h

1266
00:58:35,012 --> 00:58:37,830
so that have I access to strings and get_string

1267
00:58:37,830 --> 00:58:40,800
and get_int and get_float and other features, as well.

1268
00:58:40,800 --> 00:58:43,890
I'm going to include stdio.h so that I have access to printf

1269
00:58:43,890 --> 00:58:45,780
so I can actually see what we're doing.

1270
00:58:45,780 --> 00:58:48,600
Then I'm going to do this, which again, for today's purposes

1271
00:58:48,600 --> 00:58:51,150
and for a couple of weeks, is just kind of copy/paste.

1272
00:58:51,150 --> 00:58:54,090
This is the equivalent of when green flag clicked,

1273
00:58:54,090 --> 00:58:57,240
but we'll explain, in a couple of weeks, exactly why you're writing int

1274
00:58:57,240 --> 00:58:59,235
and why you're writing void.

1275
00:58:59,235 --> 00:59:01,110
In here, I'm going to do something like this.

1276
00:59:01,110 --> 00:59:03,360
This time, I want to get not a string but an int.

1277
00:59:03,360 --> 00:59:08,320
So let's do in age get get_int, what's your age?

1278
00:59:08,320 --> 00:59:10,860
Now, to be fair, I can probably type that pretty quickly,

1279
00:59:10,860 --> 00:59:13,650
because I have the muscle memory already for programming in C.

1280
00:59:13,650 --> 00:59:16,150
But if we look at it real methodically for a moment,

1281
00:59:16,150 --> 00:59:19,540
this is just another function, get_int, from the CS50 library that's

1282
00:59:19,540 --> 00:59:20,800
going to get an integer.

1283
00:59:20,800 --> 00:59:22,550
This is the prompt that the human is going

1284
00:59:22,550 --> 00:59:25,862
to see with their cursor moving to a new line because of the backslash n.

1285
00:59:25,862 --> 00:59:27,570
And whatever they type in is going to get

1286
00:59:27,570 --> 00:59:31,350
copied from right to left into a variable called age, the type of which,

1287
00:59:31,350 --> 00:59:34,140
so to speak, is int, or integer.

1288
00:59:34,140 --> 00:59:37,717
Now let me go ahead and compute, like, how many days old this person is.

1289
00:59:37,717 --> 00:59:40,050
So if I want to do that, I could do something like this.

1290
00:59:40,050 --> 00:59:41,490
Well, give me an integer.

1291
00:59:41,490 --> 00:59:42,780
Call it days.

1292
00:59:42,780 --> 00:59:45,602
And then just do age times 365.

1293
00:59:45,602 --> 00:59:47,310
I proposed a bit ago that there's a bunch

1294
00:59:47,310 --> 00:59:49,830
of arithmetic operators like plus and minus

1295
00:59:49,830 --> 00:59:53,850
and multiplication and subtraction and even the remainder operator.

1296
00:59:53,850 --> 00:59:58,680
So this line, 7, just says multiply age by 365.

1297
00:59:58,680 --> 01:00:02,800
Copy that value, from right to left, into a new variable called days.

1298
01:00:02,800 --> 01:00:04,800
And now I can go ahead and print this if I want.

1299
01:00:04,800 --> 01:00:09,090
So printf something like, you are at least percent--

1300
01:00:09,090 --> 01:00:13,620
not s, because it's not a string, but percent i because it's an integer now--

1301
01:00:13,620 --> 01:00:15,900
days old, backslash n.

1302
01:00:15,900 --> 01:00:18,190
But again, this is a placeholder, so I'm not done yet.

1303
01:00:18,190 --> 01:00:23,580
What do I need to put inside of these parentheses also on line 8?

1304
01:00:23,580 --> 01:00:27,990
Yeah, so comma, days, if that's the value that I want to plug in.

1305
01:00:27,990 --> 01:00:29,377
And I'm missing one more thing.

1306
01:00:29,377 --> 01:00:30,210
AUDIENCE: Semicolon.

1307
01:00:30,210 --> 01:00:32,127
DAVID MALAN: Semicolon at the end of the line.

1308
01:00:32,127 --> 01:00:33,503
Now, hopefully, I got this right.

1309
01:00:33,503 --> 01:00:35,670
But odds are the first time you write your programs,

1310
01:00:35,670 --> 01:00:37,150
you're going to see error messages.

1311
01:00:37,150 --> 01:00:41,040
But let's see, make int is the quickest way now to compile this code.

1312
01:00:41,040 --> 01:00:41,850
Enter.

1313
01:00:41,850 --> 01:00:43,860
All right, the big, long white command is OK.

1314
01:00:43,860 --> 01:00:47,490
So long as you don't see red or yellow or colored output that indicates

1315
01:00:47,490 --> 01:00:49,590
warnings or errors, you should be OK.

1316
01:00:49,590 --> 01:00:53,910
I'm going to clear my screen now so I can just now run this program, ./int.

1317
01:00:53,910 --> 01:00:56,150
And suppose your age is, say, 50.

1318
01:00:56,150 --> 01:01:00,422
Well, you are at least 18,250 days old.

1319
01:01:00,422 --> 01:01:03,630
But let me use this as an opportunity to not just do something correct, which

1320
01:01:03,630 --> 01:01:06,690
I claim this code is, but to just make it better designed.

1321
01:01:06,690 --> 01:01:11,580
It's fine to be storing this value, age, in a variable called age.

1322
01:01:11,580 --> 01:01:13,950
And it's fine to be creating a second variable called

1323
01:01:13,950 --> 01:01:19,300
days, in which my mathematical answer is age times 365.

1324
01:01:19,300 --> 01:01:22,530
But strictly speaking, I don't need that additional line of code.

1325
01:01:22,530 --> 01:01:26,520
I could also just do age times 365 here.

1326
01:01:26,520 --> 01:01:27,660
So C is nice like that.

1327
01:01:27,660 --> 01:01:32,370
You can compose, just like in Scratch, bigger ideas from multiple smaller

1328
01:01:32,370 --> 01:01:33,090
pieces.

1329
01:01:33,090 --> 01:01:35,550
And frankly, if I really want to get crazy,

1330
01:01:35,550 --> 01:01:38,040
notice I can actually highlight that whole function

1331
01:01:38,040 --> 01:01:42,000
call, so to speak, get rid of the age all together,

1332
01:01:42,000 --> 01:01:49,330
and just plug this in here times 365.

1333
01:01:49,330 --> 01:01:53,190
But at this point, we're starting to cross an inflection point.

1334
01:01:53,190 --> 01:01:55,342
Yes, this is correct, because I, strictly speaking,

1335
01:01:55,342 --> 01:01:56,550
don't need a variable, right?

1336
01:01:56,550 --> 01:01:58,020
I can pass-- we saw last week--

1337
01:01:58,020 --> 01:02:00,870
one function's output as another function's input

1338
01:02:00,870 --> 01:02:02,540
by just nesting them in this way.

1339
01:02:02,540 --> 01:02:05,040
But honestly, now we're at the point where this line of code

1340
01:02:05,040 --> 01:02:08,080
is so relatively long, it's just too hard to read.

1341
01:02:08,080 --> 01:02:10,830
And so this is an example where, for design's sake, you know what?

1342
01:02:10,830 --> 01:02:13,210
The previous version was probably a bit better,

1343
01:02:13,210 --> 01:02:16,950
because I can read the code more top to bottom than left to right.

1344
01:02:16,950 --> 01:02:18,900
But this is a design decision.

1345
01:02:18,900 --> 01:02:21,000
And indeed, you might agree or disagree.

1346
01:02:21,000 --> 01:02:24,420
You might agree or disagree with your teaching fellow, or TF, ultimately.

1347
01:02:24,420 --> 01:02:28,770
These are the kinds of decisions that go into writing good or bad code

1348
01:02:28,770 --> 01:02:30,300
or good or better code.

1349
01:02:30,300 --> 01:02:33,000
Much like in an English essay or in any written language,

1350
01:02:33,000 --> 01:02:36,030
you could argue that one person has written their document better

1351
01:02:36,030 --> 01:02:36,730
than another.

1352
01:02:36,730 --> 01:02:40,140
So we'll begin to appreciate these nuances over time.

1353
01:02:40,140 --> 01:02:41,310
What about float?

1354
01:02:41,310 --> 01:02:45,758
Well, let me go ahead and write another program real quick called float.c.

1355
01:02:45,758 --> 01:02:47,550
And this one is going to use floating point

1356
01:02:47,550 --> 01:02:50,800
values, which again, is just synonymous with real numbers with decimal points.

1357
01:02:50,800 --> 01:02:54,150
Let me go ahead and include CS50.h, include stdio.h.

1358
01:02:54,150 --> 01:02:57,840


1359
01:02:57,840 --> 01:03:02,003
And then int main void and then my open curly braces.

1360
01:03:02,003 --> 01:03:02,920
And now let's do this.

1361
01:03:02,920 --> 01:03:04,680
Let me get the price of something.

1362
01:03:04,680 --> 01:03:10,290
So int price equals get float, what's the price, for instance.

1363
01:03:10,290 --> 01:03:11,450
Semicolon.

1364
01:03:11,450 --> 01:03:13,660
And now let me do something mathematical with this.

1365
01:03:13,660 --> 01:03:18,120
Let me go ahead and say, your total is.

1366
01:03:18,120 --> 01:03:21,330
And now let me just do the total price with tax, for instance.

1367
01:03:21,330 --> 01:03:24,353
In Massachusetts, sales tax is 6.25%.

1368
01:03:24,353 --> 01:03:26,520
So let's just write a little program that does that.

1369
01:03:26,520 --> 01:03:30,540
Your total is-- not percent s, because it's not a string.

1370
01:03:30,540 --> 01:03:33,190
Not percent i, because it's not an integer.

1371
01:03:33,190 --> 01:03:37,990
It should be percent f for float.

1372
01:03:37,990 --> 01:03:39,350
And in fact, I goofed.

1373
01:03:39,350 --> 01:03:41,860
I actually made a mistake here accidentally.

1374
01:03:41,860 --> 01:03:44,997
I don't want to store the price in an int if I'm getting it as a float.

1375
01:03:44,997 --> 01:03:47,080
If I'm getting a real number with a decimal point,

1376
01:03:47,080 --> 01:03:49,310
I probably want to store it as a float, as well.

1377
01:03:49,310 --> 01:03:52,480
So again, different format codes, different placeholders

1378
01:03:52,480 --> 01:03:53,787
for different contexts.

1379
01:03:53,787 --> 01:03:55,120
Now let me go ahead and do this.

1380
01:03:55,120 --> 01:03:56,995
And if I want to plug in the price, I'm going

1381
01:03:56,995 --> 01:04:05,230
to do price times 1.0625, which just mathematically means add 106.25%--

1382
01:04:05,230 --> 01:04:08,770
or multiply, rather, the price by 106.25%

1383
01:04:08,770 --> 01:04:11,203
so that you actually see the total with tax.

1384
01:04:11,203 --> 01:04:13,120
All right, so let's go ahead and compile this.

1385
01:04:13,120 --> 01:04:14,980
Make float, Enter.

1386
01:04:14,980 --> 01:04:17,320
No error messages, so that's already promising.

1387
01:04:17,320 --> 01:04:18,730
./float.

1388
01:04:18,730 --> 01:04:19,990
And what's the price?

1389
01:04:19,990 --> 01:04:23,170
How about $100.

1390
01:04:23,170 --> 01:04:25,180
OK, that's a little excessively precise.

1391
01:04:25,180 --> 01:04:29,932
The total price is $106.250000.

1392
01:04:29,932 --> 01:04:33,130
But that's just because the computer, per last week,

1393
01:04:33,130 --> 01:04:35,440
is using some number of bits to store values.

1394
01:04:35,440 --> 01:04:40,120
And the computer happens to be capable of showing this many digits

1395
01:04:40,120 --> 01:04:41,140
after the decimal point.

1396
01:04:41,140 --> 01:04:42,830
But what if you don't want to do that?

1397
01:04:42,830 --> 01:04:46,660
Well, it turns out there's some pretty arcane tricks you can do.

1398
01:04:46,660 --> 01:04:48,910
Instead of doing percent f, I can actually

1399
01:04:48,910 --> 01:04:52,360
do percent dot 2f, which again, you would only

1400
01:04:52,360 --> 01:04:55,570
know from having heard it before looking it up in a book or reference.

1401
01:04:55,570 --> 01:04:59,150
That's going to show me only two digits after the decimal point.

1402
01:04:59,150 --> 01:05:02,560
So if I recompile this code and make float and do ./float,

1403
01:05:02,560 --> 01:05:07,720
now notice if the price is $100, now my total is a little more user friendly--

1404
01:05:07,720 --> 01:05:09,790
106.25.

1405
01:05:09,790 --> 01:05:11,953
So in short, this is the f in printf.

1406
01:05:11,953 --> 01:05:13,870
Just as you can print something to the screen,

1407
01:05:13,870 --> 01:05:19,380
you can format it as by telling printf to only show so many digits.

1408
01:05:19,380 --> 01:05:20,810
Well, let me try something else.

1409
01:05:20,810 --> 01:05:23,470
Let me go ahead and copy/paste the beginnings of this code,

1410
01:05:23,470 --> 01:05:24,940
just to speed things up.

1411
01:05:24,940 --> 01:05:27,190
So I can implement a program called parity.c.

1412
01:05:27,190 --> 01:05:30,343
So parity is a fancy way of saying is a value even or odd.

1413
01:05:30,343 --> 01:05:32,260
And I've gone ahead and just copied and pasted

1414
01:05:32,260 --> 01:05:35,708
the setup of the code, not the essence of my main function.

1415
01:05:35,708 --> 01:05:38,500
But let's go ahead, in this program, and ask the user for a number.

1416
01:05:38,500 --> 01:05:39,540
We'll call it n.

1417
01:05:39,540 --> 01:05:41,620
And we'll use get_int to get that value.

1418
01:05:41,620 --> 01:05:44,620
And we're just going to say to the human, what's the value of n?

1419
01:05:44,620 --> 01:05:49,540
And I'm just going to say n colon space to just prompt them for some integer.

1420
01:05:49,540 --> 01:05:51,460
Then I'm going to go ahead and ask a question.

1421
01:05:51,460 --> 01:05:55,570
I want to ultimately print out even if the number is even or odd

1422
01:05:55,570 --> 01:05:56,830
if the number is odd.

1423
01:05:56,830 --> 01:06:02,650
So you could imagine doing this the very tedious way, like if n equals equals 1,

1424
01:06:02,650 --> 01:06:06,130
I could go ahead and print out odd.

1425
01:06:06,130 --> 01:06:12,340
And then else if n equals equals 2, I could print out even.

1426
01:06:12,340 --> 01:06:16,190
And then after that, I could support the number three, else if n--

1427
01:06:16,190 --> 01:06:17,440
I mean, this is stupid, right?

1428
01:06:17,440 --> 01:06:18,880
I could do this forever.

1429
01:06:18,880 --> 01:06:21,632
But it's at least showing a pattern, right?

1430
01:06:21,632 --> 01:06:24,340
One and then three and then five, of course, are going to be odd,

1431
01:06:24,340 --> 01:06:26,990
and two and four and six are going to be even, and so forth.

1432
01:06:26,990 --> 01:06:29,240
Well, it turns out we can compute this mathematically.

1433
01:06:29,240 --> 01:06:30,970
And a very common trick might be this--

1434
01:06:30,970 --> 01:06:32,500
we can actually do this.

1435
01:06:32,500 --> 01:06:39,070
If n divided by 2 has a remainder of, for instance, 0,

1436
01:06:39,070 --> 01:06:42,850
then I'm going to go ahead and conclude that the number is even.

1437
01:06:42,850 --> 01:06:45,430
So this percent sign is a new construction.

1438
01:06:45,430 --> 01:06:46,090
It's not plus.

1439
01:06:46,090 --> 01:06:47,440
It's not minus.

1440
01:06:47,440 --> 01:06:49,240
It's not multiplication or division.

1441
01:06:49,240 --> 01:06:53,150
This is the remainder operation, or the modulo operation, so to speak.

1442
01:06:53,150 --> 01:06:59,470
And this just means divide n by 2, and if the answer has a remainder of 0,

1443
01:06:59,470 --> 01:07:02,670
you can conclude, by definition of even, that the number is even.

1444
01:07:02,670 --> 01:07:04,100
So I'm going to print that.

1445
01:07:04,100 --> 01:07:08,320
Else-- I could do else if n percent 2 equals equals 1

1446
01:07:08,320 --> 01:07:11,380
and has a remainder of 1, you could imagine saying odd.

1447
01:07:11,380 --> 01:07:15,405
But as you noted earlier, this is not necessary.

1448
01:07:15,405 --> 01:07:18,280
What could I instead do to make the program a little better designed,

1449
01:07:18,280 --> 01:07:19,600
a little more efficient?

1450
01:07:19,600 --> 01:07:20,248
Yeah?

1451
01:07:20,248 --> 01:07:22,440
AUDIENCE: You could just use else and that would be fine.

1452
01:07:22,440 --> 01:07:22,770
DAVID MALAN: Yeah.

1453
01:07:22,770 --> 01:07:24,687
So if we're talking about integers, I can just

1454
01:07:24,687 --> 01:07:28,360
conclude, well, if it's not even, it must be odd, by definition.

1455
01:07:28,360 --> 01:07:30,510
And so here, we can just do even and odd.

1456
01:07:30,510 --> 01:07:33,510
So this program, once run, is going to look like this.

1457
01:07:33,510 --> 01:07:35,400
Make parity.

1458
01:07:35,400 --> 01:07:36,630
Looks like it compiled OK.

1459
01:07:36,630 --> 01:07:38,880
So ./parity is how I run it.

1460
01:07:38,880 --> 01:07:40,290
Let's type the number 50.

1461
01:07:40,290 --> 01:07:40,950
That's even.

1462
01:07:40,950 --> 01:07:42,510
Let's type the number 49.

1463
01:07:42,510 --> 01:07:43,380
That's odd.

1464
01:07:43,380 --> 01:07:44,850
Proof by example.

1465
01:07:44,850 --> 01:07:48,060
This is not very compelling, but I bet this is going to be correct, just

1466
01:07:48,060 --> 01:07:49,480
based on those two examples alone.

1467
01:07:49,480 --> 01:07:49,980
Yeah?

1468
01:07:49,980 --> 01:07:52,938
AUDIENCE: [INAUDIBLE] user did not understand our comment that answer's

1469
01:07:52,938 --> 01:07:54,332
a float or not an integer?

1470
01:07:54,332 --> 01:07:55,790
DAVID MALAN: Sorry, say that again?

1471
01:07:55,790 --> 01:07:58,207
AUDIENCE: What if the user doesn't understand, I'm saying?

1472
01:07:58,207 --> 01:08:02,783
Like I just do something like 1 and 1/2 [INAUDIBLE]..

1473
01:08:02,783 --> 01:08:04,200
DAVID MALAN: Really good question.

1474
01:08:04,200 --> 01:08:06,950
One of the reasons we provide for the first few weeks of the class

1475
01:08:06,950 --> 01:08:10,700
a few functions in the CS50 library like get_string and get_int and get_float

1476
01:08:10,700 --> 01:08:14,960
is that it forces the user to behave as you expect so that your program doesn't

1477
01:08:14,960 --> 01:08:17,149
crash because of unexpected user input.

1478
01:08:17,149 --> 01:08:20,180
So to your point, suppose the user is being a little difficult and says,

1479
01:08:20,180 --> 01:08:22,939
my number is going to be 1.5.

1480
01:08:22,939 --> 01:08:27,854
Get_int is going to prompt them for the same question again and again and again

1481
01:08:27,854 --> 01:08:28,729
until they cooperate.

1482
01:08:28,729 --> 01:08:31,819
If you type in apple, it's going to prompt you again.

1483
01:08:31,819 --> 01:08:34,880
Only once you provide an actual integer will it cooperate.

1484
01:08:34,880 --> 01:08:37,540
So those are among the features you get from the CS50 library,

1485
01:08:37,540 --> 01:08:39,410
just so that we can focus on ideas and not

1486
01:08:39,410 --> 01:08:44,270
on what we would call error checking, or malicious users, in this case.

1487
01:08:44,270 --> 01:08:46,670
All right, so what else can we do once we

1488
01:08:46,670 --> 01:08:49,279
have the ability to express conditions?

1489
01:08:49,279 --> 01:08:52,010
Well, let me go ahead and open one that I brought with me.

1490
01:08:52,010 --> 01:08:54,109
So rather than type all of these from Scratch,

1491
01:08:54,109 --> 01:08:56,618
let me go ahead and open conditions1.c.

1492
01:08:56,618 --> 01:08:58,660
So this is a program that's already been written.

1493
01:08:58,660 --> 01:09:00,920
And it turns out, it's got some other lines in it,

1494
01:09:00,920 --> 01:09:03,643
these grayed-out outlines that begin with slash slash.

1495
01:09:03,643 --> 01:09:05,810
You might not have noticed this, but in Scratch, you

1496
01:09:05,810 --> 01:09:06,979
can have what are called comments.

1497
01:09:06,979 --> 01:09:09,050
They're like little sticky notes that you can add

1498
01:09:09,050 --> 01:09:10,550
that don't do anything functionally.

1499
01:09:10,550 --> 01:09:13,825
It's just like notes to self or notes to your friend or notes to your TF.

1500
01:09:13,825 --> 01:09:15,950
That's what a comment is in a programming language.

1501
01:09:15,950 --> 01:09:19,310
So anything starting with a slash slash is a note to self.

1502
01:09:19,310 --> 01:09:21,873
And it's a reminder to me what this line of code does.

1503
01:09:21,873 --> 01:09:24,040
It's a reminder to your colleagues in the real world

1504
01:09:24,040 --> 01:09:27,380
or your TF in a class to explain to them what this line of code

1505
01:09:27,380 --> 01:09:30,520
is supposed to be doing, even if maybe you have a bug

1506
01:09:30,520 --> 01:09:32,090
and it's not actually doing that.

1507
01:09:32,090 --> 01:09:35,840
So I've begun, in these pre-created examples, to comment my code,

1508
01:09:35,840 --> 01:09:37,580
but the lines are essentially the same.

1509
01:09:37,580 --> 01:09:40,250
Go ahead and give me access to the CS50 library.

1510
01:09:40,250 --> 01:09:43,010
And a library, again, is just a file of code

1511
01:09:43,010 --> 01:09:45,080
that someone else wrote that we're using.

1512
01:09:45,080 --> 01:09:47,960
And give me access to the standard I/O library, which contains

1513
01:09:47,960 --> 01:09:50,430
printf and some other things, as well.

1514
01:09:50,430 --> 01:09:54,170
Notice here, I have x equals get_int in order

1515
01:09:54,170 --> 01:09:56,390
to get one integer from the user called x.

1516
01:09:56,390 --> 01:09:59,840
Now I'm going to ask them for a second integer by just calling it y

1517
01:09:59,840 --> 01:10:01,400
and calling get_int again.

1518
01:10:01,400 --> 01:10:03,840
And now I can do things like compare these values.

1519
01:10:03,840 --> 01:10:07,790
So this is now a complete version of the Scratch-like program

1520
01:10:07,790 --> 01:10:11,450
I pulled up before that allows us to conclude is x less than y,

1521
01:10:11,450 --> 01:10:15,290
greater than y, or, by default, equal to y.

1522
01:10:15,290 --> 01:10:19,080
So the only difference is we saw these lines of code on the screen before.

1523
01:10:19,080 --> 01:10:22,340
Now we see, in context, that, oh, for those lines to work,

1524
01:10:22,340 --> 01:10:25,640
we need to get the integers from the user.

1525
01:10:25,640 --> 01:10:28,520
And we need to have the equivalent of when green flag clicked,

1526
01:10:28,520 --> 01:10:31,115
and we need the equivalent of these includes so that it's

1527
01:10:31,115 --> 01:10:33,575
a complete self-contained program.

1528
01:10:33,575 --> 01:10:35,450
And just to be clear, even though I made this

1529
01:10:35,450 --> 01:10:38,710
in advance, if I wanted to run this program, how could I run it?

1530
01:10:38,710 --> 01:10:41,770
Call conditions.c.

1531
01:10:41,770 --> 01:10:45,030
Yeah, so make conditions first.

1532
01:10:45,030 --> 01:10:45,530
Sorry.

1533
01:10:45,530 --> 01:10:48,140
Oh, this is actually a teachable moment.

1534
01:10:48,140 --> 01:10:49,670
Why did this not work?

1535
01:10:49,670 --> 01:10:54,020
So no rule to make target conditions stop, which is a little emphatic.

1536
01:10:54,020 --> 01:10:55,130
But what does that mean?

1537
01:10:55,130 --> 01:10:58,700
Well, in advance today, what I did was I downloaded into my sandbox

1538
01:10:58,700 --> 01:11:02,630
a folder called src1, S-R-C meaning "source" in programmer speak.

1539
01:11:02,630 --> 01:11:06,140
And I just downloaded this into the sandbox for me.

1540
01:11:06,140 --> 01:11:08,540
Because in that folder are all of the examples

1541
01:11:08,540 --> 01:11:12,050
not only that I wrote in live, but also some others that I brought with me.

1542
01:11:12,050 --> 01:11:15,920
Unfortunately, all of those files are in a folder called src1.

1543
01:11:15,920 --> 01:11:18,920
Now, on your Mac or PC, if you want to open a folder, you do what I did.

1544
01:11:18,920 --> 01:11:22,100
You double-double the icon, and boom, the folder is open.

1545
01:11:22,100 --> 01:11:25,880
But in a terminal window, a text-based environment, you can't do that.

1546
01:11:25,880 --> 01:11:29,840
If I type ls, we'll see all of the files that I've created today--

1547
01:11:29,840 --> 01:11:32,120
float and hello and int.

1548
01:11:32,120 --> 01:11:34,520
But notice over here, there's a folder.

1549
01:11:34,520 --> 01:11:36,145
And that's what the trailing slash is.

1550
01:11:36,145 --> 01:11:38,270
That's a forward slash that just means, hey, human,

1551
01:11:38,270 --> 01:11:40,250
this is a folder, just so it's obvious.

1552
01:11:40,250 --> 01:11:44,150
Just like the asterisk means here's a machine code that you can run.

1553
01:11:44,150 --> 01:11:47,270
I need to change into that directory, but I can't double-click.

1554
01:11:47,270 --> 01:11:49,700
Nothing's going to happen if I double-click on this text.

1555
01:11:49,700 --> 01:11:53,650
But I can type cd space src1.

1556
01:11:53,650 --> 01:11:55,760
cd means change directory.

1557
01:11:55,760 --> 01:11:57,200
And now I hit Enter.

1558
01:11:57,200 --> 01:11:59,990
And now if I hit ls, notice I see even more files,

1559
01:11:59,990 --> 01:12:03,110
because these are all of the files from the course's website

1560
01:12:03,110 --> 01:12:05,180
that I brought with me today.

1561
01:12:05,180 --> 01:12:08,037
And if you type a command like this, pwd,

1562
01:12:08,037 --> 01:12:10,370
this will reveal even more information about the system,

1563
01:12:10,370 --> 01:12:12,050
but more on this in the weeks to come.

1564
01:12:12,050 --> 01:12:16,160
You're actually inside a src1 folder that's inside of a sandbox folder

1565
01:12:16,160 --> 01:12:17,840
that's inside of a root folder.

1566
01:12:17,840 --> 01:12:21,140
Now, odds are, at some point, you'll get confused as to where you are.

1567
01:12:21,140 --> 01:12:23,150
When in doubt, just type cd.

1568
01:12:23,150 --> 01:12:25,950
That will whisk you away to the default folder where you began,

1569
01:12:25,950 --> 01:12:28,430
no matter where you found yourself to.

1570
01:12:28,430 --> 01:12:30,470
Type ls, and you're back at the beginning.

1571
01:12:30,470 --> 01:12:32,570
So when in doubt, just type cd and Enter,

1572
01:12:32,570 --> 01:12:34,430
and you'll be back at the beginning.

1573
01:12:34,430 --> 01:12:37,610
Well, let me go ahead and open up this program, but run this one first.

1574
01:12:37,610 --> 01:12:40,190
I'm going to go into a program called agree.c.

1575
01:12:40,190 --> 01:12:44,520
I'm going to hide the code for a moment and make agree.

1576
01:12:44,520 --> 01:12:47,360
I did it again, cd src1, Enter.

1577
01:12:47,360 --> 01:12:49,800
Now I can do make agree.

1578
01:12:49,800 --> 01:12:51,500
It seems to have compiled the program.

1579
01:12:51,500 --> 01:12:55,700
And if I do ./agree, this program seems to be asking me a question--

1580
01:12:55,700 --> 01:12:56,523
do you agree?

1581
01:12:56,523 --> 01:12:58,940
Now, it's not obvious from the program what I should type,

1582
01:12:58,940 --> 01:13:01,220
but my gut tells me, sure, yes.

1583
01:13:01,220 --> 01:13:04,370
So I'm going to go ahead and type y for yes and Enter.

1584
01:13:04,370 --> 01:13:06,050
And it seems to know that I've agreed.

1585
01:13:06,050 --> 01:13:07,490
If I rerun it again--

1586
01:13:07,490 --> 01:13:11,900
./agree-- and type n this time, not agreed.

1587
01:13:11,900 --> 01:13:12,650
But you know what?

1588
01:13:12,650 --> 01:13:13,942
It's actually better than that.

1589
01:13:13,942 --> 01:13:18,650
If I do ./agree and maybe do a capital Y, Enter, that also seems to work.

1590
01:13:18,650 --> 01:13:20,130
So how is this happening?

1591
01:13:20,130 --> 01:13:21,770
Well, let me look at the code here.

1592
01:13:21,770 --> 01:13:25,190
The top of the file is almost identical to everything thus far.

1593
01:13:25,190 --> 01:13:27,650
Include those two files, int main void.

1594
01:13:27,650 --> 01:13:30,320
But now I'm using get_char, and I'm storing my answer

1595
01:13:30,320 --> 01:13:33,710
in a variable called c, but I could store it in anything I want.

1596
01:13:33,710 --> 01:13:36,350
And now notice the slightly new syntax.

1597
01:13:36,350 --> 01:13:41,300
What's clearly new about what I'm doing here?

1598
01:13:41,300 --> 01:13:43,910
What symbols jump out?

1599
01:13:43,910 --> 01:13:45,200
Yeah, the vertical bar.

1600
01:13:45,200 --> 01:13:48,020
So this is a way of saying a logical or.

1601
01:13:48,020 --> 01:13:50,630
So in Python and a few other languages these days, you

1602
01:13:50,630 --> 01:13:52,280
might literally write the word "or."

1603
01:13:52,280 --> 01:13:57,500
That doesn't work in C. If you want to ask this question or this question

1604
01:13:57,500 --> 01:14:00,740
and just take either answer as a valid answer,

1605
01:14:00,740 --> 01:14:03,020
you just use two vertical bars, which are typically

1606
01:14:03,020 --> 01:14:05,720
above your Enter key on an American keyboard, at least.

1607
01:14:05,720 --> 01:14:07,760
So two vertical bars means or.

1608
01:14:07,760 --> 01:14:10,640
Two ampersands, it turns out, means and.

1609
01:14:10,640 --> 01:14:13,940
But this is just a way of asking two questions in the same breath

1610
01:14:13,940 --> 01:14:16,800
and accepting either answer as potentially true.

1611
01:14:16,800 --> 01:14:21,650
So if c is capital Y or c is lowercase y, assume that the human has agreed.

1612
01:14:21,650 --> 01:14:26,090
Else, if c equals capital N or lowercase n, assume that they've not agreed.

1613
01:14:26,090 --> 01:14:28,970
And suppose I type in some other letter all together,

1614
01:14:28,970 --> 01:14:32,220
what's the program going to do?

1615
01:14:32,220 --> 01:14:32,720
Say again?

1616
01:14:32,720 --> 01:14:33,740
AUDIENCE: Ask you again.

1617
01:14:33,740 --> 01:14:35,000
DAVID MALAN: It's not going to ask me again,

1618
01:14:35,000 --> 01:14:36,950
because there's no loop here, right?

1619
01:14:36,950 --> 01:14:41,360
There's no evidence of while or for loop.

1620
01:14:41,360 --> 01:14:46,190
And get_char is literally going to get a char, but it doesn't specify what char.

1621
01:14:46,190 --> 01:14:50,900
What happens if I don't type y or n, capital or lowercase?

1622
01:14:50,900 --> 01:14:52,103
It seems nothing.

1623
01:14:52,103 --> 01:14:54,020
Just nothing's going to happen, and that's OK.

1624
01:14:54,020 --> 01:14:56,210
Your program doesn't have to print something.

1625
01:14:56,210 --> 01:15:01,060
And indeed, if I run this again and ./agree x.

1626
01:15:01,060 --> 01:15:02,130
It doesn't do anything.

1627
01:15:02,130 --> 01:15:03,860
So I've neither agreed nor disagreed.

1628
01:15:03,860 --> 01:15:07,910
However, you could imagine writing a loop that somehow forces the human

1629
01:15:07,910 --> 01:15:10,117
to cooperate in some way or another.

1630
01:15:10,117 --> 01:15:12,200
All right, let's do a different example, this time

1631
01:15:12,200 --> 01:15:15,800
based on an idea from last time-- that of abstraction.

1632
01:15:15,800 --> 01:15:18,980
Recall that in Scratch, there was no puzzle piece for coughing,

1633
01:15:18,980 --> 01:15:21,620
to make the cat [COUGHS] on the screen.

1634
01:15:21,620 --> 01:15:25,070
And so we implemented this, really, with our own custom puzzle piece,

1635
01:15:25,070 --> 01:15:25,850
ultimately.

1636
01:15:25,850 --> 01:15:30,080
So let me create a program that's called cough0.c.

1637
01:15:30,080 --> 01:15:33,140
That's a generous definition of inactivity, but OK.

1638
01:15:33,140 --> 01:15:35,960
Let me reload the screen.

1639
01:15:35,960 --> 01:15:38,420
When in doubt in CS50, as in life, reload.

1640
01:15:38,420 --> 01:15:39,920
That will probably fix.

1641
01:15:39,920 --> 01:15:43,248
Unfortunately, with programming and the internet, that sometimes happens.

1642
01:15:43,248 --> 01:15:45,290
So in a moment, what I'm going to go ahead and do

1643
01:15:45,290 --> 01:15:49,730
is translate that idea from Scratch of implementing the notion of coughing.

1644
01:15:49,730 --> 01:15:54,060
But instead of the say block, I'm going to use the printf block, or the printf

1645
01:15:54,060 --> 01:15:54,990
function.

1646
01:15:54,990 --> 01:15:58,700
And then I'm going to go ahead and design this version of code slightly

1647
01:15:58,700 --> 01:16:01,920
better and slightly better each time.

1648
01:16:01,920 --> 01:16:07,010
So I'm going to go ahead and open up a file cough0.c.

1649
01:16:07,010 --> 01:16:11,900
And I'm going to go ahead and include, let's say, stdio.h.

1650
01:16:11,900 --> 01:16:16,180
I'm going to go ahead and do int main void, which again, is just our boiler

1651
01:16:16,180 --> 01:16:18,080
plate or copy/paste for today.

1652
01:16:18,080 --> 01:16:21,080
I'm going to go ahead, then, and say printf, quote unquote,

1653
01:16:21,080 --> 01:16:22,580
cough with a new line.

1654
01:16:22,580 --> 01:16:25,050
And recall, in Scratch I wanted this to happen three times,

1655
01:16:25,050 --> 01:16:27,300
so I'm going to do it like this-- cough, cough, cough.

1656
01:16:27,300 --> 01:16:31,520
All right, I'm going to give myself a terminal window here at the bottom

1657
01:16:31,520 --> 01:16:35,330
so that I can now go ahead and say make cough0, Enter.

1658
01:16:35,330 --> 01:16:39,470
Nothing bad seems to happen. ./cough0 and cough, cough, cough.

1659
01:16:39,470 --> 01:16:42,950
So last week, I claimed that, eh, you can design this better, right?

1660
01:16:42,950 --> 01:16:44,960
Anytime you're copying and pasting, odds are

1661
01:16:44,960 --> 01:16:46,850
you should start to resist that temptation,

1662
01:16:46,850 --> 01:16:49,933
because it's going to lead to messy code, longer code than it needs to be.

1663
01:16:49,933 --> 01:16:52,133
What's the solution to this problem from last week?

1664
01:16:52,133 --> 01:16:52,920
AUDIENCE: A loop.

1665
01:16:52,920 --> 01:16:54,390
DAVID MALAN: Yeah, a loop, a for loop.

1666
01:16:54,390 --> 01:16:55,682
So let me go ahead and do that.

1667
01:16:55,682 --> 01:16:57,693
Let me create another version, cough1.c.

1668
01:16:57,693 --> 01:17:00,360
And I'm going to copy/paste this code, just as a starting point.

1669
01:17:00,360 --> 01:17:02,400
But now I'm going to go ahead and clean it up.

1670
01:17:02,400 --> 01:17:04,960
So I'm going to go ahead and instead do a for loop.

1671
01:17:04,960 --> 01:17:07,460
And I don't quite remember what goes in the parentheses yet,

1672
01:17:07,460 --> 01:17:08,690
but we'll come back to that.

1673
01:17:08,690 --> 01:17:12,530
I do know that what I want to do some number of times is just cough.

1674
01:17:12,530 --> 01:17:15,333
So the only question at hand is, what was the syntax here?

1675
01:17:15,333 --> 01:17:17,250
Well, we can write this in any number of ways,

1676
01:17:17,250 --> 01:17:18,890
and we could even use a while loop.

1677
01:17:18,890 --> 01:17:22,520
But I do recall saying int and then the name of a variable.

1678
01:17:22,520 --> 01:17:24,960
I could say counter, or I could just say i

1679
01:17:24,960 --> 01:17:28,970
to keep it succinct, equals 0 by default.

1680
01:17:28,970 --> 01:17:32,540
I could do this so long as i is less than 3, for instance.

1681
01:17:32,540 --> 01:17:38,070
And then on each iteration, I can say i equals i plus 1 or, more succinctly,

1682
01:17:38,070 --> 01:17:39,710
i plus plus.

1683
01:17:39,710 --> 01:17:41,223
So, again, it's a lot of new syntax.

1684
01:17:41,223 --> 01:17:43,140
And there's semicolons all over the place now.

1685
01:17:43,140 --> 01:17:46,700
But if I go ahead now and do make cough1,

1686
01:17:46,700 --> 01:17:48,410
nothing bad seems to have happened.

1687
01:17:48,410 --> 01:17:51,020
./cough1, cough, cough, cough.

1688
01:17:51,020 --> 01:17:53,180
It seems to be slightly better designed.

1689
01:17:53,180 --> 01:17:55,460
Unfortunately, there is this paradigm in programming

1690
01:17:55,460 --> 01:18:00,110
where humans, programmers, tend to think or tend to count starting from zero.

1691
01:18:00,110 --> 01:18:02,240
However, if you don't like that, at least early on,

1692
01:18:02,240 --> 01:18:05,210
there's nothing stopping me from initializing i to 1

1693
01:18:05,210 --> 01:18:08,420
and then doing i is less than 4 or, even more explicitly,

1694
01:18:08,420 --> 01:18:10,655
i is less than or equal to 3.

1695
01:18:10,655 --> 01:18:13,280
There's no less than or equal sign on your keyboard, typically,

1696
01:18:13,280 --> 01:18:17,390
so you can mimic it by doing a less than and then an equal sign, two characters.

1697
01:18:17,390 --> 01:18:18,800
This is logically the same.

1698
01:18:18,800 --> 01:18:20,240
Set i equal to 1.

1699
01:18:20,240 --> 01:18:23,450
Then go ahead and print cough, and then make sure to increment it.

1700
01:18:23,450 --> 01:18:26,150
And then make sure it's still less than 3, and 2 is.

1701
01:18:26,150 --> 01:18:28,850
Make sure it's still less than or equal to 3, and it still is.

1702
01:18:28,850 --> 01:18:31,620
So that 2 is, logically, going to have the same effect.

1703
01:18:31,620 --> 01:18:36,590
However, in the interests of convention, this would be the more common approach.

1704
01:18:36,590 --> 01:18:42,768
Do this while i equals 0 and then 1 and then 2, for a total of 3 times.

1705
01:18:42,768 --> 01:18:44,810
All right, but recall what we did last time, too,

1706
01:18:44,810 --> 01:18:47,540
is that if I'm writing a lot of code, for some reason, that

1707
01:18:47,540 --> 01:18:51,800
involves programs coughing, it would be nice to give myself my own custom

1708
01:18:51,800 --> 01:18:52,920
function.

1709
01:18:52,920 --> 01:18:54,450
So let me go ahead and do that.

1710
01:18:54,450 --> 01:18:58,430
Let me go ahead and write my own first brand-new function.

1711
01:18:58,430 --> 01:19:00,570
And I'm going to do this as follows.

1712
01:19:00,570 --> 01:19:04,220
I'm going to go ahead and type void, then the name of the function I want.

1713
01:19:04,220 --> 01:19:07,160
Then I'm going to say void here, for reasons we'll come back to.

1714
01:19:07,160 --> 01:19:10,160
And then I'm going to literally just go ahead and say cough.

1715
01:19:10,160 --> 01:19:14,120
So there are functions we've used today-- printf, get_int, get_string,

1716
01:19:14,120 --> 01:19:18,650
get_float-- none of which we showed you the implementation of, because people,

1717
01:19:18,650 --> 01:19:21,270
years ago, both in the staff and in the real world,

1718
01:19:21,270 --> 01:19:23,000
implemented those functions for us.

1719
01:19:23,000 --> 01:19:26,270
You, too, can implement your own custom functions or, in Scratch,

1720
01:19:26,270 --> 01:19:29,690
those puzzle pieces that we made in those pink blocks.

1721
01:19:29,690 --> 01:19:31,940
So if you want to make your own function whose name is

1722
01:19:31,940 --> 01:19:35,960
cough, whose purpose in life is to say cough on the screen,

1723
01:19:35,960 --> 01:19:37,010
this is the syntax.

1724
01:19:37,010 --> 01:19:40,880
For today's purposes, you say void and void here, but the name of the function

1725
01:19:40,880 --> 01:19:41,690
is important.

1726
01:19:41,690 --> 01:19:43,040
I'll call it cough.

1727
01:19:43,040 --> 01:19:45,000
And then I can use it as follows.

1728
01:19:45,000 --> 01:19:50,750
I can say cough, cough, cough now in order to cough three times.

1729
01:19:50,750 --> 01:19:53,150
Or again, we already decided that was bad design.

1730
01:19:53,150 --> 01:19:57,770
For int i get 0, i less than 3, i plus plus.

1731
01:19:57,770 --> 01:20:00,230
I can now do something like cough.

1732
01:20:00,230 --> 01:20:03,290
And so now, again, out of sight, out of mind.

1733
01:20:03,290 --> 01:20:07,460
I don't need to know or care how the cough function is implemented.

1734
01:20:07,460 --> 01:20:10,850
I can care that my code just tells the computer what to do.

1735
01:20:10,850 --> 01:20:15,260
For i from 0 on up to 3, cough, cough, cough.

1736
01:20:15,260 --> 01:20:16,480
And this is an abstraction.

1737
01:20:16,480 --> 01:20:18,950
I don't care that cough is implemented with printf.

1738
01:20:18,950 --> 01:20:22,070
I just care that there's a function called cough.

1739
01:20:22,070 --> 01:20:25,490
So let me go ahead and run this and see what happens.

1740
01:20:25,490 --> 01:20:28,710
Let me scroll down to the bottom, do make cough1.

1741
01:20:28,710 --> 01:20:29,750
OK, amazing.

1742
01:20:29,750 --> 01:20:30,830
No red errors now.

1743
01:20:30,830 --> 01:20:34,550
So ./cough1, cough, cough, cough.

1744
01:20:34,550 --> 01:20:38,553
But notice that this is a little bad design, I would claim,

1745
01:20:38,553 --> 01:20:39,470
because you know what?

1746
01:20:39,470 --> 01:20:42,890
If you keep writing custom functions up here, up here, up here,

1747
01:20:42,890 --> 01:20:46,145
the main part of your program is going to get pushed pretty far down.

1748
01:20:46,145 --> 01:20:48,770
And it's a human convention to generally have the main function

1749
01:20:48,770 --> 01:20:49,790
at the top of your file.

1750
01:20:49,790 --> 01:20:50,790
Seems pretty reasonable.

1751
01:20:50,790 --> 01:20:53,420
So you open the file, boom, the main function's right there.

1752
01:20:53,420 --> 01:20:54,620
So let's keep it there.

1753
01:20:54,620 --> 01:20:58,448
So let me actually move the cough function down below just so

1754
01:20:58,448 --> 01:21:01,490
that, again, the first thing I see is indeed the main part of my program.

1755
01:21:01,490 --> 01:21:03,020
And wherever cough is, I don't care.

1756
01:21:03,020 --> 01:21:05,090
That was the whole point of implementing it.

1757
01:21:05,090 --> 01:21:08,990
Let me go now to my terminal window and do make cough1.

1758
01:21:08,990 --> 01:21:12,500
Oh my god, some red errors flew by.

1759
01:21:12,500 --> 01:21:14,030
What's wrong here?

1760
01:21:14,030 --> 01:21:19,130
So error, implicit declaration of function cough is invalid in C '99.

1761
01:21:19,130 --> 01:21:22,610
C '99 means the version of C invented in 1999.

1762
01:21:22,610 --> 01:21:23,690
What's going on?

1763
01:21:23,690 --> 01:21:25,100
Implicit declaration?

1764
01:21:25,100 --> 01:21:27,500
So this is where C differs from Scratch again.

1765
01:21:27,500 --> 01:21:29,840
C is old, and it's kind of dumb.

1766
01:21:29,840 --> 01:21:32,840
It only knows what you tell it, and it only

1767
01:21:32,840 --> 01:21:36,290
knows what you tell it in order top to bottom, left to right.

1768
01:21:36,290 --> 01:21:41,480
So in this program right now, I have included stdio.h, as before.

1769
01:21:41,480 --> 01:21:43,700
I've included the beginning of main.

1770
01:21:43,700 --> 01:21:45,480
I've started a for loop.

1771
01:21:45,480 --> 01:21:48,320
And then I'm using a function that's apparently called cough.

1772
01:21:48,320 --> 01:21:52,640
However, where is cough now actually implemented?

1773
01:21:52,640 --> 01:21:54,880
Way down here on line 11 onwards.

1774
01:21:54,880 --> 01:21:56,600
C is not that smart.

1775
01:21:56,600 --> 01:21:59,510
It's not going to presume to look later in your file to see,

1776
01:21:59,510 --> 01:22:02,150
maybe they put the function cough down below.

1777
01:22:02,150 --> 01:22:04,070
It's only going to do what you tell it.

1778
01:22:04,070 --> 01:22:05,503
So there's a fix for this.

1779
01:22:05,503 --> 01:22:07,670
You can either do what I did initially, which is put

1780
01:22:07,670 --> 01:22:09,268
all of your custom functions up top.

1781
01:22:09,268 --> 01:22:11,810
But that's kind of a vicious cycle, because you can't forever

1782
01:22:11,810 --> 01:22:13,107
put the new functions up top.

1783
01:22:13,107 --> 01:22:15,690
Eventually, you're going to run into some kind of constraints.

1784
01:22:15,690 --> 01:22:19,070
And my god, you want the main function, by convention, to be up top.

1785
01:22:19,070 --> 01:22:20,880
So there's another solution here.

1786
01:22:20,880 --> 01:22:23,900
And this is the only time where copy/paste is compelling.

1787
01:22:23,900 --> 01:22:29,210
You literally copy the first line of your function's code on line 11 there.

1788
01:22:29,210 --> 01:22:33,660
And you go ahead and paste it at the top of your file with a semicolon.

1789
01:22:33,660 --> 01:22:38,113
So this is a way of sort of tricking C into, oh, you have seen cough before.

1790
01:22:38,113 --> 01:22:40,530
You haven't seen all of it, but you've seen enough of it--

1791
01:22:40,530 --> 01:22:41,720
you've seen its name--

1792
01:22:41,720 --> 01:22:45,870
to now tolerate its appearance in my main function.

1793
01:22:45,870 --> 01:22:49,130
So let me go ahead and recompile this code.

1794
01:22:49,130 --> 01:22:51,770
I'm going to go ahead and run make cough1 enter.

1795
01:22:51,770 --> 01:22:53,510
OK, now it compiled.

1796
01:22:53,510 --> 01:22:59,370
./cough1, and viola, we're back in business there.

1797
01:22:59,370 --> 01:23:00,740
But let me make one refinement.

1798
01:23:00,740 --> 01:23:05,810
And I'm going to jump ahead to what I called in the online examples cough3.c.

1799
01:23:05,810 --> 01:23:08,600
It turns out your own custom functions can take input.

1800
01:23:08,600 --> 01:23:11,610
This word void means that it takes no input.

1801
01:23:11,610 --> 01:23:15,938
And this word void means it returns no value, like get_int and get_string hand

1802
01:23:15,938 --> 01:23:16,730
you back something.

1803
01:23:16,730 --> 01:23:18,647
That's not applicable now, but we'll come back

1804
01:23:18,647 --> 01:23:20,450
to that in a week or two's time.

1805
01:23:20,450 --> 01:23:24,770
Suppose that you wanted to make the cough function more versatile

1806
01:23:24,770 --> 01:23:28,190
such that it will cough any number of times for you.

1807
01:23:28,190 --> 01:23:29,660
You know what you can do, is this.

1808
01:23:29,660 --> 01:23:34,670
You can change the input to cough function to be some value like n,

1809
01:23:34,670 --> 01:23:38,840
and you can then do something like this-- for int i get 0.

1810
01:23:38,840 --> 01:23:43,730
i is less than n, so not hardcoded anymore. i plus plus.

1811
01:23:43,730 --> 01:23:48,650
And then inside of your curly braces, you can print this cough line.

1812
01:23:48,650 --> 01:23:52,520
So now, notice, cough has been parameterized.

1813
01:23:52,520 --> 01:23:55,430
It now takes input of integer called n, and it

1814
01:23:55,430 --> 01:23:58,220
uses that input, n, just like you could have done

1815
01:23:58,220 --> 01:24:00,740
in Scratch, to do something n times--

1816
01:24:00,740 --> 01:24:04,010
not once, not three times, but a variable number of times.

1817
01:24:04,010 --> 01:24:06,360
I have to change my first line here.

1818
01:24:06,360 --> 01:24:07,520
This is called a prototype.

1819
01:24:07,520 --> 01:24:09,860
This one-liner is what's called a prototype,

1820
01:24:09,860 --> 01:24:12,140
and it's just copy/paste from your actual function.

1821
01:24:12,140 --> 01:24:13,700
But now notice what I can do.

1822
01:24:13,700 --> 01:24:16,550
My main function, again, is the essence of my program.

1823
01:24:16,550 --> 01:24:19,190
It's a little convoluted right now.

1824
01:24:19,190 --> 01:24:23,150
Wouldn't it be nicer if I could just say cough three times?

1825
01:24:23,150 --> 01:24:28,040
And indeed, now I don't need to know or care how coughing is implemented.

1826
01:24:28,040 --> 01:24:30,950
That's a well-designed program, arguably.

1827
01:24:30,950 --> 01:24:32,300
It's one line of code.

1828
01:24:32,300 --> 01:24:33,137
It's descriptive.

1829
01:24:33,137 --> 01:24:33,720
It says cough.

1830
01:24:33,720 --> 01:24:35,990
It takes an input, which means it costs three times.

1831
01:24:35,990 --> 01:24:38,823
And what's down below in the file, though I could certainly bring it

1832
01:24:38,823 --> 01:24:40,770
back up, is just what a computer scientist

1833
01:24:40,770 --> 01:24:43,250
would call an implementation detail.

1834
01:24:43,250 --> 01:24:45,620
Someone cares how you implement coughing,

1835
01:24:45,620 --> 01:24:48,200
but you don't have to care how you implement coughing.

1836
01:24:48,200 --> 01:24:50,530
You don't have to how we get integers.

1837
01:24:50,530 --> 01:24:52,930
You don't have to care about how you printf.

1838
01:24:52,930 --> 01:24:56,140
You just care that someone else has implemented that functionality

1839
01:24:56,140 --> 01:25:00,280
so you can stand on their shoulders and build more interesting programs that

1840
01:25:00,280 --> 01:25:03,310
are actually interesting to you.

1841
01:25:03,310 --> 01:25:06,235
Let me go ahead and open up an example that builds on this same idea.

1842
01:25:06,235 --> 01:25:08,740


1843
01:25:08,740 --> 01:25:14,030
In, let's see, positive.c, we have this example here,

1844
01:25:14,030 --> 01:25:16,040
which makes this all the more clear.

1845
01:25:16,040 --> 01:25:20,100
So here's a program that uses our two libraries, CS50 in standard I/O.

1846
01:25:20,100 --> 01:25:22,330
It turns out that the CS50 library does not

1847
01:25:22,330 --> 01:25:24,730
come with a function called get_positive_int.

1848
01:25:24,730 --> 01:25:25,772
It comes with get_int.

1849
01:25:25,772 --> 01:25:27,730
And you could imagine programs where you really

1850
01:25:27,730 --> 01:25:31,450
want a positive integer from the human, because negative numbers for a game

1851
01:25:31,450 --> 01:25:33,820
or for some program just would make no sense.

1852
01:25:33,820 --> 01:25:35,380
So how can we implement that?

1853
01:25:35,380 --> 01:25:38,350
Well, it would be nice to create it so that you can simply

1854
01:25:38,350 --> 01:25:40,930
write a two-line program like this where you call

1855
01:25:40,930 --> 01:25:42,820
a function called get_positive_int.

1856
01:25:42,820 --> 01:25:46,720
And if I scroll down, notice there's actually a new feature

1857
01:25:46,720 --> 01:25:49,810
here that we've not seen yet, but it's an interesting example

1858
01:25:49,810 --> 01:25:52,600
of another feature of C. What I've highlighted here

1859
01:25:52,600 --> 01:25:56,350
between lines 15 and 24 is this logic.

1860
01:25:56,350 --> 01:25:58,510
Here's a function called get_positive_int.

1861
01:25:58,510 --> 01:26:01,690
It takes no inputs, so I don't have to pass anything in parentheses.

1862
01:26:01,690 --> 01:26:03,850
I just want to get any old positive int.

1863
01:26:03,850 --> 01:26:06,670
But I do want this function to hand me back something,

1864
01:26:06,670 --> 01:26:09,850
just like get_int handed me back a value that I could put in a variable,

1865
01:26:09,850 --> 01:26:11,170
just like get_string does.

1866
01:26:11,170 --> 01:26:13,030
So this is not void.

1867
01:26:13,030 --> 01:26:13,990
This is int.

1868
01:26:13,990 --> 01:26:17,290
So this word to the left of a function is the type of its output.

1869
01:26:17,290 --> 01:26:20,920
This word in parentheses is the type of its input, if any.

1870
01:26:20,920 --> 01:26:24,640
And if there is nothing, you just say void in either or both place.

1871
01:26:24,640 --> 01:26:26,190
Now, here's a curiosity--

1872
01:26:26,190 --> 01:26:30,280
on line 17, we've not seen this before, but this is just a hint to the computer

1873
01:26:30,280 --> 01:26:32,425
saying give me a variable called n.

1874
01:26:32,425 --> 01:26:34,300
I'm not sure what I'm going to put in it yet.

1875
01:26:34,300 --> 01:26:36,580
So you literally just say int n semicolon.

1876
01:26:36,580 --> 01:26:38,405
You don't need to assign it anything yet.

1877
01:26:38,405 --> 01:26:40,030
It has what we'll call a garbage value.

1878
01:26:40,030 --> 01:26:42,322
You have no idea what's in it, but that doesn't matter.

1879
01:26:42,322 --> 01:26:43,730
You'll put something in it later.

1880
01:26:43,730 --> 01:26:45,820
Then there's this loop, which we haven't seen yet,

1881
01:26:45,820 --> 01:26:47,800
but in C, it's called a do-while loop.

1882
01:26:47,800 --> 01:26:52,120
It literally says do the following while this Boolean expression is true.

1883
01:26:52,120 --> 01:26:53,320
So what do I want to do?

1884
01:26:53,320 --> 01:26:55,330
I want to get an int from the user, prompting

1885
01:26:55,330 --> 01:26:58,540
the human for a positive integer, and store it in n.

1886
01:26:58,540 --> 01:27:03,010
However, I want to keep doing this while n is less than 1.

1887
01:27:03,010 --> 01:27:06,370
Because if the human types in 0 or negative 1 or negative 50

1888
01:27:06,370 --> 01:27:12,040
or anything non-positive, I do want to prompt them again and again and again.

1889
01:27:12,040 --> 01:27:14,530
So a do-while loop is kind of neat, because it

1890
01:27:14,530 --> 01:27:17,090
will do this first thing at least once.

1891
01:27:17,090 --> 01:27:20,200
Then it will check the condition and potentially do it again

1892
01:27:20,200 --> 01:27:22,450
if the human has not cooperated.

1893
01:27:22,450 --> 01:27:25,900
A while loop, if you think back, actually checked the condition first.

1894
01:27:25,900 --> 01:27:29,590
It was while some Boolean expression is true, do the following.

1895
01:27:29,590 --> 01:27:34,210
This one gives you one such iteration, one pass for free,

1896
01:27:34,210 --> 01:27:35,767
and then it checks the condition.

1897
01:27:35,767 --> 01:27:37,600
So it's just a different way of programming,

1898
01:27:37,600 --> 01:27:40,090
but we could do everything we've done thus far using

1899
01:27:40,090 --> 01:27:46,550
while loops or even for loops, as well.

1900
01:27:46,550 --> 01:27:50,080
All right, well let's go ahead now and make this a little more user friendly.

1901
01:27:50,080 --> 01:27:54,790
Let me go ahead and pull up some examples here of some screens that

1902
01:27:54,790 --> 01:27:56,060
might look familiar.

1903
01:27:56,060 --> 01:27:58,488
So if I go ahead and open up, for instance,

1904
01:27:58,488 --> 01:28:00,280
this slide here, you might recall this game

1905
01:28:00,280 --> 01:28:04,000
from yesteryear, Super Mario Brothers 1, from the very original Nintendo.

1906
01:28:04,000 --> 01:28:07,510
And there's some screens in that game that look a little something like this.

1907
01:28:07,510 --> 01:28:09,100
For instance, these are little bricks in the air

1908
01:28:09,100 --> 01:28:11,200
that if Mario or Luigi hits their head up against,

1909
01:28:11,200 --> 01:28:13,450
like a coin or something else pops out.

1910
01:28:13,450 --> 01:28:16,810
But this is kind of a nice idea, because it lends itself to actually doing

1911
01:28:16,810 --> 01:28:18,535
something a little programmatically.

1912
01:28:18,535 --> 01:28:21,160
For instance, how might I go about writing a program that quite

1913
01:28:21,160 --> 01:28:23,800
simply prints out four question marks?

1914
01:28:23,800 --> 01:28:26,920
Well, let me go ahead and open up, for instance, in code,

1915
01:28:26,920 --> 01:28:30,100
an example called mario0.c.

1916
01:28:30,100 --> 01:28:33,087
And I claim that this could be one way of implementing this program.

1917
01:28:33,087 --> 01:28:35,170
It's very simple, and it really doesn't do justice

1918
01:28:35,170 --> 01:28:39,400
to the other graphics on the screen, but it does implement that one idea.

1919
01:28:39,400 --> 01:28:41,800
And indeed, somewhere in the code for Mario,

1920
01:28:41,800 --> 01:28:43,600
there was probably some line of code that

1921
01:28:43,600 --> 01:28:47,950
told the console game to print question mark, question mark, question

1922
01:28:47,950 --> 01:28:48,970
mark, question mark.

1923
01:28:48,970 --> 01:28:51,760
In C, we could certainly do this with four question marks.

1924
01:28:51,760 --> 01:28:55,048
Or how else could we do something that many times?

1925
01:28:55,048 --> 01:28:55,840
AUDIENCE: For loop.

1926
01:28:55,840 --> 01:28:57,465
DAVID MALAN: Something like a for loop.

1927
01:28:57,465 --> 01:29:00,310
So let me go ahead and jump ahead a couple of iterations

1928
01:29:00,310 --> 01:29:05,200
to an example I'll call mario2.c, which just does all of this.

1929
01:29:05,200 --> 01:29:08,500
So this is actually pretty involved, but notice what it's doing.

1930
01:29:08,500 --> 01:29:12,010
In main, I'm saying, hey, give me an integer called n.

1931
01:29:12,010 --> 01:29:14,630
Do the following while n is less than 1.

1932
01:29:14,630 --> 01:29:18,820
So this is just a way of asking, what is the width of the blocks

1933
01:29:18,820 --> 01:29:20,140
that you want to print?

1934
01:29:20,140 --> 01:29:24,190
Then, once I have that answer, I can go ahead and, just as before,

1935
01:29:24,190 --> 01:29:28,940
print that many question marks n times, one at a time.

1936
01:29:28,940 --> 01:29:32,080
And at the very end, I'll print just a new line.

1937
01:29:32,080 --> 01:29:35,470
So in short, if you want to create a program, albeit in text,

1938
01:29:35,470 --> 01:29:37,760
that does something like this, and I make mario2--

1939
01:29:37,760 --> 01:29:38,410
whoops.

1940
01:29:38,410 --> 01:29:43,510
And I make mario2, Enter, and type ./mario2,

1941
01:29:43,510 --> 01:29:46,510
I can do a width of four and get four question marks.

1942
01:29:46,510 --> 01:29:49,730
Or I can do 50 and get many more on the screen, all

1943
01:29:49,730 --> 01:29:51,480
by just using these basic building blocks.

1944
01:29:51,480 --> 01:29:54,660
But notice, because of that do-while loop, if I don't cooperate

1945
01:29:54,660 --> 01:29:58,110
and I do something like 0 or negative 1 or negative 50,

1946
01:29:58,110 --> 01:30:02,160
I just keep getting prompted again and again, because n is less than 1.

1947
01:30:02,160 --> 01:30:05,130
That's the kind of logic that you can impose there.

1948
01:30:05,130 --> 01:30:10,018
But let's go ahead and skip ahead, say, to something like this in Mario,

1949
01:30:10,018 --> 01:30:12,060
where you have a whole lot of bricks underground.

1950
01:30:12,060 --> 01:30:16,000
And this time, it's not just a column or a row of bricks.

1951
01:30:16,000 --> 01:30:17,755
This time, it's kind of two dimensions.

1952
01:30:17,755 --> 01:30:20,130
Well, this is kind of interesting, because now how do you

1953
01:30:20,130 --> 01:30:23,200
go about printing block, block, block, block, block, block, block, block,

1954
01:30:23,200 --> 01:30:25,158
block, block, block, block, and actually making

1955
01:30:25,158 --> 01:30:26,700
a two-dimensional structure instead?

1956
01:30:26,700 --> 01:30:30,090
Well, there's nothing stopping us in C, as in Scratch,

1957
01:30:30,090 --> 01:30:33,540
from doing something, for instance, with loops.

1958
01:30:33,540 --> 01:30:35,650
So let me show this example here.

1959
01:30:35,650 --> 01:30:38,070
So suppose that with these first lines of code,

1960
01:30:38,070 --> 01:30:41,938
I've asked the user for the size of this block.

1961
01:30:41,938 --> 01:30:44,730
So I want to create something that's square-like like this-- block,

1962
01:30:44,730 --> 01:30:47,710
block, block, block, block, block, block, block, block, and so forth.

1963
01:30:47,710 --> 01:30:51,270
Well, I can go ahead and prompt them for an int again and again

1964
01:30:51,270 --> 01:30:53,500
and again until I know that size.

1965
01:30:53,500 --> 01:30:54,930
And then notice this.

1966
01:30:54,930 --> 01:30:58,770
This is starting to escalate again, but consider the logic.

1967
01:30:58,770 --> 01:31:02,520
This now is for int i get 0, i less than n, i plus plus.

1968
01:31:02,520 --> 01:31:04,500
So do the following n times, right?

1969
01:31:04,500 --> 01:31:08,220
This is a very cryptic, C-like way of saying, do the following n times.

1970
01:31:08,220 --> 01:31:10,170
What about line 16?

1971
01:31:10,170 --> 01:31:13,740
What is line 16 saying?

1972
01:31:13,740 --> 01:31:16,710
Even though it's using a different variable.

1973
01:31:16,710 --> 01:31:18,869
I'm using j just because instead of i.

1974
01:31:18,869 --> 01:31:19,744
AUDIENCE: Same thing.

1975
01:31:19,744 --> 01:31:20,786
Do the following n times.

1976
01:31:20,786 --> 01:31:24,180
DAVID MALAN: Yeah, it says the exact same thing-- do the following n times.

1977
01:31:24,180 --> 01:31:26,880
However, it's counting using j instead of i,

1978
01:31:26,880 --> 01:31:30,100
just so that my math doesn't kind of commingle incorrectly.

1979
01:31:30,100 --> 01:31:32,580
So if you think about what this Mario block is,

1980
01:31:32,580 --> 01:31:35,318
this is like printing rows and columns.

1981
01:31:35,318 --> 01:31:37,860
Kind of like an old school typewriter that's got to move from

1982
01:31:37,860 --> 01:31:41,250
left to right and then top to bottom, top to bottom, left to right,

1983
01:31:41,250 --> 01:31:44,610
and so forth just to print different blocks on different lines.

1984
01:31:44,610 --> 01:31:47,010
So the effect here-- if I open up mario8--

1985
01:31:47,010 --> 01:31:48,730
might be this, make-- oops.

1986
01:31:48,730 --> 01:31:53,193
Let me go ahead and make mario8, ./mario8.

1987
01:31:53,193 --> 01:31:54,360
What's the size going to be?

1988
01:31:54,360 --> 01:31:55,680
Well, maybe three.

1989
01:31:55,680 --> 01:32:00,030
And now I've printed out three rows and three columns.

1990
01:32:00,030 --> 01:32:03,930
These essentially represent each of my rows.

1991
01:32:03,930 --> 01:32:05,830
I'm counting from i up to--

1992
01:32:05,830 --> 01:32:07,450
oh.

1993
01:32:07,450 --> 01:32:10,980
I'm teaching myself now only, OK.

1994
01:32:10,980 --> 01:32:11,760
Let's rewind.

1995
01:32:11,760 --> 01:32:13,950
Here is what was amazing me a moment ago.

1996
01:32:13,950 --> 01:32:16,770
When I was running what's the size of this program,

1997
01:32:16,770 --> 01:32:19,140
I saw a three-by-three grid of blocks.

1998
01:32:19,140 --> 01:32:21,450
And if I run it again, maybe with 10, I now

1999
01:32:21,450 --> 01:32:24,003
see an even bigger grid of 10-by-10 bricks.

2000
01:32:24,003 --> 01:32:26,670
It's a little taller than it is wide, because the hash marks are

2001
01:32:26,670 --> 01:32:27,960
taller than they are wide.

2002
01:32:27,960 --> 01:32:30,390
And you'll see that now this program is dynamic.

2003
01:32:30,390 --> 01:32:31,950
So how is that working?

2004
01:32:31,950 --> 01:32:33,950
Well, if I actually look at the code here,

2005
01:32:33,950 --> 01:32:36,750
notice that, effectively, what line 14 is doing

2006
01:32:36,750 --> 01:32:39,030
is it's doing one row at a time.

2007
01:32:39,030 --> 01:32:43,170
It's giving me n rows, and each of those rows I'm thinking of this is i at 0,

2008
01:32:43,170 --> 01:32:46,020
i1, i2, and so forth.

2009
01:32:46,020 --> 01:32:50,650
Meanwhile, within each row, I'm using this inner loop,

2010
01:32:50,650 --> 01:32:54,900
which is deliberately nested inside, to kind of do each of the characters

2011
01:32:54,900 --> 01:32:55,990
from left to right.

2012
01:32:55,990 --> 01:32:58,680
So within each row, I want hash, hash, hash, hash.

2013
01:32:58,680 --> 01:33:00,750
Within each row-- hash, hash, hash, hash.

2014
01:33:00,750 --> 01:33:03,670
So it's like implementing this two-dimensional process.

2015
01:33:03,670 --> 01:33:06,900
But again, using the same fundamental ideas.

2016
01:33:06,900 --> 01:33:11,370
Just a for loop that's very carefully counting from zero on up

2017
01:33:11,370 --> 01:33:16,032
to some value to do something again and again and again.

2018
01:33:16,032 --> 01:33:18,240
And so if you think about really any of today's games

2019
01:33:18,240 --> 01:33:21,150
or graphics or programs, anytime you see redundancy,

2020
01:33:21,150 --> 01:33:24,600
whether it's this in two dimensions-- maybe it's this vertically in one

2021
01:33:24,600 --> 01:33:26,712
dimension or this horizontally in another.

2022
01:33:26,712 --> 01:33:29,670
Odds are, there's just some repetition that's happening again and again

2023
01:33:29,670 --> 01:33:33,510
and again that can be reduced in C or in Scratch or some other language

2024
01:33:33,510 --> 01:33:36,780
to ultimately just lines of code.

2025
01:33:36,780 --> 01:33:39,270
And indeed, this is an allusion to one of the first things

2026
01:33:39,270 --> 01:33:41,760
you'll do for the first problem set, problem set 1.

2027
01:33:41,760 --> 01:33:45,180
You'll use CS50 Lab, which is identical to CS50 Sandbox, which

2028
01:33:45,180 --> 01:33:48,090
I've been using thus far, but which adds instructions,

2029
01:33:48,090 --> 01:33:52,170
the actual problems to solve, alongside of your sandbox.

2030
01:33:52,170 --> 01:33:55,470
But before we tease you with that, let's just

2031
01:33:55,470 --> 01:34:00,720
consider now that there are a bunch of little assumptions I've been making.

2032
01:34:00,720 --> 01:34:03,060
Like thus far, all of the mistakes in my code

2033
01:34:03,060 --> 01:34:06,990
have been my own-- some intentional, but several unintentional, as well, today.

2034
01:34:06,990 --> 01:34:10,560
But it turns out that computers themselves do have limitations.

2035
01:34:10,560 --> 01:34:12,810
Inside of your Mac or PC is generally stuff like this.

2036
01:34:12,810 --> 01:34:14,372
This is called memory, or RAM.

2037
01:34:14,372 --> 01:34:16,080
And you don't typically see it unless you

2038
01:34:16,080 --> 01:34:18,900
remove the cover from your phone or your laptop or desktop.

2039
01:34:18,900 --> 01:34:22,680
RAM is where all of your programs are stored while they're running.

2040
01:34:22,680 --> 01:34:26,190
RAM is where all of your programs-- where all of your files are

2041
01:34:26,190 --> 01:34:27,540
stored while they're open.

2042
01:34:27,540 --> 01:34:30,930
It's what your computer uses to do multiple things at once

2043
01:34:30,930 --> 01:34:32,440
and keep things in memory.

2044
01:34:32,440 --> 01:34:35,430
However, it is, by nature of hardware, finite.

2045
01:34:35,430 --> 01:34:38,610
You have maybe one gigabyte, one billion bytes, of memory.

2046
01:34:38,610 --> 01:34:41,400
Maybe you have four gigabytes, or four billion bytes, of memory.

2047
01:34:41,400 --> 01:34:44,280
You have fixed amount of memory in your computer,

2048
01:34:44,280 --> 01:34:48,040
which means there is some fundamental limitation on what your computer can

2049
01:34:48,040 --> 01:34:48,540
do.

2050
01:34:48,540 --> 01:34:52,350
It cannot necessarily count to infinity, because how could it count to infinity

2051
01:34:52,350 --> 01:34:57,020
if it can't store all possible numbers using a finite amount of space?

2052
01:34:57,020 --> 01:34:59,370
Indeed, there are some limits of computation

2053
01:34:59,370 --> 01:35:01,230
that we've only just begun to see.

2054
01:35:01,230 --> 01:35:02,890
In fact, let me go ahead and do this.

2055
01:35:02,890 --> 01:35:06,445
Let me write a program that I'm going to go ahead and call float.c.

2056
01:35:06,445 --> 01:35:09,570
And this is just going to be a program that gets a couple of floating point

2057
01:35:09,570 --> 01:35:11,980
values from the user.

2058
01:35:11,980 --> 01:35:15,000
Let me go ahead and include the CS50 library.

2059
01:35:15,000 --> 01:35:19,420
Let's go ahead and include stdio.h, int main void, as before.

2060
01:35:19,420 --> 01:35:22,488
And all I want to do here with this program is get a couple of floats.

2061
01:35:22,488 --> 01:35:23,280
So give me a float.

2062
01:35:23,280 --> 01:35:24,420
We'll call it x.

2063
01:35:24,420 --> 01:35:26,808
Get_float, and I'll prompt the human for x.

2064
01:35:26,808 --> 01:35:28,350
Then let me go ahead and get another.

2065
01:35:28,350 --> 01:35:29,370
I'll call it y.

2066
01:35:29,370 --> 01:35:31,380
Get_float, quote unquote y.

2067
01:35:31,380 --> 01:35:34,110
And recall that a float is just a number that

2068
01:35:34,110 --> 01:35:36,475
has a decimal point in it, a so-called real number.

2069
01:35:36,475 --> 01:35:38,100
Now let's just do some simple division.

2070
01:35:38,100 --> 01:35:40,990
I claim that computers can do addition, subtraction, and so forth.

2071
01:35:40,990 --> 01:35:41,920
So let's do that.

2072
01:35:41,920 --> 01:35:46,410
Let's just tell it that x divided by y is going to equal the following--

2073
01:35:46,410 --> 01:35:52,150
percent f backslash n x divided by y semicolon.

2074
01:35:52,150 --> 01:35:55,110
So that's just sort of a very simplistic calculator

2075
01:35:55,110 --> 01:35:57,510
that I've implemented that only supports division.

2076
01:35:57,510 --> 01:36:04,170
Let me go ahead and compile this by going and typing make floats.

2077
01:36:04,170 --> 01:36:05,820
And you'll see that it did compile.

2078
01:36:05,820 --> 01:36:07,980
So floats with dot slash.

2079
01:36:07,980 --> 01:36:09,570
x is going to be, say, 1.

2080
01:36:09,570 --> 01:36:10,960
y is going to be 10.

2081
01:36:10,960 --> 01:36:12,120
OK, viola.

2082
01:36:12,120 --> 01:36:15,501
x divided by y equals 0.10000.

2083
01:36:15,501 --> 01:36:16,440
That's pretty nice.

2084
01:36:16,440 --> 01:36:19,570
And recall, if you don't want to see all those zeros, you can just say,

2085
01:36:19,570 --> 01:36:23,160
show me one decimal point by adding 0.1.

2086
01:36:23,160 --> 01:36:25,950
Recompile and then rerun it.

2087
01:36:25,950 --> 01:36:27,790
And now do 1, 10.

2088
01:36:27,790 --> 01:36:29,820
OK, so now it's 1/10.

2089
01:36:29,820 --> 01:36:30,930
Or is it?

2090
01:36:30,930 --> 01:36:33,660
Now that I have this ability to look past the decimal point,

2091
01:36:33,660 --> 01:36:36,900
why don't I look not a few places or one place.

2092
01:36:36,900 --> 01:36:40,440
Let me go ahead and look maybe 10 places after the decimal point.

2093
01:36:40,440 --> 01:36:48,210
Let me rerun this as make floats, ./floats, 1, 10.

2094
01:36:48,210 --> 01:36:49,920
Interesting.

2095
01:36:49,920 --> 01:36:51,627
All right, that seems a little strange.

2096
01:36:51,627 --> 01:36:52,710
Maybe it was just a fluke.

2097
01:36:52,710 --> 01:36:54,043
Let's look out a little further.

2098
01:36:54,043 --> 01:36:56,080
Let's look 50 decimal places out.

2099
01:36:56,080 --> 01:36:57,887
Let's go ahead and recompile this.

2100
01:36:57,887 --> 01:36:59,970
And it turns out, there's some keyboard shortcuts.

2101
01:36:59,970 --> 01:37:02,100
I'm now hitting up and down on my keyboard, which

2102
01:37:02,100 --> 01:37:04,302
will scroll through your entire history of commands

2103
01:37:04,302 --> 01:37:06,010
so you don't have to remember everything.

2104
01:37:06,010 --> 01:37:08,130
So to save time, I'm now just going up and down.

2105
01:37:08,130 --> 01:37:11,850
Let me go ahead and do ./floats now, 1, 10.

2106
01:37:11,850 --> 01:37:14,820
Oh my god, division is a lie.

2107
01:37:14,820 --> 01:37:18,660
So when your grade school teachers or whatnot taught you that 1 divided by 10

2108
01:37:18,660 --> 01:37:24,690
is 1/10, or 0.10000 infinitely, apparently that's not true.

2109
01:37:24,690 --> 01:37:28,810
According to this computer, 1/10 is actually this value.

2110
01:37:28,810 --> 01:37:31,500
So how do we reconcile that?

2111
01:37:31,500 --> 01:37:36,180
Who is right, grade school math or computers?

2112
01:37:36,180 --> 01:37:39,150
And what might explain?

2113
01:37:39,150 --> 01:37:40,860
Any thoughts?

2114
01:37:40,860 --> 01:37:41,850
Yeah?

2115
01:37:41,850 --> 01:37:45,550
AUDIENCE: It only stores so much so then half of that,

2116
01:37:45,550 --> 01:37:47,300
you don't know what's going on over there.

2117
01:37:47,300 --> 01:37:48,800
DAVID MALAN: Yeah, that's a good way of putting it.

2118
01:37:48,800 --> 01:37:51,200
Computers can only store so much, so after a certain point,

2119
01:37:51,200 --> 01:37:52,908
you don't know what's going on out there.

2120
01:37:52,908 --> 01:37:53,480
I like that.

2121
01:37:53,480 --> 01:37:54,710
Because that's indeed true.

2122
01:37:54,710 --> 01:37:57,120
If you only have a finite amount of hardware,

2123
01:37:57,120 --> 01:38:00,830
like a finite amount of memory, at some point, the computer has to decide,

2124
01:38:00,830 --> 01:38:02,780
I can count no higher than this value.

2125
01:38:02,780 --> 01:38:06,890
Or I can store no more than this many numbers after the decimal point.

2126
01:38:06,890 --> 01:38:09,290
You might be using 32 bits, which a float is.

2127
01:38:09,290 --> 01:38:12,470
You could use more bits, like a double, as I described it earlier,

2128
01:38:12,470 --> 01:38:14,720
literally uses twice as many bits, 64 bits.

2129
01:38:14,720 --> 01:38:19,580
So that means we could get farther out before we see that imprecision.

2130
01:38:19,580 --> 01:38:20,870
But you will see it.

2131
01:38:20,870 --> 01:38:24,440
Computers are, indeed, not perfect in this sense.

2132
01:38:24,440 --> 01:38:26,780
They can only store a finite amount of information.

2133
01:38:26,780 --> 01:38:31,190
And so in that sense, the computer is storing the closest possible match

2134
01:38:31,190 --> 01:38:34,190
for 1 divided by 10 that it can.

2135
01:38:34,190 --> 01:38:38,090
Because you can't possibly store an infinite number of numbers 100%

2136
01:38:38,090 --> 01:38:42,080
precisely using a finite amount of information.

2137
01:38:42,080 --> 01:38:44,060
And we see this in another context, too.

2138
01:38:44,060 --> 01:38:48,530
Let me go ahead and write one other program here called overflow.c.

2139
01:38:48,530 --> 01:38:50,990
And we'll see the same issue in another context.

2140
01:38:50,990 --> 01:38:54,350
Let me go ahead and include stdio.h.

2141
01:38:54,350 --> 01:38:57,410
Let me go ahead and do int main void.

2142
01:38:57,410 --> 01:39:01,190
Let me go ahead and do for int i gets one.

2143
01:39:01,190 --> 01:39:07,478
I'm going to go ahead and just say no condition and do i times equals 2.

2144
01:39:07,478 --> 01:39:09,020
And let me go ahead and just do this.

2145
01:39:09,020 --> 01:39:11,840
Print out the value of i.

2146
01:39:11,840 --> 01:39:15,440
So I'm doing the super quickly, but I just have written a program here

2147
01:39:15,440 --> 01:39:17,510
that's going to start counting at zero.

2148
01:39:17,510 --> 01:39:19,430
It's going to multiply i.

2149
01:39:19,430 --> 01:39:22,562
Star equals just means times two again and again.

2150
01:39:22,562 --> 01:39:25,520
And it's going to do this forever, because I literally and deliberately

2151
01:39:25,520 --> 01:39:27,380
didn't ask a Boolean expression here.

2152
01:39:27,380 --> 01:39:29,352
I could actually just say something like true,

2153
01:39:29,352 --> 01:39:30,810
but I can also just leave it blank.

2154
01:39:30,810 --> 01:39:32,310
So this just means do this forever.

2155
01:39:32,310 --> 01:39:33,590
It's an infinite loop.

2156
01:39:33,590 --> 01:39:36,950
Well, let me go ahead and this is going to fly past the screen here.

2157
01:39:36,950 --> 01:39:40,190
So I'm going to also sleep for one second in between.

2158
01:39:40,190 --> 01:39:43,010
And indeed, there's a function in C called sleep.

2159
01:39:43,010 --> 01:39:45,230
But to use it, you actually have to include

2160
01:39:45,230 --> 01:39:50,092
another file called unistandard.h.

2161
01:39:50,092 --> 01:39:52,550
You would only know this from looking in the documentation,

2162
01:39:52,550 --> 01:39:55,820
but it's a handy function that lets me sleep one second at a time.

2163
01:39:55,820 --> 01:39:57,920
Let me go ahead and make overflow.

2164
01:39:57,920 --> 01:39:58,650
No errors.

2165
01:39:58,650 --> 01:40:00,650
Let me increase the size of my screen.

2166
01:40:00,650 --> 01:40:02,600
And let me go ahead and run overflow.

2167
01:40:02,600 --> 01:40:06,530
And we'll see that every one second, it prints out a value starting at one,

2168
01:40:06,530 --> 01:40:08,780
and then it doubles it, and then it doubles it,

2169
01:40:08,780 --> 01:40:10,760
and then it doubles it again.

2170
01:40:10,760 --> 01:40:13,220
So you might recall some of these values from last week,

2171
01:40:13,220 --> 01:40:16,620
where I proposed that were 1,024 pages in a phone book,

2172
01:40:16,620 --> 01:40:18,893
and then it just got smaller and smaller and smaller.

2173
01:40:18,893 --> 01:40:20,310
Now we're just doing the opposite.

2174
01:40:20,310 --> 01:40:22,970
We're doubling by two, by two, by two.

2175
01:40:22,970 --> 01:40:26,090
We're just past a million now, 2 million, 4 million, 8 million,

2176
01:40:26,090 --> 01:40:27,077
16 million.

2177
01:40:27,077 --> 01:40:28,160
So we're getting up there.

2178
01:40:28,160 --> 01:40:30,770
So it looks like integers are pretty big.

2179
01:40:30,770 --> 01:40:35,720
They're indeed using 32 bits in a computer that apparently--

2180
01:40:35,720 --> 01:40:38,150
what just happened?

2181
01:40:38,150 --> 01:40:39,170
Another lie.

2182
01:40:39,170 --> 01:40:44,360
If you just multiply some integer by two forever, it eventually becomes zero,

2183
01:40:44,360 --> 01:40:46,310
it would seem.

2184
01:40:46,310 --> 01:40:48,153
That, too, is not right.

2185
01:40:48,153 --> 01:40:49,070
But what has happened?

2186
01:40:49,070 --> 01:40:51,770
And there's kind of an illusion to it, both in my program's name

2187
01:40:51,770 --> 01:40:53,240
and in the red error.

2188
01:40:53,240 --> 01:40:56,750
Well, at some point, you only have so many bits

2189
01:40:56,750 --> 01:40:59,840
after which if you keep incrementing, incrementing, incrementing,

2190
01:40:59,840 --> 01:41:02,600
you don't have enough bits to sort of carry the one, so to speak,

2191
01:41:02,600 --> 01:41:04,580
and remember the even bigger value.

2192
01:41:04,580 --> 01:41:08,000
After all, if we go back to some of our discussion last week to discuss now

2193
01:41:08,000 --> 01:41:12,240
what's called floating point imprecision or now integer overflow,

2194
01:41:12,240 --> 01:41:14,720
which means floats can only be so precise

2195
01:41:14,720 --> 01:41:16,830
and integers can only be so big.

2196
01:41:16,830 --> 01:41:18,670
What you have is the following scenario.

2197
01:41:18,670 --> 01:41:21,253
123 in decimal, in our human world--

2198
01:41:21,253 --> 01:41:23,170
of course, you can just keep adding one to it.

2199
01:41:23,170 --> 01:41:26,630
And as soon as you hit nine, it rolls over to zero.

2200
01:41:26,630 --> 01:41:29,240
You then carry the one, and you have 130.

2201
01:41:29,240 --> 01:41:30,380
That works great.

2202
01:41:30,380 --> 01:41:36,050
But of course, even in decimal, if you're at 999 using only three digits

2203
01:41:36,050 --> 01:41:39,440
and you try to add one more, you carry the one, you carry the one,

2204
01:41:39,440 --> 01:41:41,000
you lose the one.

2205
01:41:41,000 --> 01:41:41,840
Sorry.

2206
01:41:41,840 --> 01:41:43,110
What happens next?

2207
01:41:43,110 --> 01:41:47,030
This becomes 1, 0, 0, 0.

2208
01:41:47,030 --> 01:41:50,420
But if you only have three digits, you lose that initial one,

2209
01:41:50,420 --> 01:41:51,890
and you're left with just zero.

2210
01:41:51,890 --> 01:41:53,150
Same thing happens in binary.

2211
01:41:53,150 --> 01:41:54,690
Now if you context switch--

2212
01:41:54,690 --> 01:41:58,860
and this is, in binary, what number?

2213
01:41:58,860 --> 01:42:01,580
This is the fours place, twos place, ones.

2214
01:42:01,580 --> 01:42:02,420
So it's seven.

2215
01:42:02,420 --> 01:42:04,280
4 plus 2 plus 1, this is 7.

2216
01:42:04,280 --> 01:42:06,230
So of course, if you add 1 to 7, you'd like

2217
01:42:06,230 --> 01:42:10,010
to get 8, which would give you 1, 0, 0.

2218
01:42:10,010 --> 01:42:13,370
But if you only have three bits, three digits,

2219
01:42:13,370 --> 01:42:15,740
you're going to overflow, so to speak.

2220
01:42:15,740 --> 01:42:19,400
You're going to lose the carried one so that the value you're actually storing

2221
01:42:19,400 --> 01:42:20,600
is just zero.

2222
01:42:20,600 --> 01:42:23,600
That's why if I count high enough with an integer in a program,

2223
01:42:23,600 --> 01:42:28,010
once I hit the billions, eventually that one has gotten carried too far.

2224
01:42:28,010 --> 01:42:30,620
It's only 32 bits large.

2225
01:42:30,620 --> 01:42:33,530
We can't fit a number even bigger than that.

2226
01:42:33,530 --> 01:42:35,240
That's what's called integer overflow.

2227
01:42:35,240 --> 01:42:38,340
And if you ever heard of the Y2K problem,

2228
01:42:38,340 --> 01:42:43,340
this was a horrible, very simple problem that humans created for themselves

2229
01:42:43,340 --> 01:42:46,960
back in the day when computers were invented in the mid 1900s, really.

2230
01:42:46,960 --> 01:42:50,410
Humans decided to save space, very reasonable, because space was expensive

2231
01:42:50,410 --> 01:42:51,260
early on.

2232
01:42:51,260 --> 01:42:58,452
So instead of storing the year as 1999 or 1970 for 1970, what did they do?

2233
01:42:58,452 --> 01:43:00,160
Yeah, they just stored two digits, right?

2234
01:43:00,160 --> 01:43:01,480
Like oh my god, we're not going to be using

2235
01:43:01,480 --> 01:43:03,190
these computers 50 years from now.

2236
01:43:03,190 --> 01:43:04,570
Let's just store two digits.

2237
01:43:04,570 --> 01:43:06,573
Unfortunately, that was not the case.

2238
01:43:06,573 --> 01:43:09,490
And there was a lot of code out there and a lot of computers out there

2239
01:43:09,490 --> 01:43:12,040
that were still running in 1999.

2240
01:43:12,040 --> 01:43:17,080
But if you're only storing two digits and you plus plus one value

2241
01:43:17,080 --> 01:43:20,020
to the year, what you'd like to be 2000 was

2242
01:43:20,020 --> 01:43:25,120
misinterpreted in lots of systems as 1900, at which point stuff broke.

2243
01:43:25,120 --> 01:43:27,580
And the world spent millions of dollars, presumably,

2244
01:43:27,580 --> 01:43:30,160
having programmers start using more memory

2245
01:43:30,160 --> 01:43:32,650
to fix this problem in anticipation of what was called

2246
01:43:32,650 --> 01:43:35,860
Y2K to get ahead of this problem.

2247
01:43:35,860 --> 01:43:38,890
And in the end, the world did not end in 1999, which was great.

2248
01:43:38,890 --> 01:43:40,930
But it was a very real and a very expensive

2249
01:43:40,930 --> 01:43:43,570
problem because of that lack of foresight.

2250
01:43:43,570 --> 01:43:46,400
It turns out that there's other examples of this, as well.

2251
01:43:46,400 --> 01:43:50,980
So this one, as an example, will just about end on Boeing 787.

2252
01:43:50,980 --> 01:43:53,737
So Boeing has not been getting great press recently.

2253
01:43:53,737 --> 01:43:55,570
And even a few years ago, did they have what

2254
01:43:55,570 --> 01:43:58,150
appeared to be a very straightforward software bug.

2255
01:43:58,150 --> 01:44:01,300
Pictured here is a model 787 airplane.

2256
01:44:01,300 --> 01:44:04,210
And the article from The New York Times explained as follows--

2257
01:44:04,210 --> 01:44:09,130
"A model 787 airplane that has been powered continuously for 248 days

2258
01:44:09,130 --> 01:44:12,070
can lose all alternating current, electrical power,

2259
01:44:12,070 --> 01:44:14,380
due to the generator control units simultaneously

2260
01:44:14,380 --> 01:44:15,940
going into failsafe mode.

2261
01:44:15,940 --> 01:44:17,920
This condition is caused by a software counter

2262
01:44:17,920 --> 01:44:20,920
internal to the counters that will overflow

2263
01:44:20,920 --> 01:44:24,550
after 248 days of continuous power.

2264
01:44:24,550 --> 01:44:26,920
Boeing, according to the statement, is in the process

2265
01:44:26,920 --> 01:44:30,550
of developing a software upgrade that will remedy the safe condition."

2266
01:44:30,550 --> 01:44:31,578
So what does this mean?

2267
01:44:31,578 --> 01:44:33,370
Well, if you actually dig into the numbers,

2268
01:44:33,370 --> 01:44:41,560
248 days is roughly the value of 2 raised to the 32nd power,

2269
01:44:41,560 --> 01:44:44,467
give or take, in 1/100 of a second.

2270
01:44:44,467 --> 01:44:47,050
Which is to say that Boeing, in some crucial piece of hardware

2271
01:44:47,050 --> 01:44:51,640
in their 787 actual airplanes, were using integers

2272
01:44:51,640 --> 01:44:56,140
that were counting so high that after the 248th day of the airplane being

2273
01:44:56,140 --> 01:44:59,230
powered on would actually overflow, the result of which

2274
01:44:59,230 --> 01:45:01,900
is that the power in the plane could cut off entirely.

2275
01:45:01,900 --> 01:45:05,140
And so the solution, if you read through all the technical speak and jargon

2276
01:45:05,140 --> 01:45:09,970
there, is they literally had to reboot their planes every 248 days

2277
01:45:09,970 --> 01:45:13,270
in order to reset that variable back to zero.

2278
01:45:13,270 --> 01:45:16,870
This happens even today in the real world with issues like that.

2279
01:45:16,870 --> 01:45:19,540
And so you'll begin to notice these trends anytime people talk

2280
01:45:19,540 --> 01:45:21,760
about hardware mistakes or software mistakes.

2281
01:45:21,760 --> 01:45:24,700
Quite honestly, can you typically reduce them to problems

2282
01:45:24,700 --> 01:45:26,690
you yourselves have run into.

2283
01:45:26,690 --> 01:45:30,310
And let me go ahead and tease just a couple of things, a couple of features

2284
01:45:30,310 --> 01:45:31,390
now ahead.

2285
01:45:31,390 --> 01:45:34,450
It turns out that now that we have the ability to write code,

2286
01:45:34,450 --> 01:45:37,630
our programs, of course, can do any number of things, saying or printing

2287
01:45:37,630 --> 01:45:38,657
things on the screen.

2288
01:45:38,657 --> 01:45:40,990
We, of course, might do something like this in a program

2289
01:45:40,990 --> 01:45:43,900
we might call figlet, which actually comes with some systems.

2290
01:45:43,900 --> 01:45:46,630
And I can say something like, this is CS50,

2291
01:45:46,630 --> 01:45:49,540
and actually print it out in what's called ASCII art using characters

2292
01:45:49,540 --> 01:45:51,707
on the screen that kind of sort of look like letters

2293
01:45:51,707 --> 01:45:55,520
and create fairly beautiful, if old school, art on the screen.

2294
01:45:55,520 --> 01:45:58,210
Of course, if you write code and you understand

2295
01:45:58,210 --> 01:46:01,450
not only how numbers and letters are represented, but also sounds,

2296
01:46:01,450 --> 01:46:04,270
per our chat last week, you can do even more powerful things,

2297
01:46:04,270 --> 01:46:08,900
such as this note, which we will literally end on today.

2298
01:46:08,900 --> 01:46:10,217
SPEAKER 2: This is CS50.

2299
01:46:10,217 --> 01:46:11,550
DAVID MALAN: That's it for CS50.

2300
01:46:11,550 --> 01:46:13,210
We will see you next week.

2301
01:46:13,210 --> 01:46:15,060
[APPLAUSE]

