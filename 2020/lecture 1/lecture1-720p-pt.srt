0
00: 00: 00.000 -> 00: 00: 00.994


1
00: 00: 00,994 -> 00: 00: 03.976
[MÚSICA, TOCANDO]

2
00: 00: 03,976 -> 00: 01: 23.496


3
00: 01: 23,496 -> 00: 01: 27.907
DAVID MALAN: Muito bem, este é o CS50, e este é um dia muito emocionante,

4
00: 01: 27,907 -> 00: 01: 29.990
porque hoje vamos aprender um nova linguagem.

5
00: 01: 29,990 -> 00: 01: 33.020
E isso não é algo que você pode dizer que acontece com você todos os dias.

6
00: 01: 33,020 -> 00: 01: 35.810
E essa linguagem vai se parecer um pouco com isso.

7
00: 01: 35,810 -> 00: 01: 37.220
Hoje, apresentamos C -

8
00: 01: 37,220 -> 00: 01: 41.690
uma linguagem muito tradicional, muito antiga, puramente baseada em texto,

9
00: 01: 41,690 -> 00: 01: 45.230
mas pode fazer tudo o que você pode fazer no Scratch e ainda mais,

10
00: 01: 45,230 -> 00: 01: 47.810
mas sem a interface amigável que estávamos

11
00: 01: 47,810 -> 00: 01: 49.370
acostumados nos últimos dias.

12
00: 01: 49,370 -> 00: 01: 52.490
Embora, no entanto isso possa parecer muito enigmático para você à primeira vista,

13
00: 01: 52,490 -> 00: 01: 55.280
mesmo que haja algumas palavras em inglês ou parecidas com o inglês nisso,

14
00: 01: 55,280 -> 00: 01: 58.200
tenha certeza de que dentro de alguns dias, certamente dentro de algumas semanas,

15
00: 01: 58,200 -> 00: 02: 00.658
você será capaz de entender cada caractere nesta tela,

16
00: 02: 00,658 -> 00: 02: 02.520
cada linha de código e muito mais.

17
00: 02: 02,520 -> 00: 02: 06.157
Mas ouso dizer que qualquer curso como este pode ser um pouco assustador, especialmente

18
00: 02: 06,157 -> 00: 02: 07.490
se você não tem experiência anterior.

19
00: 02: 07,490 -> 00: 02: 10.759
Mas lembre-se da semana passada, de que, de fato, a norma, o caso comum

20
00: 02: 10,759 -> 00: 02: 13.490
2/3 dos alunos do CS50 - talvez você entre eles -

21
00: 02: 13,490 -> 00: 02: 16.250
nunca fizeram um curso de ciência da computação antes.

22
00: 02: 16,250 -> 00: 02: 21.462
Então, o que parece assim hoje, perceba, será exatamente assim no final das contas.

23
00: 02: 21,462 -> 00: 02: 24.170
Na verdade, embora o código pareça diferente - opa.

24
00: 02: 24,170 -> 00: 02: 25.670
Mesmo que o código pareça diferente,

25
00: 02: 25,670 -> 00: 02: 27.830
as ideias hoje serão absolutamente

26
00: 02: 27,830 -> 00: 02: 30.410
as mesmas da semana passada no Scratch.

27
00: 02: 30,410 -> 00: 02: 33.500
Veremos funções e condições e expressões booleanas, loops,

28
00: 02: 33,500 -> 00: 02: 35.390
e outros recursos ao longo do caminho.

29
00: 02: 35,390 -> 00: 02: 37.800
Mas talvez me remeta a este maravilhoso hack do MIT

30
00: 02: 37,800 -> 00: 02: 42.350
em 1991, uma expressão do MIT, é de que, ter uma educação do MIT

31
00: 02: 42,350 -> 00: 02: 44.630
é como beber água de uma mangueira de incêndio.

32
00: 02: 44,630 -> 00: 02: 46.910
E no espírito dos hacks do MIT, como são chamados,

33
00: 02: 46,910 -> 00: 02: 51.140
alguns alunos conectaram uma mangueira de incêndio real a uma fonte de água real

34
00: 02: 51,140 -> 00: 02: 53.480
com uma placa na parede que diz exatamente isso.

35
00: 02: 53,480 -> 00: 02: 56.240
E este é o tipo de curso, como acontece com muitos cursos introdutórios,

36
00: 02: 56,240 -> 00: 02: 58.990
onde parece que você está realmente sendo atingido no rosto com muitas

37
00: 02: 58,990 -> 00: 03: 04.010
informações, muito mais idéias do que você pode carregar de uma vez.

38
00: 03: 04,010 -> 00: 03: 09.652
Mas perceba que você será capaz de absorver ainda mais material com o tempo.

39
00: 03: 09,652 -> 00: 03: 11.360
E o objetivo da aula, em última análise, é

40
00: 03: 11,360 -> 00: 03: 14.240
para apresentar a você tantos conceitos e habilidades práticas

41
00: 03: 14,240 -> 00: 03: 16.040
quantos possam ser úteis mais tarde.

42
00: 03: 16,040 -> 00: 03: 20.960
E então perceba que no final do semestre você vai se sentir muito menos assim

43
00: 03: 20,960 -> 00: 03: 24.630
e muito mais como algo em que você teve sucesso.

44
00: 03: 24,630 -> 00: 03: 27.880
Então, sem mais delongas, vamos introduzir esta linguagem chamada C.

45
00: 03: 27,880 -> 00: 03: 30.380
À esquerda aqui, lembre-se de que isso talvez era o mais simples

46
00: 03: 30,380 -> 00: 03: 31.910
programa que poderíamos escrever no Scratch.

47
00: 03: 31,910 -> 00: 03: 35.330
E tudo o que este programa fez foi compelir um gato, ou qualquer sprite,

48
00: 03: 35,330 -> 00: 03: 36.760
a dizer olá na tela.

49
00: 03: 36,760 -> 00: 03: 38.960
Hoje, para alcançar esse mesmo resultado, 

50
00: 03: 38,960 -> 00: 03: 42.650
vamos começar a escrever código parecido com este, usando apenas um teclado -

51
00: 03: 42,650 -> 00: 03: 44.690
menos controles gráficos para o usuário.

52
00: 03: 44,690 -> 00: 03: 47.910
Mas vamos ver por que o da esquerda é realmente equivalente ao da direita.

53
00: 03: 47,910 -> 00: 03: 50.390
Então, vamos decompô-lo, digamos, nesta única peça do quebra-cabeça.

54
00: 03: 50,390 -> 00: 03: 53.330
Isso, é claro, fez o que -

55
00: 03: 53,330 -> 00: 03: 55.815
isso representava o quê no contexto de um programa Scratch?

56
00: 03: 55,815 -> 00: 03: 57.440
Qual foi o papel desta peça do quebra-cabeças?

57
00: 03: 57,440 -> 00: 03: 58.700
PÚBLICO: Como começar.

58
00: 03: 58,700 -> 00: 03: 59.850
DAVID MALAN: Sim, para começar.

59
00: 03: 59,850 -> 00: 04: 01.892
Então, para a parte principal do seu programa começar,

60
00: 04: 01,892 -> 00: 04: 05.600
você tem que anexá-lo a esta peça do quebra-cabeça com uma bandeira verde.

61
00: 04: 05,600 -> 00: 04: 08.693
E veremos em C que não é tão simples.

62
00: 04: 08,693 -> 00: 04: 11.360
Mas é algo que você pode simplesmente copiar e colar por enquanto.

63
00: 04: 11,360 -> 00: 04: 15.040
E dentro de alguns dias isso fará mais sentido caractere por caractere.

64
00: 04: 15,040 -> 00: 04: 17.720
Int main void e, em seguida, as chaves abertas,

65
00: 04: 17,720 -> 00: 04: 20.029
é seguido por esta chave fechada

66
00: 04: 20,029 -> 00: 04: 22.940
sugere que todo o código que vamos escrever hoje em diante

67
00: 04: 22,940 -> 00: 04: 26.240
vai ficar entre essas duas chaves opostas

68
00: 04: 26,240 -> 00: 04: 28.770
que envolve de uma peça do quebra-cabeça como esta.

69
00: 04: 28,770 -> 00: 04: 31.785
Mesmo que isso não faça muito sentido hoje ou por alguns dias,

70
00: 04: 31,785 -> 00: 04: 34.160
perceba que é funcionalmente equivalente a apenas dizer

71
00: 04: 34,160 -> 00: 04: 38.070
que a bandeira verde foi clicada, aqui está a parte principal do meu programa.

72
00: 04: 38,070 -> 00: 04: 40.197
Agora, o que um programa pode realmente fazer por você?

73
00: 04: 40,197 -> 00: 04: 43.280
Bem, você pode ter algo como dizer "olá, mundo" no Scratch que apenas

74
00: 04: 43,280 -> 00: 04: 45.030
literalmente imprime isso na tela.

75
00: 04: 45,030 -> 00: 04: 48.260
Então, vamos considerar como você implementaria isso em C,

76
00: 04: 48,260 -> 00: 04: 50.930
sendo uma linguagem baseada em texto ou teclado.

77
00: 04: 50,930 -> 00: 04: 55.490
Bem, não há um verbo ou função chamada "say"/"diga" em C. Em vez disso,

78
00: 04: 55,490 -> 00: 04: 57.410
é chamado de "print"/"imprima", ou não exatamente "print".

79
00: 04: 57,410 -> 00: 05: 00.680
Na verdade, é chamado de "printf", onde f significa formatado

80
00: 05: 00,680 -> 00: 05: 03.860
para que você possa imprimir o texto formatado, como veremos em breve.

81
00: 05: 03,860 -> 00: 05: 07.400
Então, você segue e coloca, ao lado de printf, dois parênteses - um

82
00: 05: 07,400 -> 00: 05: 09.830
parênteses de abertura e o parênteses de fechamento.

83
00: 05: 09,830 -> 00: 05: 14.180
E isso é uma espécie de reminiscência desta forma oval em que usamos anteriormente

84
00:05:14,180 -> 00:05:15.770
colocando a entrada em primeiro lugar.

85
00: 05: 15,770 -> 00: 05: 19.210
E a entrada que colocamos na semana passada foi apenas "diga: olá, mundo".

86
00: 05: 19,210 -> 00: 05: 21.770
Então, literalmente, em C, você vai escrever "hello world"

87
00: 05: 21,770 -> 00: 05: 24.200
entre esses dois parênteses.

88
00: 05: 24,200 -> 00: 05: 25.850
Mas C é um pouco mais minucioso.

89
00: 05: 25,850 -> 00: 05: 28.850
Você não pode simplesmente começar a escrever palavras entre parênteses.

90
00: 05: 28,850 -> 00: 05: 32.870
Sempre que você tiver caracteres, palavras, sentenças ou frases,

91
00: 05: 32,870 -> 00: 05: 36.290
você precisa realmente encapsular esse texto com aspas duplas,

92
00: 05: 36,290 -> 00: 05: 37.090
como neste caso.

93
00: 05: 37,090 -> 00: 05: 40.340
Então você só tem que envolver o que quer que você queira dizer ou imprimir

94
00: 05: 40,340 -> 00: 05: 41.540
com aspas duplas aqui.

95
00: 05: 41,540 -> 00: 05: 44.480
E a última coisa com C que é tão fácil de esquecer no início,

96
00: 05: 44,480 -> 00: 05: 47.520
como você sem dúvida irá, é que você precisa terminar seu pensamento.

97
00: 05: 47,520 -> 00: 05: 51.000
Assim como em uma redação de inglês, você normalmente termina uma frase com um ponto,

98
00: 05: 51.000 -> 00: 05: 52.850
Em C você termina seu pensamento

99
00: 05: 52,850 -> 00: 05: 55.730
Mas não com um ponto, e sim com um ponto e vírgula, geralmente

100
00: 05: 55,730 -> 00: 05: 57.560
no final de uma linha de código.

101
00: 05: 57.560 -> 00: 06: 00.882
Mas veremos quais tipos de linhas de código exigem isso.

102
00: 06: 00,882 -> 00: 06: 02.840
À esquerda, temos uma ideia da semana passada.

103
00: 06: 02,840 -> 00: 06: 06.930
À direita, temos uma ideia desta semana, como veremos em breve no meu computador,

104
00: 06: 06,930 -> 00: 06: 08.930
mas elas são funcionalmente equivalentes.

105
00: 06: 08,930 -> 00: 06: 10.440
Elas fazem a mesma coisa.

106
00: 06: 10,440 -> 00: 06: 13.940
Então, como vamos deste programa Scratch

107
00: 06: 13,940 -> 00: 06: 15.540
para este programa Scratch?

108
00:06:15,540 --> 00:06:18,770
Vamos em frente e pontuar uma ultima coisa.

109
00:06:18,770 --> 00:06:20,840
Precisamos de uma última linha de código, que é apenas

110
00:06:20,840 --> 00:06:24,090
surgiu na tela, que é incluir stdio.h.

111
00:06:24,090 --> 00:06:25,320
Bem, o que isso significa?

112
00:06:25,320 --> 00:06:28,010
Acontece que o Scratch é super amigável.

113
00:06:28,010 --> 00:06:30,600
Você tem todas essas categorias de peças coloridas

114
00:06:30,600 --> 00:06:32,670
à esquerda, e elas estão disponíveis para você

115
00:06:32,670 --> 00:06:35,220
a partir do momento que você começa a usar o Scratch.

116
00:06:35,220 --> 00:06:38,910
No C, quando você quer usar alguma função-- ou alguma peça de quebra-cabeças,

117
00:06:38,910 --> 00:06:39,790
Se quiser--

118
00:06:39,790 --> 00:06:42,240
você tem que tipicamente dizer com antecedência ao computador

119
00:06:42,240 --> 00:06:47,110
Onde essa função está implementada, onde ela está salva.

120
00:06:47,110 --> 00:06:50,340
E isso será reconhecido como uma sintaxe encriptada, e dizendo,

121
00:06:50,340 --> 00:06:52,880
Ei, computador, olhe no arquivo que nós vamos

122
00:06:52,880 --> 00:06:56,640
começar chamando stdio.h, seja lá o que isso signifique

123
00:06:56,640 --> 00:06:58,933
com o objetivo de acessar esta função.

124
00:06:58,933 --> 00:07:00,350
Bem, novamente, este é uma assunto muito extenso.

125
00:07:00,350 --> 00:07:02,400
Está é a nossa primeira mangueira de incêndio de hoje.

126
00:07:02,400 --> 00:07:04,620
Mas a linha importante de código para a proposta de hoje

127
00:07:04,620 --> 00:07:07,470
realmente é essa que está mais para baixo ali no meio.

128
00:07:07,470 --> 00:07:11,040
Então, como faço para escrever meu primeiro programa em C,

129
00:07:11,040 --> 00:07:15,210
Igual na semana passada, quando escrevemos nosso primeiro programa no Scratch?

130
00:07:15,210 --> 00:07:18,540
Bem, considere que a primeira coisa que fizemos no Scratch

131
00:07:18,540 --> 00:07:22,950
era abrir um programa, uma ferramenta - scratch.mit.edu.

132
00: 07: 22,950 -> 00: 07: 25.530
Você pode programar, na verdade, em seu próprio Mac, ou PC,

133
00: 07: 25,530 -> 00: 07: 27.510
não importa qual sistema operacional você está usando.

134
00: 07: 27,510 -> 00: 07: 30.630
Mas, francamente, tende a ser muito irritante e muito sujeito

135
00: 07: 30,630 -> 00: 07: 32.640
a dores de cabeça se todos nós

136
00: 07: 32,640 -> 00: 07: 36.900
tentarmos instalar o software necessário em todos os nossos Macs e PCs individualmente.

137
00: 07: 36,900 -> 00: 07: 39.420
Invariavelmente, todos nós temos diferentes versões das coisas,

138
00: 07: 39,420 -> 00: 07: 41.500
e nossos computadores não funcionam exatamente da mesma forma.

139
00: 07: 41,500 -> 00: 07: 44.440
Portanto, nas primeiras semanas do CS50, usamos uma ferramentas baseadas em nuvem -

140
00: 07: 44,440 -> 00: 07: 48.270
CS50 Sandbox, que reside em sandbox.cs50.io.

141
00: 07: 48,270 -> 00: 07: 51.360
E você usará ela para seu primeiro desafio na próxima semana.

142
00: 07: 51,360 -> 00: 07: 54.280
Este é um ambiente de programação semelhante em espírito ao Scratch,

143
00: 07: 54,280 -> 00: 07: 55.530
mas isso não usa Scratch.

144
00:07:55,530 --> 00:07:57,000
Isto não usa peças de quebra-cabeça.

145
00:07:57,000 --> 00:07:59,730
Ao invés usa C, que é uma linguagem de texto

146
00:07:59,730 --> 00:08:01,530
Que vamos começar a ver agora.

147
00:08:01,530 --> 00:08:04,410
Então há duas partis principais no ambiente deste programa.

148
00:08:04,410 --> 00:08:07,350
Aqui no topo, será onde escrevo meu código real.

149
00:08:07,350 --> 00:08:09,250
Literalmente, em um momento, clicarei naquele sinal de mais,

150
00:08:09,250 --> 00:08:10,708
e vou criar um novo arquivo.

151
00:08:10,708 --> 00:08:13,390
E vou começar a escrever o código nesse arquivo e salvá-lo.

152
00: 08: 13,390 -> 00: 08: 16.038
E então, na metade inferior deste ambiente de programação

153
00: 08: 16,038 -> 00: 08: 18.330
é o que vamos chamar uma janela de terminal.

154
00: 08: 18,330 -> 00: 08: 20.880
Uma janela de terminal é uma espécie de interface das antigas

155
00: 08: 20,880 -> 00: 08: 24.780
através do qual você pode executar comandos digitando-os literalmente em um prompt

156
00: 08: 24,780 -> 00: 08: 25.980
e pressione Enter.

157
00: 08: 25,980 -> 00: 08: 27.330
Tão diferente do Scratch -

158
00: 08: 27,330 -> 00: 08: 29.700
e francamente, ao contrário do Mac OS e do Windows hoje em dia -

159
00: 08: 29,700 -> 00: 08: 32.610
onde você aponta e clica e arrasta e assim por diante, interagindo

160
00: 08: 32,610 -> 00: 08: 35.460
com uma interface gráfica de usuário, muito de nossa programação

161
00: 08: 35,460 -> 00: 08: 38.620
no início vai envolver comandos de digitação.

162
00: 08: 38,620 -> 00: 08: 40.380
Então, vamos tornar isso mais real.

163
00: 08: 40,380 -> 00: 08: 44.580
O objetivo em questão, novamente, é, simplesmente, implementar um programa em C

164
00: 08: 44,580 -> 00: 08: 47.580
que diz olá para o mundo, que funcionalmente será

165
00: 08: 47,580 -> 00: 08: 49.950
semelhante ao programa Scratch à esquerda.

166
00: 08: 49,950 -> 00: 08: 53.295
Mas agora precisamos implementá-lo usando a linguagem certa.

167
00: 08: 53,295 -> 00: 08: 55.170
Então, neste ambiente de programação, vou

168
00: 08: 55,170 -> 00: 08: 59.610
seguir em frente e clicar aqui no sinal de mais para criar um novo arquivo ou guia.

169
00: 08: 59,610 -> 00: 09: 03.090
Por convenção, irei prosseguir e nomear meu arquivo com algo como hello.c.

170
00: 09: 03,090 -> 00: 09: 05.550
Olá só porque quero que este programa diga olá,

171
00: 09: 05,550 -> 00: 09: 07.170
mas eu poderia chamá-lo do que quiser.

172
00: 09: 07,170 -> 00: 09: 10.920
E ponto c porque a convenção, nesta linguagem de programação C,

173
00: 09: 10.920 -> 00: 09: 14.640
é nomear seus arquivos que contêm seu código com este

174
00: 09: 14,640 -> 00: 09: 18.740
ponto c, bem como você tem ponto doc ou ponto docx para Microsoft Word,

175
00: 09: 18,740 -> 00: 09: 22.342
ponto gif para arquivos gráficos e similares.

176
00: 09: 22,342 -> 00: 09: 24.300
Então, vou prosseguir e clicar em Criar arquivo.

177
00: 09: 24,300 -> 00: 09: 27.750
E você verá agora que tenho um prompt piscando na linha 1--

178
00: 09: 27,750 -> 00: 09: 31.530
ele numerará automaticamente minhas linhas - em uma guia chamada hello.c.

179
00: 09: 31,530 -> 00: 09: 33.000
É aqui que posso escrever código.

180
00: 09: 33.000 -> 00: 09: 37.210
Agora, embora o código que estou prestes a escrever seja, francamente, bastante enigmático -

181
00: 09: 37,210 -> 00: 09: 41.400
include stdio.h, int main void.

182
00: 09: 41,400 -> 00: 09: 44.220
E então aqui, vou fazer printf, aspas, aspas,

183
00: 09: 44,220 -> 00: 09: 46.650
ponto e vírgula "hello world".

184
00: 09: 46,650 -> 00: 09: 50.008
Acabei de escrever meu primeiro programa em C.

185
00: 09: 50,008 -> 00: 09: 52.050
Vou prosseguir e aumentar o zoom no canto superior esquerdo.

186
00: 09: 52,050 -> 00: 09: 54.120
São seis linhas de código no total.

187
00: 09: 54,120 -> 00: 09: 57.720
E você verá que incluí stdio.h, o que quer que isso signifique,

188
00: 09: 57,720 -> 00: 09: 59.850
int main void, o que quer que isso signifique.

189
00: 09: 59,850 -> 00: 10: 02.610
E então, realmente, a essência deste programa está na linha 5 -

190
00: 10: 02,610 -> 00: 10: 07.050
print ou printf para formatação, "olá, mundo."

191
00: 10: 07,050 -> 00: 10: 10.050
Portanto, lembre-se de que int main void é semelhante em espírito à

192
00: 10: 10,050 -> 00: 10: 11.580
quando a bandeira verde foi clicada.

193
00: 10: 11,580 -> 00: 10: 13.980
E printf é semelhante ao bloco "diga".

194
00: 10: 13,980 -> 00: 10: 16.350
E essa linha de cima de código, só precisamos dela,

195
00: 10: 16,350 -> 00: 10: 19.320
porque o computador não vai entender printf

196
00: 10: 19,320 -> 00: 10: 22.630
a menos que eu diga para incluir esse arquivo.

197
00: 10: 22,630 -> 00: 10: 26.850
Tudo bem, agora eu proclamo que escrevi algum código.

198
00: 10: 26,850 -> 00: 10: 28.110
Como faço para executá-lo?

199
00: 10: 28,110 -> 00: 10: 32.390
Bem, como você executa um programa no seu Mac ou PC?

200
00: 10: 32,390 -> 00: 10: 34.590
O que você normalmente faz?

201
00: 10: 34,590 -> 00: 10: 36.180
Você clica duas vezes, certo?

202
00: 10: 36,180 -> 00: 10: 39.730
Infelizmente, não parece haver nada óbvio para clicar duas vezes aqui.

203
00: 10: 39,730 -> 00: 10: 41.370
Na verdade, não há nenhum ícone na minha tela.

204
00: 10: 41,370 -> 00: 10: 44.100
E, de fato, ainda não existe um programa em si.

205
00: 10: 44,100 -> 00: 10: 47.760
Porque os computadores, lembre-se da semana passada, não entendem inglês.

206
00: 10: 47,760 -> 00: 10: 49.740
Eles não entendem tecnicamente C, em si.

207
00: 10: 49,740 -> 00: 10: 52.440
Veja qual é a linguagem que os computadores falam e entendem?

208
00: 10: 52,440 -> 00: 10: 53.235
PÚBLICO: Binário.

209
00: 10: 53,235 -> 00: 10: 55.110
DAVID MALAN: Sim, binário, zeros e uns.

210
00: 10: 55,110 -> 00: 10: 56.943
E, no entanto, isso claramente não são zeros e uns.

211
00: 10: 56,943 -> 00: 11: 00.030
E, francamente, nenhum de nós se divertiria se a programação estivesse envolvida,

212
00: 11: 00,030 -> 00: 11: 03.240
hoje em dia, literalmente escrevendo zeros e uns, que, de algum modo,

213
00: 11: 03,240 -> 00: 11: 06.450
se fazia necessário muito tempo atrás.

214
00: 11: 06,450 -> 00: 11: 09.510
Mas hoje em dia, parece que existe uma solução para esse problema.

215
00: 11: 09,510 -> 00: 11: 12.660
Por mais enigmático que pareça para a maioria de nós nesta sala,

216
00: 11: 12,660 -> 00: 11: 15.540
pelo menos você pode imaginar eventualmente ficar confortável,

217
00: 11: 15,540 -> 00: 11: 18.700
provavelmente, com esta sintaxe, uma vez que você aprenda as regras e a sintaxe

218
00: 11: 18,700 -> 00: 11: 19.530
e assim por diante.

219
00: 11: 19,530 -> 00: 11: 22.260
Mas precisamos converter isso de alguma forma para zeros e uns.

220
00: 11: 22,260 -> 00: 11: 25.110
E como fazer isso talvez não seja óbvio.

221
00: 11: 25,110 -> 00: 11: 31.110
Então, se quisermos converter um código como este em zeros e uns

222
00: 11: 31,110 -> 00: 11: 34.770
que o computador entenda, deve haver alguma etapa intermediária.

223
00: 11: 34,770 -> 00: 11: 38.370
Eu realmente preciso, no meu Mac ou PC ou neste ambiente baseado em nuvem,

224
00: 11: 38,370 -> 00: 11: 43.200
um programa que vai ter como entrada meu código-fonte, que

225
00: 11: 43.200 -> 00: 11: 45.650
é aquela linguagem chamada C, e vai produzir

226
00: 11: 45,650 -> 00: 11: 48.000
como saída o que é chamado de código de máquina.

227
00: 11: 48.000 -> 00: 11: 53.400
Portanto, o código-fonte é algo como C ou Python ou Java ou C ++ e talvez outros

228
00: 11: 53,400 -> 00: 11: 54.660
idiomas que você já ouviu falar.

229
00: 11: 54,660 -> 00: 11: 58.170
É uma sintaxe semelhante ao inglês, na qual você escreve programas.

230
00: 11: 58,170 -> 00: 12: 02.760
Código de máquina são os zeros e uns que todo computador realmente entende.

231
00: 12: 02,760 -> 00: 12: 05.970
Então, para ir do código-fonte ao código de máquina,

232
00: 12: 05,970 -> 00: 12: 08.773
deve haver algum tipo de algoritmo ou, mais especificamente,

233
00: 12: 08,773 -> 00: 12: 10.690
um software que faz essa conversão.

234
00: 12: 10,690 -> 00: 12: 14.230
E esse software é o que vamos começar a chamar de compilador.

235
00: 12: 14,230 -> 00: 12: 17.790
Então, vamos escrever código literalmente apenas digitando comandos em um teclado.

236
00: 12: 17,790 -> 00: 12: 20.160
Vamos salvar esses comandos em um arquivo,

237
00: 12: 20,160 -> 00: 12: 21.900
assim como você salvou seu código no Scratch.

238
00: 12: 21,900 -> 00: 12: 24.990
Mas antes que eu possa executar meu programa e fazer o equivalente a clicar duas vezes

239
00: 12: 24,990 -> 00: 12: 28.200
nele, preciso executá-lo por meio de um compilador

240
00: 12: 28,200 -> 00: 12: 30.640
e produzir sua saída, que é de zeros e uns.

241
00: 12: 30,640 -> 00: 12: 33.000
Então, como faço isso?

242
00: 12: 33.000 -> 00: 12: 35.640
Este é o primeiro dos comandos mais esotéricos,

243
00: 12: 35,640 -> 00: 12: 38.880
mas acontece que é relativamente simples de fazer.

244
00: 12: 38,880 -> 00: 12: 40.680
No topo do meu ambiente de programação -

245
00: 12: 40,680 -> 00: 12: 43.380
novamente, tenho meu código aqui no canto superior esquerdo.

246
00: 12: 43,380 -> 00: 12: 45.780
E se eu rolar para baixo, eu tenho isso, de novo,

247
00: 12: 45,780 -> 00: 12: 47.322
o chamado terminal.

248
00: 12: 47,322 -> 00: 12: 49.530
E o cifrão é apenas uma convenção humana estranha.

249
00: 12: 49,530 -> 00: 12: 51.930
O cifrão significa apenas digite algo aqui.

250
00: 12: 51,930 -> 00: 12: 54.540
Esse é o seu prompt, ou shell.

251
00: 12: 54,540 -> 00: 12: 59.700
Mas o cursor piscando está apenas me convidando a digitar um comando neste prompt.

252
00: 12: 59,700 -> 00: 13: 04.740
O primeiro comando que vou digitar é o chamado Clang para linguagem C.

253
00: 13: 04,740 -> 00: 13: 09.210
Clang é o nome de um programa que existe para compilar código.

254
00: 13: 09,210 -> 00: 13: 10.650
Que Alguém escreveu.

255
00: 13: 10,650 -> 00: 13: 14.100
Outra pessoa online criou este programa chamado Clang - todo um grupo de pessoas,

256
00: 13: 14,100 -> 00: 13: 14.640
de fato.

257
00: 13: 14,640 -> 00: 13: 18.210
Disponibilizado gratuitamente para mim e para você baixar em seus próprios Macs ou PCs

258
00: 13: 18,210 -> 00: 13: 19.990
ou este ambiente de sandbox.

259
00: 13: 19,990 -> 00: 13: 23.110
E podemos usar o Clang para converter o código-fonte em código de máquina.

260
00: 13: 23,110 -> 00: 13: 26.940
Então, vou prosseguir e executar o Clang hello.c.

261
00: 13: 26,940 -> 00: 13: 29.860
Ainda não pressionei Enter, mas no momento em que pressiono Enter,

262
00: 13: 29,860 -> 00: 13: 31.360
vamos ver algo acontecer.

263
00: 13: 31,360 -> 00: 13: 33.720
Deixe-me ir até este pequeno ícone de pasta aqui,

264
00: 13: 33,720 -> 00: 13: 37.020
e você pode realmente ver todos os arquivos na minha sandbox atual,

265
00: 13: 37,020 -> 00: 13: 38.710
por assim dizer, meu ambiente de programação.

266
00: 13: 38,710 -> 00: 13: 41.752
Claro, há apenas um, porque o único arquivo que criei até agora

267
00: 13: 41,752 -> 00: 13: 43.170
é chamado de hello.c.

268
00: 13: 43,170 -> 00: 13: 45.720
Mas observe o que acontece no momento em que pressiono Enter,

269
00: 13: 45,720 -> 00: 13: 47.940
depois de digitar Clang hello.c.

270
00: 13: 47,940 -> 00: 13: 50.610


271
00: 13: 50,610 -> 00: 13: 54.150
Então, claramente, algo mais existe agora, e é

272
00: 13: 54,150 -> 00: 13: 56.490
um nome realmente estúpido e muito enigmático.

273
00: 13: 56,490 -> 00: 14: 02.520
É a.out, mas talvez você possa adivinhar o que há dentro desse novo arquivo.

274
00: 14: 02,520 -> 00: 14: 03.842
O que pode estar dentro dele?

275
00: 14: 03,842 -> 00: 14: 04.800
PÚBLICO: Código de máquina.

276
00: 14: 04,800 -> 00: 14: 06.133
DAVID MALAN: Sim, código de máquina.

277
00: 14: 06,133 -> 00: 14: 09.540
Portanto, significa saída do assembly, mas que significa apenas código de máquina.

278
00: 14: 09,540 -> 00: 14: 13.110
Portanto, dentro deste arquivo há um monte de zeros e uns

279
00: 14: 13,110 -> 00: 14: 16.437
que correspondem a este código, mas em binário,

280
00: 14: 16,437 -> 00: 14: 18.270
na linguagem que o computador pode entender.

281
00: 14: 18,270 -> 00: 14: 20.640
Então, literalmente, o que acabei de fazer foi isso -

282
00: 14: 20,640 -> 00: 14: 24.450
Tomei como entrada um código semelhante a este, escrito em C.

283
00: 14: 24,450 -> 00: 14: 28.148
Executei-o como entrada no compilador e produzi esta saída, zeros e uns.

284
00: 14: 28,148 -> 00: 14: 29.940
E esses zeros e uns eram automaticamente

285
00: 14: 29,940 -> 00: 14: 35.113
salvo para mim dentro de um arquivo que, por convenção humana, é chamado a.out.

286
00: 14: 35,113 -> 00: 14: 37.530
Tudo bem, mas alguém propôs antes, que para executar um programa,

287
00: 14: 37,530 -> 00: 14: 40.088
normalmente, em seu Mac e PC, basta clicar duas vezes nele.

288
00: 14: 40,088 -> 00: 14: 41.880
Mas realmente não há nada para clicar duas vezes.

289
00: 14: 41,880 -> 00: 14: 44.940
E, na verdade, se eu clicar duas vezes nisso, vai ficar muito estranho,

290
00: 14: 44,940 -> 00: 14: 46.380
e o computador não vai entender.

291
00: 14: 46,380 -> 00: 14: 48.930
Porque são zeros e uns que não devem ser clicados.

292
00: 14: 48,930 -> 00: 14: 52.598
Eles devem ser executados neste prompt de comando.

293
00: 14: 52,598 -> 00: 14: 53.890
Então, deixe-me ir em frente e fazer isso.

294
00: 14: 53,890 -> 00: 14: 54.807
Isso também é enigmático.

295
00: 14: 54,807 -> 00: 14: 58.740
Mas vou prosseguir e fazer ./a.out.

296
00: 14: 58,740 -> 00: 15: 02.190
E isso, por mais estranho que pareça à primeira vista,

297
00: 15: 02,190 -> 00: 15: 07.890
é como digo ao computador, execute o programa a.out no meu diretório atual.

298
00: 15: 07,890 -> 00: 15: 11.010
Então, esse ponto que digitei primeiro significa que está literalmente bem aqui,

299
00: 15: 11,010 -> 00: 15: 13.260
na minha pasta atual, como se você estivesse clicando duas vezes

300
00: 15: 13,260 -> 00: 15: 14.730
nele no seu Mac ou PC.

301
00: 15: 14,730 -> 00: 15: 19.650
E /a.out significa olhar neste diretório e executar o programa no arquivo chamado

302
00: 15: 19,650 -> 00: 15: 20.860
a.out.

303
00: 15: 20,860 -> 00: 15: 23.150
Deixe-me ir em frente e pressione Enter.

304
00: 15: 23,150 -> 00: 15: 25.980
E voila, olá mundo.

305
00: 15: 25,980 -> 00: 15: 29.610
Então você ficou muito impressionado na semana passada, pelo que me lembro, quando fiz o gato dizer:

306
00: 15: 29,610 -> 00: 15: 30.580
Olá Mundo.

307
00: 15: 30,580 -> 00: 15: 32.510
Aqui, parecemos menos do que desapontados.

308
00: 15: 32,510 -> 00: 15: 36.360
Mas olá, mundo agora é meu programa em C que faz exatamente a mesma coisa.

309
00: 15: 36,360 -> 00: 15: 39.870
Mas, admito, parece um pouco estúpido no momento.

310
00: 15: 39,870 -> 00: 15: 40.950
Parece um pouco bugado.

311
00: 15: 40,950 -> 00: 15: 44.373
O que o incomoda, mesmo que você nunca tenha programado antes?

312
00: 15: 44,373 -> 00: 15: 45.290
PÚBLICO: Cifrão.

313
00: 15: 45,290 -> 00: 15: 46.748
DAVID MALAN: Sim, o cifrão.

314
00: 15: 46,748 -> 00: 15: 48.660
Eu não quis dizer olá, mundo cifrão,

315
00: 15: 48,660 -> 00: 15: 50.868
mas aquele cifrão é como um artefato, certo?

316
00: 15: 50,868 -> 00: 15: 52.482
O que significa mesmo o cifrão?

317
00: 15: 52,482 -> 00: 15: 53.190
PÚBLICO: Prompt.

318
00: 15: 53,190 -> 00: 15: 54.150
DAVID MALAN: É apenas esse prompt.

319
00: 15: 54,150 -> 00: 15: 57.270
Ele está esperando por outro comando, e é por isso que meu cursor está piscando aqui.

320
00: 15: 57,270 -> 00: 15: 58.603
Mas parece estúpido, certo?

321
00: 15: 58,603 -> 00: 16: 01.538
Poderíamos argumentar que essa era minha intenção, mas, francamente, eu estaria mentindo.

322
00: 16: 01,538 -> 00: 16: 03.330
Isso não faz exatamente o que eu quero que faça.

323
00: 16: 03,330 -> 00: 16: 05.380
E isso porque, ao contrário do Scratch -

324
00: 16: 05,380 -> 00: 16: 06.930
que, novamente, é mais amigável -

325
00: 16: 06,930 -> 00: 16: 12.220
C, e muitas linguagens como esta, literalmente farão apenas o que você lhes disser para fazer.

326
00: 16: 12,220 -> 00: 16: 16.972
Em nenhum momento eu disse ao computador para mover o cursor para uma nova linha.

327
00: 16: 16,972 -> 00: 16: 18.180
Eu não terminei esse pensamento.

328
00: 16: 18,180 -> 00: 16: 20.340
Eu disse, olá, vírgula, mundo e é isso.

329
00: 16: 20,340 -> 00: 16: 23.650
Nunca enviei um comando ao computador para realmente mover o cursor,

330
00: 16: 23,650 -> 00: 16: 24.660
mas eu posso.

331
00: 16: 24,660 -> 00: 16: 26.830
Então, deixe-me voltar ao meu código aqui.

332
00: 16: 26,830 -> 00: 16: 30.300
E acontece que em C, se você disser ao computador

333
00: 16: 30,300 -> 00: 16: 33.240
imprimir olá, vírgula, mundo, isso é literalmente tudo o que 

334
00: 16: 33,240 -> 00: 16: 34.620
vai imprimir para você.

335
00: 16: 34,620 -> 00: 16: 36.810
Se você deseja imprimir uma nova linha, você precisa

336
00: 16: 36,810 -> 00: 16: 40.950
usar um comando especial, um caractere especial denominado caractere de nova linha,

337
00: 16: 40,950 -> 00: 16: 43.650
que é representado pela barra invertida n.

338
00: 16: 43,650 -> 00: 16: 44.672
Agora, por que isso?

339
00: 16: 44,672 -> 00: 16: 46.380
Bem, é realmente porque embora você

340
00: 16: 46,380 -> 00: 16: 49.590
pode ficar inclinado a pressionar Enter, simplesmente assim

341
00: 16: 49,590 -> 00: 16: 51.900
como você esperaria que o computador fizesse,

342
00: 16: 51,900 -> 00: 16: 54.210
mesmo que você nunca tenha programado antes, isso provavelmente

343
00: 16: 54,210 -> 00: 16: 55.950
deve começar a incomodá-lo.

344
00: 16: 55,950 -> 00: 16: 57.270
Parece um pouco estranho.

345
00: 16: 57,270 -> 00: 16: 59.460
Parece um pouco confuso, essa linha está aqui

346
00: 16: 59,460 -> 00: 17: 00.930
e a segunda linha está aqui.

347
00: 17: 00,930 -> 00: 17: 03.180
Então, o que os humanos decidiram anos atrás foi: vamos

348
00:17:03,180 --> 00:17:06,750
apenas ter uma instrução simples, barra invertida n,

349
00: 17: 06,750 -> 00: 17: 10.170
que diz ao computador para mover essa nova linha para baixo.

350
00: 17: 10,170 -> 00: 17: 11.670
Então, deixe-me ir em frente e diminuir o zoom agora.

351
00: 17: 11,670 -> 00: 17: 14.010
Na sandbox, ele salva automaticamente como o Google Docs,

352
00: 17: 14,010 -> 00: 17: 16.589
então você não precisa ir para Arquivo, Salvar ou qualquer coisa assim.

353
00: 17: 16,589 -> 00: 17: 23.440
Se eu prosseguir agora e executar novamente este programa ./a.out Enter, ainda não foi corrigido.

354
00: 17: 23,440 -> 00: 17: 25.319
Deixe-me ir em frente e aumentar o zoom.

355
00: 17: 25,319 -> 00: 17: 27.210
Observe que o sintoma ainda está lá.

356
00: 17: 27,210 -> 00: 17: 28.260
Por quê?

357
00: 17: 28,260 -> 00: 17: 31.050
Que erro eu cometi?

358
00: 17: 31,050 -> 00: 17: 32.700
Sim, não o recompilei.

359
00: 17: 32,700 -> 00: 17: 36.120
Então, novamente, o computador vai começar a te levar muito, muito ao pé da letra

360
00: 17: 36,120 -> 00: 17: 38.580
agora que você está programando ele para fazer coisas.

361
00: 17: 38,580 -> 00: 17: 41.340
E se você quiser executar a nova versão do seu código,

362
00: 17: 41,340 -> 00: 17: 44.880
você vai literalmente ter que fazer algo como Clang

363
00: 17: 44,880 -> 00: 17: 48.360
e então hello.c, Enter.

364
00: 17: 48,360 -> 00: 17: 49.810
E nada parece acontecer.

365
00: 17: 49,810 -> 00: 17: 52.552
E, francamente, e ironicamente, quando você não vê nenhum resultado,

366
00: 17: 52,552 -> 00: 17: 53.760
isso geralmente é uma coisa boa.

367
00: 17: 53,760 -> 00: 17: 56.340
Quando você vê a saída, geralmente é uma lista de, tipo, cinco erros

368
00: 17: 56,340 -> 00: 17: 58.560
que você cometeu ou mensagens de erro que veremos em breve.

369
00: 17: 58,560 -> 00: 18: 00.120
Mas ainda temos a.out.

370
00: 18: 00,120 -> 00: 18: 02.200
É apenas uma versão mais recente disso.

371
00: 18: 02,200 -> 00: 18: 06.930
Então, se eu prosseguir e aumentar o zoom agora e fizer isso-- ./a.out, Enter--

372
00: 18: 06,930 -> 00: 18: 10.070
agora tenho uma versão mais impressionante de hello world.

373
00: 18: 10,070 -> 00: 18: 12.450
Eu acabei de limpar ele um pouco.

374
00: 18: 12,450 -> 00: 18: 14.190
Tudo bem, deixe-me fazer uma pausa por um momento

375
00: 18: 14,190 -> 00: 18: 18.490
e veja se há alguma dúvida sobre essa mecânica até agora.

376
00: 18: 18,490 -> 00: 18: 19.066
Sim?

377
00: 18: 19,066 -> 00: 18: 20.440
PÚBLICO: Por que a linha 2 está vazia?

378
00: 18: 20,440 -> 00: 18: 21.940
DAVID MALAN: Diga um pouco mais alto.

379
00: 18: 21,940 -> 00: 18: 23.640
PÚBLICO: Por que a linha 2 está vazia?

380
00: 18: 23,640 -> 00: 18: 24.330
DAVID MALAN: Por que a linha 2 está vazia?

381
00: 18: 24,330 -> 00: 18: 25.540
Oh, pergunta realmente boa.

382
00: 18: 25,540 -> 00: 18: 29.678
A linha 2 está vazia porque decidi estéticamente

383
00: 18: 29,678 -> 00: 18: 30.720
ter uma aparência um pouco melhor.

384
00: 18: 30,720 -> 00: 18: 32.553
Muito parecido com uma redação de inglês, você pode dar

385
00:18:32,553 --> 00:18:34,500
Enter, só para separar seus parágrafos,

386
00: 18: 34,500 -> 00: 18: 36.810
assim, os programadores geralmente separam seus códigos, apenas

387
00: 18: 36,810 -> 00: 18: 39.300
para torná-lo um pouco mais fácil de digerir para que não

388
00: 18: 39,300 -> 00: 18: 41.610
pareça apenas um grande amontoado de código.

389
00: 18: 41,610 -> 00: 18: 44.680
Mas não é necessário e eu poderia omitir.

390
00: 18: 44,680 -> 00: 18: 46.880
Outras perguntas?

391
00: 18: 46,880 -> 00: 18: 49.036
Sim?

392
00: 18: 49,036 -> 00: 18: 51.940
PÚBLICO: Você pode renomear a.out para ter mais de um

393
00: 18: 51,940 -> 00: 18: 52.898
arquivo em seu diretório?

394
00: 18: 52,898 -> 00: 18: 54.315
DAVID MALAN: Boa pergunta.

395
00: 18: 54,315 -> 00: 18: 57.750
Você pode renomear a.out para ter mais de um arquivo ou programa

396
00: 18: 57.750 -> 00: 18: 58.740
no mesmo diretório?

397
00: 18: 58,740 -> 00: 18: 59.430
Absolutamente.

398
00: 18: 59,430 -> 00: 19: 00.990
Então deixe-me fazer isso agora.

399
00: 19: 00,990 -> 00: 19: 04.350
Acontece que quando você executa comandos em um computador como o Clang,

400
00: 19: 04,350 -> 00: 19: 08.100
você não precisa apenas dizer o nome do programa e o nome do arquivo.

401
00: 19: 08,100 -> 00: 19: 10.380
Você pode adicionar opções adicionais, também conhecidas

402
00: 19: 10,380 -> 00: 19: 12.180
como argumentos de linha de comando.

403
00: 19: 12,180 -> 00: 19: 14.280
E aqui também é um pouco arcaico.

404
00: 19: 14,280 -> 00: 19: 19.020
Você tem que saber o que é possível para digitar essas coisas.

405
00: 19: 19,020 -> 00: 19: 20.640
Mas acontece que com o Clang -

406
00: 19: 20,640 -> 00: 19: 22.740
e se você ler a documentação, verá -

407
00: 19: 22,740 -> 00: 19: 25.920
você pode realmente dizer -o para a saída.

408
00: 19: 25,920 -> 00: 19: 28.140
E então você pode especificar qualquer nome que você

409
00: 19: 28,140 -> 00: 19: 31.860
deseja para o arquivo no qual seu código de máquina será salvo.

410
00: 19: 31,860 -> 00: 19: 33.000
Portanto, observe o que acontece agora.

411
00: 19: 33.000 -> 00: 19: 35.550
Quando pressiono Enter agora, observe o canto superior esquerdo,

412
00: 19: 35,550 -> 00: 19: 37.710
onde eu tenho a.out e hello.c.

413
00: 19: 37,710 -> 00: 19: 40.930
Agora eu também tenho hello.

414
00: 19: 40,930 -> 00: 19: 45.210
E agora posso prosseguir e dizer ./hello em vez de a.out,

415
00: 19: 45,210 -> 00: 19: 48.137
e o resultado agora será o mesmo.

416
00: 19: 48,137 -> 00: 19: 50.970
E deixe-me aproveitar essa oportunidade para pontuar outra coisa.

417
00: 19: 50,970 -> 00: 19: 53.570
Mesmo que vejamos essa interface gráfica aqui,

418
00: 19: 53,570 -> 00: 19: 55.320
isso é apenas conveniente, porque você e eu

419
00: 19: 55,320 -> 00: 19: 59.310
geralmente estão familiarizados com essa interface de nossos próprios Macs e PCs.

420
00: 19: 59,310 -> 00: 20: 04.590
Mas posso fazer tudo por meio deste prompt de comando o que posso fazer por meio do meu mouse.

421
00: 20: 04,590 -> 00: 20: 07.350
Na verdade, neste ambiente de programação,

422
00: 20: 07,350 -> 00: 20: 10.200
Posso digitar um comando chamado ls para listar.

423
00: 20: 10,200 -> 00: 20: 13.800
É uma notação abreviada, porque anos atrás, os humanos decidiram, bem,

424
00: 20: 13,800 -> 00: 20: 17.830
por que digitar L-I-S-T se podemos apenas digitar ls, que soa quase a mesma coisa.

425
00: 20: 17,830 -> 00: 20: 22.320
E assim nasceu o comando ls, que simplesmente exibe

426
00: 20: 22,320 -> 00: 20: 26.340
uma lista de todos os arquivos da pasta ou diretório atual.

427
00: 20: 26,340 -> 00: 20: 30.570
E vemos a mesma coisa - a.out, hello e hello.c.

428
00: 20: 30,570 -> 00: 20: 33.720
E você pode talvez inferir ou adivinhar, o que o asterisco

429
00: 20: 33,720 -> 00: 20: 36.060
quer dizer depois de a.out e hello, talvez?

430
00: 20: 36,060 -> 00: 20: 37.033
PÚBLICO: Executável.

431
00: 20: 37,033 -> 00: 20: 38.950
DAVID MALAN: É executável, o que significa apenas

432
00: 20: 38,950 -> 00: 20: 42.660
há um código de máquina lá que pode ser executado pelo computador,

433
00: 20: 42,660 -> 00: 20: 45.773
enquanto hello.c não tem esse asterisco ou estrela depois dele,

434
00: 20: 45,773 -> 00: 20: 47.190
o que significa apenas que é o código-fonte.

435
00: 20: 47,190 -> 00: 20: 50.340
Assim, você pode até mesmo distinguir visualmente o código-fonte do código de máquina

436
00: 20: 50,340 -> 00: 20: 51.600
do código de máquina.

437
00: 20: 51,600 -> 00: 20: 54.630
Agora, suponha que eu não queira que a.out exista mais,

438
00: 20: 54,630 -> 00: 20: 56.130
porque parece um nome estúpido.

439
00: 20: 56,130 -> 00: 20: 58.230
Nunca vou lembrar que programa ele é.

440
00: 20: 58,230 -> 00: 21: 02.520
Bem, você pode digitar outros comandos, como rm, para remover, a.out.

441
00: 21: 02,520 -> 00: 21: 03.660
E então pressione Enter.

442
00: 21: 03,660 -> 00: 21: 04.980
E isso é um pouco arcaico.

443
00: 21: 04,980 -> 00: 21: 07.540
Ele diz para remover o arquivo comum a.out.

444
00: 21: 07,540 -> 00: 21: 10.890
Observe que o prompt agora está piscando após esse ponto de interrogação.

445
00: 21: 10.890 -> 00: 21: 15.060
Posso prosseguir e digitar Y para sim ou yes para sim.

446
00: 21: 15,060 -> 00: 21: 17.010
Observe que nada parece ter acontecido.

447
00: 21: 17,010 -> 00: 21: 20.730
Mas como posso verificar quais arquivos existem agora nesta pasta?

448
00: 21: 20,730 -> 00: 21: 24.790
Sim, então apenas digito ls de novo, e agora estou com esses dois arquivos.

449
00: 21: 24,790 -> 00: 21: 27.450
Acontece que também existem outros comandos que podemos digitar.

450
00: 21: 27,450 -> 00: 21: 34.140
E há comandos como ls e rm.

451
00: 21: 34,140 -> 00: 21: 36.690
Há mkdir para criar um diretório.

452
00: 21: 36,690 -> 00: 21: 38.683
Existe rmdir para remover o diretório.

453
00: 21: 38,683 -> 00: 21: 41.100
E a qualquer momento que você precisar saber ou usar um desses comandos,

454
00: 21: 41,100 -> 00: 21: 43.080
faremos questão de informá-lo no seu desafio.

455
00: 21: 43,080 -> 00: 21: 46.320
Mas perceba tudo o que você pode fazer com o mouse

456
00: 21: 46,320 -> 00: 21: 50.610
e aquela interface gráfica, você também pode fazer nesta linha de comando.

457
00: 21: 50,610 -> 00: 21: 53.640
Tudo bem, então vamos aumentar um pouco as coisas

458
00: 21: 53,640 -> 00: 21: 55.950
e fazer algo um pouco mais interessante,

459
00: 21: 55,950 -> 00: 21: 58.350
voltando para o lado a lado aqui.

460
00: 21: 58,350 -> 00: 22: 02.000
Até agora, tudo o que fizemos foi imprimir hello world.

461
00: 22: 02.000 -> 00: 22: 04.620
Mas lembre-se, na semana passada, o segundo programa que escrevemos

462
00: 22: 04,620 -> 00: 22: 06.450
foi um pouco mais dinâmico e interativo.

463
00: 22: 06,450 -> 00: 22: 10.200
O que fizemos na semana passada como nosso segundo programa no Scratch, se você se lembrar?

464
00: 22: 10,200 -> 00: 22: 12.400
PÚBLICO: Solicitamos ao usuário seu nome.

465
00: 22: 12,400 -> 00: 22: 14.692
DAVID MALAN: Sim, solicitamos ao usuário o nome dele.

466
00: 22: 14.692 -> 00: 22: 17.550
E então dissemos olá, David, ou olá, Brian, ou quem quer que seja

467
00: 22: 17,550 -> 00: 22: 19.133
estava realmente executando o programa.

468
00: 22: 19,133 -> 00: 22: 21.300
Então aquele programa parecia um pouco com isso.
469
00: 22: 21,300 -> 00: 22: 25.590
Essas duas linhas de código foram anexadas ao bloco "quando a bandeira verde for clicada".

470
00: 22: 25,590 -> 00: 22: 28.170
Este bloco azul aqui no topo era uma função,

471
00: 22: 28,170 -> 00: 22: 32.940
e essa função retornou um argumento, retornou uma resposta.

472
00: 22: 32,940 -> 00: 22: 35.170
Ele retornou a resposta que o usuário havia digitado.

473
00: 22: 35,170 -> 00: 22: 38.130
E isso foi útil, porque usamos a resposta do usuário

474
00: 22: 38,130 -> 00: 22: 42.600
para juntá-los, ou concatenar esquerda e direita, com a palavra hello.

475
00: 22: 42,600 -> 00: 22: 45.160
E então dissemos o resultado disso.

476
00: 22: 45,160 -> 00: 22: 46.255
Então, como fazemos isso em C?

477
00: 22: 46,255 -> 00: 22: 48.630
Bem, é aqui que as coisas vão se complicar rapidamente.

478
00: 22: 48,630 -> 00: 22: 51.570
Mas, novamente, é tudo uma questão de seguir certas regras e padrões que

479
00: 22: 51,570 -> 00: 22: 54.190
vão ficar cada vez mais familiares com o tempo.

480
00: 22: 54,190 -> 00: 22: 57.990
Em C, pelo menos no CS50 Sandbox, o equivalente mais próximo

481
00: 22: 57,990 -> 00: 23: 03.810
para a função "ask/pergunte" no Scratch será uma função C chamada get_string.

482
00: 23: 03,810 -> 00: 23: 06.180
Uma string é apenas uma expressão de programadores

483
00: 23: 06,180 -> 00: 23: 09.750
para uma palavra ou frase ou sentença.

484
00: 23: 09,750 -> 00: 23: 14.470
Portanto, texto, o oposto de números ou algum outro dado.

485
00: 23: 14,470 -> 00: 23: 19.680
Portanto, get_string é o análogo mais próximo da função ask.

486
00: 23: 19,680 -> 00: 23: 22.830
Entre os parênteses, o que implica que aqui está

487
00: 23: 22,830 -> 00: 23: 24.840
onde você pode fornecer alguma entrada, eu posso seguir

488
00: 23: 24,840 -> 00: 23: 27.673
e fornecer o prompt que o usuário verá na tela -

489
00: 23: 27,673 -> 00: 23: 30.217
por exemplo, qual é o seu nome, abre aspas, fecha aspas.

490
00: 23: 30,217 -> 00: 23: 31.050
Agora, por que as aspas?

491
00: 23: 31,050 -> 00: 23: 34.050
Eu acabei de afirmar que sempre que você passar uma string -

492
00: 23: 34,050 -> 00: 23: 36.450
uma palavra, uma frase, caracteres alfanuméricos -

493
00: 23: 36,450 -> 00: 23: 38.460
você tem que colocá-los entre aspas duplas

494
00: 23: 38,460 -> 00: 23: 40.380
à esquerda e aspas duplas à direita.

495
00: 23: 40,380 -> 00: 23: 44.994
E para ser claro, por que eu tenho esse encantamento estranho aqui, barra invertida n?

496
00: 23: 44,994 -> 00: 23: 45.786
PÚBLICO: Nova linha.

497
00: 23: 45,786 -> 00: 23: 47.970
DAVID MALAN: Sim, ele apenas move o cursor para a nova linha.

498
00: 23: 47,970 -> 00: 23: 48.540
Por quê?

499
00: 23: 48,540 -> 00: 23: 50.207
Só porque parece um pouco mais bonito.

500
00: 23: 50,207 -> 00: 23: 51.000
Não é necessário.

501
00: 23: 51.000 -> 00: 23: 54.370
E, de fato, um momento atrás, meu próprio computador me solicitou a resposta sim ou não,

502
00: 23: 54,370 -> 00: 23: 56.780
e não moveu o cursor para a próxima linha.

503
00: 23: 56,780 -> 00: 23: 59.470
Isso porque aquele programador decidiu não se preocupar em fazer isso.

504
00: 23: 59,470 -> 00: 24: 02.120
Mas irei em frente e manterei as coisas limpas fazendo isso.

505
00: 24: 02,120 -> 00: 24: 07.150
Agora, uma vez que eu pergunto ao usuário por seu nome por meio desta função get_string,

506
00: 24: 07,150 -> 00: 24: 08.680
Eu preciso fazer algo com isso.

507
00: 24: 08,680 -> 00: 24: 12.220
E em C, a maneira como você faz isso é literalmente

508
00: 24: 12,220 -> 00: 24: 15.837
dê a si mesmo uma variável, que é um pedaço de armazenamento para um valor.

509
00: 24: 15,837 -> 00: 24: 18.670
E vou prosseguir e chamá-la de resposta, assim como foi feito no Scratch.

510
00: 24: 18,670 -> 00: 24: 21.040
Mas em C, posso chamar isso do que quiser.

511
00: 24: 21,040 -> 00: 24: 22.565
Eu poderia chamá-la de xyz.

512
00: 24: 22,565 -> 00: 24: 25.690
Nenhuma delas é muito descritiva, então vou chamá-la de resposta.

513
00: 24: 25,690 -> 00: 24: 27.100
Você pode usar qualquer palavra.

514
00: 24: 27,100 -> 00: 24: 28.990
Mas C é um pouco diferente.

515
00: 24: 28,990 -> 00: 24: 34.480
C é da velha guarda, e você tem que ser super explícito quanto ao tipo de valor

516
00: 24: 34,480 -> 00: 24: 37.630
que está obtendo e, portanto, armazenando na variável.

517
00: 24: 37,630 -> 00: 24: 40.040
Então, à esquerda do nome da variável,

518
00: 24: 40,040 -> 00: 24: 43.810
Tenho que dizer ao computador o tipo de valor que preciso armazenar

519
00: 24: 43,810 -> 00: 24: 45.010
vai ser uma string.

520
00: 24: 45,010 -> 00: 24: 49.180
E veremos em um momento, que há outros tipos de valores.

521
00: 24: 49,180 -> 00: 24: 53.860
Existem números e muito mais, mas por enquanto, vamos apenas armazenar uma string.

522
00: 24: 53,860 -> 00: 24: 56.760
E há uma coisa faltando nesta linha de código.

523
00: 24: 56,760 -> 00: 24: 57.700
PÚBLICO: Ponto e vírgula.

524
00: 24: 57,700 -> 00: 24: 58.600
DAVID MALAN: Ponto e vírgula, certo?

525
00: 24: 58,600 -> 00: 25: 00.392
Fim do pensamento, e esse foi um grande pensamento,

526
00: 25: 00,392 -> 00: 25: 02.200
mas um ponto-e-vírgula finaliza esse pensamento.

527
00: 25: 02,200 -> 00: 25: 04.700
Agora, este sinal de igual é um pouco diferente da álgebra,

528
00: 25: 04,700 -> 00: 25: 07.750
se você pensar em seus dias de matemática, onde poderia dizer que x é igual a y.

529
00: 25: 07,750 -> 00: 25: 11.440
Quando x é igual a y, isso significa, literalmente, x é a mesma coisa que y.

530
00: 25: 11,440 -> 00: 25: 14.740
Mas aqui, o sinal de igual nas linguagens de programação

531
00: 25: 14,740 -> 00: 25: 17.990
normalmente é o tipo de movimento da direita para a esquerda.

532
00: 25: 17,990 -> 00: 25: 20.560
Este sinal de igual não significa tecnicamente igual.

533
00: 25: 20,560 -> 00: 25: 24.070
Significa atribuir, ou o operador de atribuição.

534
00: 25: 24,070 -> 00: 25: 27.200
Mova algo da direita para a esquerda.

535
00: 25: 27,200 -> 00: 25: 31.600
Então, se esta função get_string, assim como a função ask,

536
00: 25: 31,600 -> 00: 25: 35.140
pede ao usuário o nome dele e devolve um valor,

537
00: 25: 35,140 -> 00: 25: 37.930
você quer colocar esse nome em uma variável

538
00: 25: 37,930 -> 00: 25: 40.192
chamada de resposta, da direita para a esquerda.

539
00: 25: 40,192 -> 00: 25: 42.650
Então, embora nós - assim como escrevemos da direita para a esquerda,

540
00: 25: 42,650 -> 00: 25: 45.710
então você pensa sobre isso executando da direita para a esquerda.

541
00: 25: 45,710 -> 00: 25: 48.310
Então, neste ponto da história, agora temos

542
00: 25: 48,310 -> 00: 25: 52.960
em algum lugar da memória do computador, em uma chamada variável, a resposta do usuário

543
00: 25: 52,960 -> 00: 25: 54.130
ao seu nome.

544
00: 25: 54,130 -> 00: 25: 55.540
O que eu quero fazer com isso?

545
00: 25: 55,540 -> 00: 25: 58.093
Bem, em C, não há uma função de junção, então vamos

546
00: 25: 58,093 -> 00: 26: 00.010
ter que fazer isso um pouco diferente.

547
00: 26: 00,010 -> 00: 26: 03.613
Mas existe um tipo de função "say/diga", e como essa função foi chamada?

548
00: 26: 03,613 -> 00: 26: 04.340
PÚBLICO: Printf.

549
00:26:04,340 --> 00:26:05,173
DAVID MALAN: Printf.

550
00: 26: 05,173 -> 00: 26: 08.440
Então, printf é a função que pode ser acessada sempre que você quiser imprimir ou dizer algo

551
00: 26: 08,440 -> 00: 26: 09.320
na tela.

552
00: 26: 09,320 -> 00: 26: 10.993
Então, vou prosseguir e usar printf.

553
00: 26: 10,993 -> 00: 26: 13.660
E vou usar parênteses, porque parênteses significam, aqui

554
00: 26: 13,660 -> 00: 26: 18.670
com estas entradas, também conhecidas como argumentos ou parâmetros na programação.

555
00: 26: 18,670 -> 00: 26: 21.100
Mas esses são sinônimos para nossos propósitos.

556
00: 26: 21,100 -> 00: 26: 23.350
E agora isso não é um tanto óbvio, certo?

557
00: 26: 23,350 -> 00: 26: 29.180
Porque eu não quero apenas colocar, abre fecha aspas, "oi, vírgula, resposta".

558
00: 26: 29,180 -> 00: 26: 29.680
Por quê?

559
00: 26: 29,680 -> 00: 26: 34.480
Por que seria incorreto abre, fecha aspas, olá, vírgula, resposta?

560
00: 26: 34,480 -> 00: 26: 35.155
O que é isso?

561
00: 26: 35,155 -> 00: 26: 36.400
PÚBLICO: Vai apenas imprimir "resposta".

562
00: 26: 36,400 -> 00: 26: 39.323
DAVID MALAN: Certo, vai literalmente dizer olá, vírgula, resposta, certo?

563
00: 26: 39,323 -> 00: 26: 40.490
E não é isso que queremos.

564
00: 26: 40,490 -> 00: 26: 41.530
Não queremos dizer "Olá, resposta".

565
00: 26: 41,530 -> 00: 26: 43.450
Queremos dizer olá David ou olá Brian,

566
00: 26: 43,450 -> 00: 26: 45.280
ou quem quer esteja rodando este programa.

567
00: 26: 45,280 -> 00: 26: 49.900
Então, de alguma forma, preciso juntar a palavra hello com a entrada do usuário.

568
00: 26: 49,900 -> 00: 26: 53.335
E a maneira de fazer isso no printf é um pouco diferente do Scratch.

569
00: 26: 53,335 -> 00: 26: 55.550
Você usa o que é chamado de "placeholder/espaço reservado".

570
00: 26: 55,550 -> 00: 26: 57.550
Então você literalmente escreve a sentença ou frase

571
00: 26: 57.550 -> 00: 27: 00.220
que você quer dizer ou imprimir na tela,

572
00: 27: 00,220 -> 00: 27: 03.340
mas onde quer que você ainda não saiba o valor com antecedência,

573
00: 27: 03,340 -> 00: 27: 08.570
você coloca um espaço reservado usando um sinal de porcentagem e, em seguida, um s para representar sua string.

574
00: 27: 08,570 -> 00: 27: 11.320
E isso porque, é claro, se estou escrevendo este programa hoje,

575
00: 27: 11,320 -> 00: 27: 13.840
Não tenho ideia de quem vai executá-lo amanhã.

576
00: 27: 13,840 -> 00: 27: 15.910
Quero colocar dinamicamente um "placeholder/marcador de posição"

577
00: 27: 15,910 -> 00: 27: 19.400
então se alguém rodar este programa amanhã ou no dia seguinte,

578
00: 27: 19,400 -> 00: 27: 21.070
seu nome é inserido dinamicamente.

579
00: 27: 21,070 -> 00: 27: 23.410
Eu, claro, não sei o nome deles hoje.

580
00: 27: 23,410 -> 00: 27: 26.350
Portanto, entre aspas, aspas, "olá, vírgula, %s".

581
00: 27: 26,350 -> 00: 27: 30.130
E esse %s é apenas um espaço reservado para tudo o que eu quiser inserir lá.

582
00: 27: 30,130 -> 00: 27: 32.590
"barra invertida n", é claro, significa apenas nova linha.

583
00: 27: 32,590 -> 00: 27: 35.590
Portanto, a única coisa nova aqui é esse percentual s.

584
00: 27: 35,590 -> 00: 27: 39.490
Agora, acontece que funções em C, assim como em Scratch,

585
00: 27: 39,490 -> 00: 27: 40.990
podem não ter argumentos.

586
00:27:40,990 --> 00:27:42,550
Ou podem ter argumentos.

587
00:27:42,550 --> 00:27:44,650
Ou podem ter 2 ou mais argumentos.

588
00: 27: 44,650 -> 00: 27: 49.310
E se elas tiverem dois ou mais, basta separá-los com vírgulas.

589
00: 27: 49,310 -> 00: 27: 50.450
Então, a maneira como printf funciona -

590
00: 27: 50,450 -> 00: 27: 53.200
e você só saberia disso, novamente, sendo ensinado ou lendo

591
00: 27: 53,200 -> 00: 27: 55.720
a documentação - é que você pode, sim,

592
00: 27: 55,720 -> 00: 27: 59.560
fornecer apenas uma única string como entrada -

593
00: 27: 59,560 -> 00: 28: 00.910
entre aspas, alguma coisa.

594
00: 28: 00,910 -> 00: 28: 03.010
Mas se você tiver alguns "placeholders/marcadores" lá,

595
00: 28: 03,010 -> 00: 28: 06.520
você pode dizer ao computador o que concatenar adicionando uma vírgula

596
00: 28: 06,520 -> 00: 28: 10.570
e, em seguida, o nome do valor ou variável que você deseja conectar.

597
00: 28: 10,570 -> 00: 28: 14.120
Portanto, agora, essas duas linhas de código são equivalentes a estas aqui.

598
00: 28: 14,120 -> 00: 28: 15.870
Mas, novamente, embora à primeira vista,

599
00: 28: 15,870 -> 00: 28: 17.620
pode parecer especialmente enigmático, se você apenas

600
00: 28: 17,620 -> 00: 28: 19.480
decompô-lo em componentes individuais

601
00: 28: 19,480 -> 00: 28: 23.020
da direita para a esquerda e de fora para dentro,

602
00: 28: 23,020 -> 00: 28: 28.150
você pode genericamente supor até mesmo o que um novo código que você nunca viu antes

603
00: 28: 28,150 -> 00: 28: 29.860
está fazendo.

604
00: 28: 29,860 -> 00: 28: 33.880
Alguma dúvida sobre essas duas linhas do Scratch ou C?

605
00: 28: 33,880 -> 00: 28: 34.594
Sim?

606
00: 28: 34,594 -> 00: 28: 36.570
PÚBLICO: Você pode adicionar [INAUDÍVEL]?

607
00: 28: 36,570 -> 00: 28: 40.220


608
00: 28: 40,220 -> 00: 28: 41.220
DAVID MALAN: Com certeza.

609
00: 28: 41,220 -> 00: 28: 42.450
Você pode adicionar outras variáveis?

610
00: 28: 42,450 -> 00: 28: 46.290
Se eu tivesse mais variáveis ​​neste programa, graças a mais linhas de código,

611
00: 28: 46,290 -> 00: 28: 49.740
Eu poderia apenas fazer vírgula, outra coisa, vírgula, outra coisa, vírgula.

612
00: 28: 49,740 -> 00: 28: 52.620
E eu poderia ter apenas um "placeholder" nesta 

613
00: 28: 52,620 -> 00: 28: 56.340
expressão para todas as variáveis ​​que desejo inserir.

614
00: 28: 56,340 -> 00: 28: 57.670
E eles vão da esquerda para a direita.

615
00: 28: 57,670 -> 00: 29: 00.510
Então, se eu tivesse dois sinais de "%" aqui, o primeiro

616
00: 29: 00,510 -> 00: 29: 01.890
viria após a primeira vírgula.

617
00: 29: 01,890 -> 00: 29: 04.481
O segundo viria após a segunda vírgula.

618
00: 29: 04,481 -> 00: 29: 06.485
PÚBLICO: Então você precisa de %s [INAUDÍVEL] ??

619
00: 29: 06,485 -> 00: 29: 07.360
DAVID MALAN: Correto.

620
00: 29: 07,360 -> 00: 29: 10.962
Você precisa de um %s para qualquer "placeholder" que deseja inserir, se for uma string.

621
00: 29: 10,962 -> 00: 29: 13.420
E veremos outros "placeholders" em apenas um momento.

622
00: 29: 13,420 -> 00: 29: 14.720
Boa pergunta.

623
00: 29: 14,720 -> 00: 29: 16.464
Outras perguntas?

624
00: 29: 16,464 -> 00: 29: 17.230
Não?

625
00: 29: 17,230 -> 00: 29: 18.440
Oh, sim, la trás.

626
00: 29: 18,440 -> 00: 29: 20.705
PÚBLICO: Existe outra maneira de concatenar strings?

627
00: 29: 20,705 -> 00: 29: 23.080
DAVID MALAN: Existe outra maneira de concatenar strings?

628
00: 29: 23,080 -> 00: 29: 26.533
Resposta curta - sim, de muitas maneiras, nenhuma delas fácil.

629
00: 29: 26,533 -> 00: 29: 29.200
Então, vamos chegar a isso, na verdade, em algumas semanas.

630
00: 29: 29,200 -> 00: 29: 33.290
Printf, por enquanto, é de longe a maneira mais fácil de fazer isso.

631
00: 29: 33,290 -> 00: 29: 34.175
Outras perguntas?

632
00: 29: 34,175 -> 00: 29: 36.550
Se eu não enxergar as mãos de vocês, é porque há tanto brilho.

633
00: 29: 36,550 -> 00: 29: 37.510
Apenas chame.

634
00: 29: 37,510 -> 00: 29: 38.200
Por aqui.

635
00: 29: 38,200 -> 00: 29: 40.550
OK, vocês três.

636
00: 29: 40,550 -> 00: 29: 41.571
Aqui à direita.

637
00: 29: 41,571 -> 00: 29: 43.890
PÚBLICO: [INAUDÍVEL].

638
00: 29: 43,890 -> 00: 29: 44.640
DAVID MALAN: Claro.

639
00: 29: 44,640 -> 00: 29: 45.420
O que é uma string?

640
00: 29: 45,420 -> 00: 29: 50.530
Uma string é uma sequência de zero ou mais caracteres entre aspas duplas.

641
00: 29: 50,530 -> 00: 29: 54.060
Colocado de outra forma, é uma palavra, uma frase, uma sentença, um parágrafo - zero

642
00: 29: 54,060 -> 00: 29: 58.883
ou mais caracteres, letras do alfabeto, entre aspas duplas.

643
00: 29: 58,883 -> 00: 29: 59.550
Outras perguntas?

644
00: 29: 59,550 -> 00: 30: 01.100
Sim?

645
00: 30: 01,100 -> 00: 30: 07.083
PÚBLICO: O que aconteceria se sua barra invertida estivesse fora das aspas.

646
00: 30: 07,083 -> 00: 30: 08.500
DAVID MALAN: Boa pergunta.

647
00: 30: 08,500 -> 00: 30: 11.270
O que aconteceria se sua barra invertida n estivesse fora das aspas?

648
00: 30: 11,270 -> 00: 30: 12.210
Bem, deixe-me fazer isso.

649
00: 30: 12,210 -> 00: 30: 14.210
E, francamente, esse é o instinto certo de se ter.

650
00: 30: 14,210 -> 00: 30: 17.250
A qualquer momento, a frente, que você tenha as mesmas perguntas instintivas,

651
00: 30: 17,250 -> 00: 30: 17.880
apenas tente.

652
00: 30: 17,880 -> 00: 30: 19.770
Você não pode fazer mal ao computador.

653
00: 30: 19,770 -> 00: 30: 22.170
Então deixe-me ir em frente e acidentalmente, se vocês me permitem,

654
00: 30: 22,170 -> 00: 30: 24.510
coloque a barra invertida n fora das aspas,

655
00: 30: 24,510 -> 00: 30: 25.978
é o que eu acho que foi sua pergunta.

656
00: 30: 25,978 -> 00: 30: 27.520
Tudo bem, então vamos ver o que acontece.

657
00: 30: 27,520 -> 00: 30: 29.490
Então, vou agora e executar o Clang.

658
00: 30: 29,490 -> 00: 30: 31.470
Eu sei como fazer um nome personalizado agora,

659
00: 30: 31,470 -> 00: 30: 34.380
então vou adotar essa convenção. -o hello.

660
00: 30: 34,380 -> 00: 30: 36.720
E agora vou dizer hello.c

661
00: 30: 36,720 -> 00: 30: 38.940
que eu acho que vai quebrar.

662
00: 30: 38,940 -> 00: 30: 41.910
E, de fato, algo, de fato, quebrou aqui.

663
00: 30: 41,910 -> 00: 30: 43.420
Vamos ver qual é o erro.

664
00: 30: 43,420 -> 00: 30: 48.210
Portanto, é um pouco arcaico também, mas hello.c, dois pontos 5, dois pontos 26.

665
00: 30: 48,210 -> 00: 30: 49.240
O que está acontecendo lá?

666
00: 30: 49,240 -> 00: 30: 50.370
Bem, deixe-me diminuir o zoom.

667
00: 30: 50,370 -> 00: 30: 53.110
Sempre que você cometer um erro em seu código como este,

668
00: 30: 53,110 -> 00: 30: 57.870
O Clang vai tentar ajudá-lo a descobrir onde está esse erro ou bug.

669
00: 30: 57,870 -> 00: 31: 02.760
Portanto, hello.c Dois pontos 5 significa procurar na linha 5 por seu erro.

670
00: 31: 02,760 -> 00: 31: 07.930
Então, veja, ele diz erro - esperado parênteses de fechamento bem por aqui.

671
00: 31: 07,930 -> 00: 31: 11.500
Então é um pouco estranho, porque não, eu não quero fechar parênteses,

672
00: 31: 11,500 -> 00: 31: 12.000
Eu acho.

673
00: 31: 12.000 -> 00: 31: 13.170
Eu quero a nova linha.

674
00: 31: 13,170 -> 00: 31: 16.080
Portanto, não é perfeitamente capaz de dizer a você, ei,

675
00: 31: 16,080 -> 00: 31: 18.450
essa "\n" deve estar entre as aspas.

676
00: 31: 18,450 -> 00: 31: 21.780
Mas pode pelo menos ajudá-lo a descobrir onde está o erro.

677
00: 31: 21,780 -> 00: 31: 24.000
Então, está em algum lugar por aí, ao qual

678
00: 31: 24.000 -> 00: 31: 26.850
sua própria memória ou sua própria pesquisa no Google deve funcionar para descobrir,

679
00: 31: 26,850 -> 00: 31: 29.717
oh, isso tem que estar entre as aspas.

680
00: 31: 29,717 -> 00: 31: 30.300
Boa pergunta.

681
00: 31: 30,300 -> 00: 31: 31.883
Houve uma terceira pergunta lá atrás?

682
00: 31: 31,883 -> 00: 31: 32.430
Sim?

683
00: 31: 32,430 -> 00: 31: 32.930
Não?

684
00: 31: 32,930 -> 00: 31: 33.480
ESTÁ BEM.

685
00: 31: 33,480 -> 00: 31: 37.860
Tudo bem, então vamos prosseguir agora e fazer a transição para alguns outros recursos

686
00: 31: 37,860 -> 00: 31: 39.360
que podemos fazer, também -

687
00: 31: 39,360 -> 00: 31: 42.630
ou seja, implementar o mesmo programa que acabei de fazer.

688
00: 31: 42,630 -> 00: 31: 45.600
Vou fechar este arquivo e criar um novo chamado,

689
00: 31: 45,600 -> 00: 31: 49.173
digamos, string.c, porque agora estou fazendo experiências com strings.

690
00: 31: 49,173 -> 00: 31: 50.590
E vou começar como antes -

691
00: 31: 50,590 -> 00: 31: 55.260
incluir stdio.h int main void.

692
00: 31: 55,260 -> 00: 32: 01.470
E então vou prosseguir aqui e dizer string resposta get_string,

693
00: 32: 01,470 -> 00: 32: 07.020
entre aspas, qual é o seu nome, ponto de interrogação, "\n", ponto e vírgula.

694
00: 32: 07,020 -> 00: 32: 09.448
E, à parte, tudo que eu digito no teclado

695
00: 32: 09,448 -> 00: 32: 11.490
hoje vamos postar no site do curso depois.

696
00: 32: 11,490 -> 00: 32: 15.010
Portanto, não há necessidade de digitar cada pequeno caractere, se você não quiser.

697
00: 32: 15,010 -> 00: 32: 18.448
E então vou dizer printf, abre aspas fecha aspas, olá, resposta.

698
00: 32: 18,448 -> 00: 32: 20.490
Não "resposta", porque afirmamos que isso era ruim.

699
00: 32: 20,490 -> 00: 32: 22.440
Isso diria literalmente resposta.

700
00: 32: 22,440 -> 00: 32: 24.750
Eu quero fazer um placeholder, %s.

701
00: 32: 24,750 -> 00: 32: 29.920
E agora "\n", vírgula, resposta, ponto e vírgula.

702
00: 32: 29,920 -> 00: 32: 32.910
Então Acho que transcrevi o código do slide

703
00: 32: 32,910 -> 00: 32: 37.920
em meu ambiente de programação agora em um arquivo chamado string.c.

704
00: 32: 37,920 -> 00: 32: 39.300
Então, deixe-me ir em frente e diminuir o zoom.

705
00: 32: 39,300 -> 00: 32: 41.790
E se eu quiser compilar este programa, convertê-lo

706
00: 32: 41,790 -> 00: 32: 46.795
do código-fonte ao código de máquina, que comando posso digitar aqui?

707
00: 32: 46,795 -> 00: 32: 47.295
Então, Clang.

708
00: 32: 47,295 -> 00: 32: 50.150


709
00: 32: 50,150 -> 00: 32: 51.210
Então string.c.

710
00: 32: 51,210 -> 00: 32: 53.590
Mas isso vai me dar um programa, por padrão, chamado

711
00: 32: 53,590 -> 00: 32: 56.030
a.out, o que é muito inútil.

712
00: 32: 56,030 -> 00: 32: 58.670
Então, deixe-me ir em frente e dizer -o string, apenas para

713
00: 32: 58,670 -> 00: 33: 00.230
que meu programa seja chamado de string

714
00: 33: 00,230 -> 00: 33: 02.090
Mas eu poderia chamá-lo do que eu quiser.

715
00: 33: 02,090 -> 00: 33: 04.975
Eu poderia chamá-lo de programa dois, se preferir.

716
00: 33: 04,975 -> 00: 33: 06.350
Deixe-me ir em frente e pressione Enter.

717
00: 33: 06,350 -> 00: 33: 10.220
E ai meu Deus, há mais erros do que linhas

718
00: 33: 10,220 -> 00: 33: 12.320
de código, o que é um pouco preocupante.

719
00: 33: 12,320 -> 00: 33: 15.530
E esta segunda camada é onde você deve se consolar, pois isso significa apenas

720
00: 33: 15,530 -> 00: 33: 17.113
o computador ficou confuso, certo?

721
00: 33: 17,113 -> 00: 33: 20.480
Você não é tão ruim em programação que gera mais erros do que linhas

722
00: 33: 20,480 -> 00: 33: 21.860
de código que você mesmo escreveu.

723
00: 33: 21,860 -> 00: 33: 25.370
É que o computador ficou realmente confuso em algum momento,

724
00: 33: 25,370 -> 00: 33: 28.670
e meio que começa a tropeçar em si mesmo, por assim dizer, conceitualmente.

725
00: 33: 28,670 -> 00: 33: 31.910
Ele não sabe onde está o erro, então começa a interpretar mal o código correto

726
00: 33: 31,910 -> 00: 33: 33.020
como código incorreto.

727
00: 33: 33,020 -> 00: 33: 38.100
Portanto, o ponto de partida é sempre a primeira mensagem de erro.

728
00: 33: 38,100 -> 00: 33: 41.450
Então, você notará que eu já rolei até o comando

729
00: 33: 41,450 -> 00: 33: 44.570
que digitei, que estava bem aqui, como destaquei.

730
00: 33: 44,570 -> 00: 33: 47.270
Concentre-se no primeiro erro que você vê e talvez nos outros

731
00: 33: 47,270 -> 00: 33: 50.985
são apenas erros fantasmas, confusões que surgiram em seu lugar.

732
00: 33: 50,985 -> 00: 33: 53.360
Então, deixe-me ir em frente e ampliar essa parte da tela

733
00: 33: 53,360 -> 00: 33: 55.700
e ver se não podemos diagnosticar esse problema.

734
00: 33: 55,700 -> 00: 33: 59.420
O comando que executei foi Clang -o string string.c.

735
00: 33: 59,420 -> 00: 34: 02.480
Isso significa apenas que minha entrada é meu código-fonte em string.c.

736
00: 34: 02,480 -> 00: 34: 06.500
Quero que minha saída seja um código de máquina em um arquivo chamado string.

737
00: 34: 06,500 -> 00: 34: 09.409
Tudo bem, string.c linha 5 é onde o erro começa,

738
00: 34: 09,409 -> 00: 34: 11.540
então esse parece ser um local familiar.

739
00: 34: 11,540 -> 00: 34: 13.820
Uso de identificador "string" não declarado.

740
00: 34: 13,820 -> 00: 34: 19.960
Você quis dizer - antecipação - stdin?

741
00: 34: 19,960 -> 00: 34: 21.280
Não, não quis.

742
00: 34: 21,280 -> 00: 34: 22.600
Eu quis dizer string neste caso.

743
00: 34: 22,600 -> 00: 34: 25.159
Então, aqui também, o computador ficou confuso,

744
00: 34: 25,159 -> 00: 34: 28.179
e mesmo que seja uma útil mensagem em verde na verdade não é útil.

745
00: 34: 28,179 -> 00: 34: 29.679
Não, eu quero uma string.

746
00: 34: 29,679 -> 00: 34: 31.270
Eu não quero "standard n".

747
00: 34: 31,270 -> 00: 34: 34.060
Mas a razão para isso é que, tecnicamente,

748
00: 34: 34,060 -> 00: 34: 37.420
pelo menos neste ponto da história, não existe essa tal de string,

749
00: 34: 37,420 -> 00: 34: 41.699
S-T-R-I-N-G em C. Na verdade, é uma espécie de rodinhas de apoio

750
00: 34: 41,699 -> 00: 34: 44.949
vamos usar por apenas algumas semanas até que, para sua pergunta anterior,

751
00: 34: 44,949 -> 00: 34: 48.340
vamos mostrar o que realmente está acontecendo sob o capô do computador,

752
00: 34: 48,340 -> 00: 34: 51.130
por assim dizer, quando se trata de implementar uma string.

753
00: 34: 51,130 -> 00: 34: 56.620
Então string é algo que o curso CS50 oferece a você

754
00: 34: 56,620 -> 00: 35: 01.570
em um arquivo chamado CS50.h.

755
00: 35: 01,570 -> 00: 35: 06.355
Assim como existe um arquivo chamado "stardard I/O"-

756
00: 35: 06,355 -> 00: 35: 10.330
onde I/O significa apenas "input/output" entrada/saída, como imprimir e obter entrada.

757
00: 35: 10,330 -> 00: 35: 16.060
Assim como existe um arquivo chamado stdio.h, no qual printf foi inventado,

758
00: 35: 16,060 -> 00: 35: 19.420
todas essas outras funções que posso usar neste programa,

759
00: 35: 19,420 -> 00: 35: 25.000
como get_string, está armazenado em um arquivo chamado CS50.h.

760
00: 35: 25.000 -> 00: 35: 28.150
Então, meu problema surgiu um momento atrás, ao compilar este código,

761
00: 35: 28,150 -> 00: 35: 30.640
porque o computador não tinha ideia do que é uma string.

762
00: 35: 30,640 -> 00: 35: 34.870
E não tem ideia - veremos o que é a função get_string.

763
00: 35: 34,870 -> 00: 35: 37.570
Deixe-me ir em frente e recompilar isso agora.

764
00: 35: 37,570 -> 00: 35: 46.130
Vou prosseguir e fazer Clang -o string string.c e aumentar o zoom.

765
00: 35: 46,130 -> 00: 35: 46.630
Aqui vamos nós.

766
00: 35: 46,630 -> 00: 35: 47.820
Enter.

767
00: 35: 47,820 -> 00: 35: 49.930
OK, progresso.

768
00: 35: 49,930 -> 00: 35: 51.100
Ainda é um bug.

769
00: 35: 51,100 -> 00: 35: 53.230
Ainda há um erro, porque o vermelho não pode

770
00: 35: 53,230 -> 00: 35: 54.850
significa qualquer coisa boa neste contexto.

771
00: 35: 54,850 -> 00: 35: 56.590
E, de fato, é um erro.

772
00: 35: 56,590 -> 00: 35: 58.940
Mas são muito menos erros.

773
00: 35: 58,940 -> 00: 36: 02.080
Portanto, este é o último comando que precisamos apresentar agora.

774
00: 36: 02,080 -> 00: 36: 04.240
Observe o que a mensagem de erro está dizendo.

775
00: 36: 04,240 -> 00: 36: 07.450
Depois de executar o Clang -o string string.c, há

776
00: 36: 07,450 -> 00: 36: 09.490
ainda é um problema na minha função principal.

777
00: 36: 09,490 -> 00: 36: 11.170
Qual é o problema?

778
00: 36: 11,170 -> 00: 36: 13.480
Referência indefinida para get_string.

779
00: 36: 13,480 -> 00: 36: 18.490
Portanto, ao usar a biblioteca CS50, você precisa fazer duas coisas.

780
00: 36: 18,490 -> 00: 36: 21.100
Em seu código-fonte, você tem que dizer ao computador

781
00: 36: 21,100 -> 00: 36: 23.800
para incluir este arquivo CS50.h, onde, novamente,

782
00: 36: 23,800 -> 00: 36: 26.860
funções como get_string e a palavra string

783
00: 36: 26,860 -> 00: 36: 28.870
são realmente implementados para você.

784
00: 36: 28,870 -> 00: 36: 32.170
Mas ao compilar seu código, você precisa, de forma um tanto redundante

785
00: 36: 32,170 -> 00: 36: 37.060
mas por diferentes razões, dizer ao computador para adicionar todo o código

786
00: 36: 37,060 -> 00: 36: 40.600
que a equipe do CS50 escreveu para implementar get_string e string

787
00: 36: 40,600 -> 00: 36: 44.110
e outras funções como esta.

788
00: 36: 44,110 -> 00: 36: 50.530
Então escrever Clang -o string string.c, como antes,

789
00: 36: 50,530 -> 00: 36: 54.400
mas preciso dizer ao computador esta instrução especial

790
00: 36: 54,400 -> 00: 36: 56.410
para vinculá-lo ao CS50.

791
00: 36: 56,410 -> 00: 36: 59.320
E isso fará mais sentido em apenas algumas semanas.

792
00: 36: 59,320 -> 00: 37: 02.620
Mas isso é apenas um -l para link e CS50.

793
00: 37: 02,620 -> 00: 37: 04.720
E tudo isso diz que o computador o que é isso -

794
00: 37: 04,720 -> 00: 37: 10.550
os zeros e uns para o meu programa real virão de string.c certo

795
00: 37: 10,550 -> 00: 37: 11.050
aqui.

796
00: 37: 11,050 -> 00: 37: 12.400
Este é meu código-fonte.

797
00: 37: 12,400 -> 00: 37: 16.780
Mas a equipe do CS50, anos atrás, também escreveu código em C para

798
00: 37: 16,780 -> 00: 37: 19.420
fornecer funções como get_string, para

799
00: 37: 19,420 -> 00: 37: 22.390
fornecer variáveis ​​como strings.

800
00: 37: 22,390 -> 00: 37: 27.070
Os zeros e uns da biblioteca CS50 são armazenados em outro lugar na nuvem.

801
00: 37: 27,070 -> 00: 37: 29.920
Eles precisam estar ligados aos seus.

802
00: 37: 29,920 -> 00: 37: 34.000
Então, assim como seu código está neste arquivo, nosso código está nesse arquivo.

803
00: 37: 34.000 -> 00: 37: 37.330
E assim, dizendo ao computador para incluí-lo em seu código-fonte

804
00: 37: 37,330 -> 00: 37: 40.980
e vinculá-lo a este comando é apenas a maneira arcaica de dizer,

805
00: 37: 40,980 -> 00: 37: 46.930
combine meu código com o código do CS50 em um programa que eu possa realmente executar.

806
00: 37: 46,930 -> 00: 37: 49.180
Agora, tudo isso, francamente é muito rápido

807
00: 37: 49,180 -> 00: 37: 53.170
tornando-se muito opressor, eu acho, e muito desnecessariamente complicado.

808
00: 37: 53,170 -> 00: 37: 56.200
Portanto, há uma maneira melhor do que essa.

809
00: 37: 56,200 -> 00: 38: 00.310
Acontece que, seguindo em frente, se você gostaria de compilar seu código,

810
00: 38: 00,310 -> 00: 38: 01.720
você não precisa se lembrar.

811
00: 38: 01,720 -> 00: 38: 03.935
Você não precisa se lembrar de -l CS50.

812
00: 38: 03,935 -> 00: 38: 07.060
Você não precisa se lembrar de nenhum desses comandos, espero que apenas das ideias.

813
00: 38: 07,060 -> 00: 38: 12.130
Em vez disso, você pode dizer, faça-me um programa chamado string e pronto.

814
00: 38: 12,130 -> 00: 38: 15.970
Toda essa saída é gerada automaticamente para você

815
00: 38: 15,970 -> 00: 38: 18.610
quando você disser ao computador, "make/faça" meu programa.

816
00: 38: 18,610 -> 00: 38: 24.130
E o programa "make" descobrirá quais argumentos de linha de comando usar,

817
00: 38: 24,130 -> 00: 38: 26.800
que nome dar ao arquivo, quais bibliotecas

818
00: 38: 26,800 -> 00: 38: 29.650
ou código que outras pessoas escreveram para serem ligados no seu.

819
00: 38: 29,650 -> 00: 38: 32.500
Portanto, de agora em diante, quando você quiser compilar seu programa,

820
00: 38: 32,500 -> 00: 38: 36.460
literalmente, diga apenas  "make" e o nome do programa.

821
00: 38: 36,460 -> 00: 38: 38.680
Mas não é "make string.c".

822
00: 38: 38,680 -> 00: 38: 41.260
É só "make" e o nome do programa.

823
00: 38: 41,260 -> 00: 38: 43.180
Make, este outro programa, descobrirá

824
00: 38: 43,180 -> 00: 38: 46.630
que você quis dizer algo chamado string.c.

825
00: 38: 46,630 -> 00: 38: 48.910
E posso retroceder e fazer isso para hello também.

826
00: 38: 48,910 -> 00: 38: 50.770
make hello.

827
00: 38: 50,770 -> 00: 38: 53.150
Oh, eu nunca corrigi o problema de antes.

828
00: 38: 53,150 -> 00: 38: 56.660
Então, deixe-me entrar em hello.c abrindo esse arquivo.

829
00: 38: 56,660 -> 00: 38: 59.740
Deixe-me consertar isso para a posteridade.

830
00: 38: 59,740 -> 00: 39: 02.110
Salvar este arquivo ou deixe o arquivo ser salvo automaticamente.

831
00: 39: 02,110 -> 00: 39: 03.310
Agora make hello.

832
00: 39: 03,310 -> 00: 39: 06.100
E viola, fez a mesma coisa pra mim agora.

833
00: 39: 06,100 -> 00: 39: 06.820
Sim?

834
00: 39: 06,820 -> 00: 39: 09.543
PÚBLICO: make é algo padrão... [INAUDÍVEL] ?..

835
00: 39: 09,543 -> 00: 39: 10.960
DAVID MALAN: Boa pergunta.

836
00: 39: 10,960 -> 00: 39: 13.300
"make é algo padrão ou específico do CS50?

837
00: 39: 13,300 -> 00: 39: 16.280
Não é uma coisa específica do CS50.

838
00: 39: 16,280 -> 00: 39: 19.460
É uma ferramenta padrão que existe em Macs, PCs e computadores

839
00: 39: 19,460 -> 00: 39: 21.410
geralmente executando Unix ou Linux.

840
00: 39: 21,410 -> 00: 39: 24.020
E, de fato, a ferramenta sandbox que estamos usando

841
00: 39: 24,020 -> 00: 39: 26.480
é em si um computador na nuvem, embora apenas

842
00: 39: 26,480 -> 00: 39: 30.960
tem essas duas janelas, guias no topo e a janela do terminal embaixo.

843
00: 39: 30,960 -> 00: 39: 32.960
Ao fazer login no CS50 Sandbox, você tem acesso

844
00: 39: 32,960 -> 00: 39: 36.620
ao seu próprio servidor na nuvem executando um sistema operacional chamado Linux.

845
00: 39: 36,620 -> 00: 39: 41.600
E Clang e make e outras ferramentas que veremos, como ls e rm,

846
00: 39: 41,600 -> 00: 39: 43.700
todos existem nesse sistema operacional.

847
00: 39: 43,700 -> 00: 39: 46.580
Eles não são específicos do CS50.

848
00: 39: 46,580 -> 00: 39: 47.768
Sim?

849
00: 39: 47,768 -> 00: 39: 51.235
PÚBLICO: Com isso, hello seria código de máquina, não [INAUDÍVEL] ??

850
00: 39: 51,235 -> 00: 39: 52.110
DAVID MALAN: Correto.

851
00:39:52,110 --> 00:39:53,520
Hello é o código de máquina.

852
00: 39: 53,520 -> 00: 39: 55.756
Hello.c é o código-fonte.

853
00: 39: 55,756 -> 00: 39: 57.244
PÚBLICO: Então [INAUDÍVEL]?

854
00: 39: 57,244 -> 00: 40: 00.915


855
00: 40: 00,915 -> 00: 40: 01.790
DAVID MALAN: Correto.

856
00: 40: 01,790 -> 00: 40: 06.110
Make é um programa inteligente projetado para tornar nossas vidas mais fáceis, sem trocadilhos,

857
00: 40: 06,110 -> 00: 40: 11.210
onde se você fizer "make hello", ele procurará um arquivo chamado hello.c.

858
00: 40: 11,210 -> 00: 40: 14.450
E se o encontrar, criará o programa chamado hello

859
00: 40: 14,450 -> 00: 40: 16.630
do código-fonte ao código de máquina, respectivamente.

860
00: 40: 16,630 -> 00: 40: 17.267
Sim?

861
00: 40: 17,267 -> 00: 40: 18.698
PÚBLICO: [INAUDÍVEL].

862
00: 40: 18,698 -> 00: 40: 22.498


863
00: 40: 22,498 -> 00: 40: 23.540
DAVID MALAN: Não exatamente.

864
00: 40: 23,540 -> 00: 40: 27.770
Portanto, make é um programa que vem com um sistema operacional chamado Linux,

865
00: 40: 27,770 -> 00: 40: 29.150
e também vem com Mac OS.

866
00: 40: 29,150 -> 00: 40: 31.160
E hoje em dia, também vem com o Windows.

867
00: 40: 31,160 -> 00: 40: 34.040
É um programa que você pode executar digitando seu nome,

868
00: 40: 34,040 -> 00: 40: 37.147
não que você execute clicando duas vezes em um ícone.

869
00: 40: 37,147 -> 00: 40: 37.730
Boa pergunta.

870
00: 40: 37,730 -> 00: 40: 38.882
Sim?

871
00: 40: 38,882 -> 00: 40: 39.854
PÚBLICO: [INAUDÍVEL]?

872
00: 40: 39,854 -> 00: 40: 43.755


873
00: 40: 43,755 -> 00: 40: 44.880
DAVID MALAN: Boa pergunta.

874
00: 40: 44,880 -> 00: 40: 46.610
Isso significa que o make está armazenado no seu computador

875
00: 40: 46,610 -> 00: 40: 47.930
ou no computador baseado em nuvem?

876
00: 40: 47,930 -> 00: 40: 49.350
No computador baseado em nuvem.

877
00: 40: 49,350 -> 00: 40: 52.100
Então, até esse ponto do semestre, e nas primeiras semanas,

878
00: 40: 52,100 -> 00: 40: 55.310
tudo o que fizermos será na nuvem em um ambiente padronizado

879
00: 40: 55,310 -> 00: 40: 58.670
chamado CS50 Sandbox e, em breve, algo chamado CS50 Lab.

880
00: 40: 58,670 -> 00: 41: 02.780
Mas é projetado para ser uma representação de um computador Linux padrão

881
00: 41: 02,780 -> 00: 41: 04.210
e também um Mac ou PC.

882
00: 41: 04,210 -> 00: 41: 05.960
Mas o software tende a ser um pouco diferente,

883
00: 41: 05,960 -> 00: 41: 09.470
então padronizamos no Linux, que é um sistema operacional muito popular

884
00: 41: 09,470 -> 00: 41: 12.140
no mundo do desenvolvimento de software.

885
00: 41: 12,140 -> 00: 41: 15.265
Tudo bem, então vamos dar uma olhada em algumas outras equivalências e então

886
00: 41: 15,265 -> 00: 41: 18.015
comparações e começar a escrever programas mais interessantes do que estes

887
00: 41: 18,015 -> 00: 41: 19.220
que apenas dizem olá, mundo.

888
00: 41: 19,220 -> 00: 41: 22.400
Então, aqui está, novamente, um resumo de como você tecnicamente

889
00: 41: 22,400 -> 00: 41: 25.070
deve converter seu código fonte em código de máquina

890
00: 41: 25,070 -> 00: 41: 28.580
usando um programa chamado Clang com um argumento de linha de comando,

891
00: 41: 28,580 -> 00: 41: 33.322
um parâmetro especial, -o hello, para nomear o arquivo de outra forma.

892
00: 41: 33,322 -> 00: 41: 35.780
E honestamente, ninguém nunca vai se lembrar desse comando.

893
00: 41: 35,780 -> 00: 41: 37.905
E mesmo se você fizer isso, é muito entediante digitar.

894
00: 41: 37,905 -> 00: 41: 40.250
É por isso que programas como o make existem, que

895
00: 41: 40,250 -> 00: 41: 42.142
apenas automatize exatamente o mesmo processo.

896
00: 41: 42,142 -> 00: 41: 43.850
Mas eles ainda estão fazendo a mesma coisa -

897
00: 41: 43,850 -> 00: 41: 46.700
compilar seu código-fonte em código de máquina.

898
00: 41: 46,700 -> 00: 41: 48.500
E para executar o programa depois disso, você diz

899
00: 41: 48,500 -> 00: 41: 50.920
ponto, que se refere apenas à sua pasta atual,

900
00: 41: 50,920 -> 00: 41: 54.140
porque veremos que você pode ter várias pastas em um servidor, e hello

901
00: 41: 54,140 -> 00: 41: 55.510
é o nome do programa.

902
00: 41: 55,510 -> 00: 41: 58.760
Tudo bem, vamos dar uma olhada em alguns outros tipos de recursos do Scratch

903
00: 41: 58,760 -> 00: 42: 00.510
e ver como ficam em C,

904
00: 42: 00,510 -> 00: 42: 04.560
e então começaremos a implementar alguns programas em C mais manualmente.

905
00: 42: 04,560 -> 00: 42: 07.130
Portanto, considere este exemplo aqui, que foi um exemplo

906
00: 42: 07,130 -> 00: 42: 11.450
de que tipo de característica no Scratch?

907
00: 42: 11,450 -> 00: 42: 13.300
Isso fez o quê por nós?

908
00: 42: 13,300 -> 00: 42: 14.260
PÚBLICO: Variável.

909
00: 42: 14,260 -> 00: 42: 16.000
DAVID MALAN: Este foi um exemplo de variável.

910
00: 42: 16.000 -> 00: 42: 18.167
E essa variável, neste caso, foi chamada de contador.

911
00: 42: 18,167 -> 00: 42: 21.130
E nós a inicializamos como-- isto é, nós o definimos igual a-- zero.

912
00: 42: 21,130 -> 00: 42: 24.220
Em C, do lado direito, se quisermos obter este mesmo resultado

913
00: 42: 24,220 -> 00: 42: 27.190
de hoje em diante, você vai literalmente dizer o nome da variável,

914
00: 42: 27,190 -> 00: 42: 30.490
como contador, mas você pode chamá-lo do que quiser, igual a zero.

915
00: 42: 30,490 -> 00: 42: 33.198
Porque lembre-se de que o sinal de igual é o operador de atribuição.

916
00: 42: 33,198 -> 00: 42: 34.990
Então, o que está à direita vai ser

917
00: 42: 34,990 -> 00: 42: 37.210
copiado para o que estiver à esquerda.

918
00: 42: 37,210 -> 00: 42: 41.200
No entanto, isso não é suficiente, porque quando você declara uma variável

919
00: 42: 41,200 -> 00: 42: 44.230
e você diz, ei, computador, preciso de algum armazenamento para algum valor,

920
00: 42: 44,230 -> 00: 42: 47.950
você tem que dizer ao computador qual é o tipo dessa variável.

921
00: 42: 47,950 -> 00: 42: 52.000
Vimos que strings são variáveis ​​que armazenam várias palavras.

922
00: 42: 52.000 -> 00: 42: 55.000
Mas, neste caso, queremos armazenar um número.

923
00: 42: 55.000 -> 00: 42: 58.390
E em C, esse tipo de número é chamado de int ou integer,

924
00: 42: 58,390 -> 00: 43: 00.070
mas I-N-T para abreviar.

925
00: 43: 00,070 -> 00: 43: 02.147
Há uma coisa faltando nesta linha de código.

926
00: 43: 02,147 -> 00: 43: 02.980
PÚBLICO: Ponto e vírgula.

927
00: 43: 02,980 -> 00: 43: 03.610
DAVID MALAN: Ponto e vírgula.

928
00: 43: 03,610 -> 00: 43: 04.840
Apenas termina o pensamento.

929
00: 43: 04,840 -> 00: 43: 05.830
Então, o que isso faz?

930
00: 43: 05,830 -> 00: 43: 10.270
Ei, computador, me dê uma variável cujo tipo seja itneger ou int.

931
00: 43: 10,270 -> 00: 43: 15.280
Chame esse contador de variável e armazene o valor zero nessa variável

932
00: 43: 15,280 -> 00: 43: 19.970
por padrão. Acontece que podemos fazer outras operações desse tipo em variáveis.

933
00: 43: 19,970 -> 00: 43: 23.460
Por exemplo, aqui temos o recurso de incrementação do Scratch.

934
00: 43: 23,460 -> 00: 43: 27.080
Altere o contador em um adicionando 1 à variável.

935
00: 43: 27,080 -> 00: 43: 28.510
Então, como fazemos isso em C?

936
00: 43: 28,510 -> 00: 43: 30.800
Em C, você faria algo assim.

937
00: 43: 30,800 -> 00: 43: 35.110
E isso é um pouco paradoxal se você está vindo da álgebra,

938
00: 43: 35,110 -> 00: 43: 38.110
porque como poderia counter ser igual a counter mais 1?

939
00: 43: 38,110 -> 00: 43: 39.560
Mas aqui isso não é igualdade.

940
00: 43: 39,560 -> 00: 43: 41.780
Esta é uma atribuição da direita para a esquerda.

941
00: 43: 41,780 -> 00: 43: 43.780
Portanto, no lado esquerdo, você está dizendo counter.

942
00: 43: 43,780 -> 00: 43: 45.190
Esse é o nome da sua variável.

943
00: 43: 45,190 -> 00: 43: 47.500
No lado direito, você está dizendo counter mais 1,

944
00: 43: 47,500 -> 00: 43: 49.390
qualquer que seja essa resposta aritmética.

945
00: 43: 49,390 -> 00: 43: 53.260
E você está copiando o contador mais 1 no contador.

946
00: 43: 53,260 -> 00: 43: 56.420
Ainda estou sentindo falta de alguma coisa aqui, que é aquele ponto e vírgula.

947
00: 43: 56,420 -> 00: 44: 00.580
Mas não preciso dizer int neste exemplo.

948
00: 44: 00,580 -> 00: 44: 05.200
Neste ponto da história, presume-se que counter já exista

949
00: 44: 05,200 -> 00: 44: 08.020
e que usei uma linha de código como a anterior

950
00: 44: 08,020 -> 00: 44: 10.270
em outro lugar no meu programa.

951
00: 44: 10,270 -> 00: 44: 13.330
Porque isso diz ao computador uma vez, dê-me uma variável chamada counter,

952
00: 44: 13,330 -> 00: 44: 14.950
e deixe-me armazenar ints nela.

953
00: 44: 14,950 -> 00: 44: 17.110
Esta linha de código assume que counter já exista,

954
00: 44: 17,110 -> 00: 44: 20.410
e, portanto, não especificamos a palavra int novamente.

955
00: 44: 20,410 -> 00: 44: 22.060
Você especifica apenas uma vez.

956
00: 44: 22,060 -> 00: 44: 24.040
Agora, precisamos do ponto-e-vírgula, como propus.

957
00: 44: 24,040 -> 00: 44: 26.680
Mas, francamente, esta é uma operação tão comum na programação,

958
00: 44: 26,680 -> 00: 44: 28.930
como veremos, apenas para incrementar uma variável.

959
00: 44: 28,930 -> 00: 44: 31.280
Acontece que há outras maneiras de fazer isso.

960
00: 44: 31,280 -> 00: 44: 33.520
Você pode, em vez disso, equivalentemente dizer isso -

961
00: 44: 33,520 -> 00: 44: 36.250
counter mais igual 1 ponto-e-vírgula.

962
00: 44: 36,250 -> 00: 44: 37.800
É literalmente a mesma coisa.

963
00: 44: 37,800 -> 00: 44: 39.550
E se isso for muito para você,

964
00: 44: 39,550 -> 00: 44: 42.910
você pode literalmente apenas dizer counter mais mais ponto-e-vírgula,

965
00: 44: 42,910 -> 00: 44: 44.500
e isso também faz a mesma coisa.

966
00: 44: 44,500 -> 00: 44: 47.650
Isso é conhecido em programação como sintaxe adocicada.

967
00: 44: 47,650 -> 00: 44: 51.110
Ela não adiciona nenhuma funcionalidade que você não poderia fazer de outra maneira.

968
00: 44: 51,110 -> 00: 44: 53.800
Mas faz isso de uma forma mais bonita, geralmente mais sucinta.

969
00: 44: 53,800 -> 00: 44: 56.680
E é mais comum escrever linhas de código como esta.

970
00: 44: 56,680 -> 00: 44: 58.430
Tudo bem, vamos considerar outro exemplo.

971
00: 44: 58,430 -> 00: 45: 01.750
Isso foi chamado de quê no Scratch?

972
00: 45: 01,750 -> 00: 45: 03.980
Sim, uma condição, uma decisão que você tem que tomar.

973
00: 45: 03,980 -> 00: 45: 06.310
Portanto, se algo for verdade, faça isso.

974
00: 45: 06,310 -> 00: 45: 08.720
Em C, podemos convertê-lo da seguinte maneira.

975
00: 45: 08,720 -> 00: 45: 11.260
Se x menor que y entre parênteses -

976
00: 45: 11,260 -> 00: 45: 15.300
que não é bem a forma angular que temos aqui em verde, mas em C,

977
00: 45: 15,300 -> 00: 45: 16.780
você usa parênteses aqui.

978
00: 45: 16,780 -> 00: 45: 20.380
Portanto, se x for menor que y, abre parênteses, fecha parênteses,

979
00: 45: 20,380 -> 00: 45: 21.970
então vá em frente e faça o seguinte.

980
00: 45: 21,970 -> 00: 45: 25.720
E assim como esta peça amarela ou laranja do quebra-cabeça parece que está

981
00: 45: 25,720 -> 00: 45: 29.920
abraçando a peça roxa do quebra-cabeça, esta chave aberta também

982
00: 45: 29,920 -> 00: 45: 32.830
e esta chave fechada, por assim dizer, está meio que lá

983
00: 45: 32,830 -> 00: 45: 36.050
pronta para abraçar ou encapsular uma ou mais linhas de código.

984
00: 45: 36,050 -> 00: 45: 37.090
Qual é a linha de código?

985
00: 45: 37,090 -> 00: 45: 42.640
Pode ser algo assim - printf x é menor que y barra invertida n.

986
00: 45: 42,640 -> 00: 45: 47.080
Então, novamente, nova sintaxe, mas vimos as chaves antes

987
00: 45: 47,080 -> 00: 45: 48.490
no contexto de principal.

988
00: 45: 48,490 -> 00: 45: 52.280
E vimos parênteses antes no contexto de entradas.

989
00: 45: 52,280 -> 00: 45: 54.520
Portanto, este é apenas um tipo de padrão que iremos

990
00: 45: 54,520 -> 00: 45: 58.530
comece a seguir em C sempre que quisermos fazer algo condicionalmente.

991
00: 45: 58,530 -> 00: 46: 01.000
OK, no Scratch, vimos algo assim -

992
00: 46: 01.000 -> 00: 46: 04.300
se x for menor que y, então digamos que x seja menor que y.

993
00: 46: 04,300 -> 00: 46: 06.730
Caso contrário, conclua que x não é menor que y.

994
00: 46: 06,730 -> 00: 46: 11.380
Em C, quase parece o mesmo, mas você mesmo deve montar o bloco "else"

995
00: 46: 11,380 -> 00: 46: 15.010
com dois conjuntos de chaves, meio que dois caracteres prontos para abraçar

996
00: 46: 15,010 -> 00: 46: 16.600
as linhas de código entre eles.

997
00: 46: 16,600 -> 00: 46: 19.660
E podemos apenas inserir agora, literalmente, as traduções para o printf

998
00: 46: 19,660 -> 00: 46: 25.060
dizendo que printf x é menor que y ou printf x não é menor que y.

999
00: 46: 25,060 -> 00: 46: 28.450
Agora, observe, há apenas dois pontos e vírgulas neste exemplo.

1000
00: 46: 28,450 -> 00: 46: 33.430
Geralmente, você não termina coisas como condições com ponto e vírgula.

1001
00: 46: 33,430 -> 00: 46: 37.690
Você termina funções ou linhas que envolvem funções com ponto e vírgula.

1002
00: 46: 37,690 -> 00: 46: 39.850
E essa não é uma regra que vale para tudo, mas você

1003
00: 46: 39,850 -> 00: 46: 42.490
não quer linhas de código - você não quer ponto e vírgula

1004
00: 46: 42,490 -> 00: 46: 43.870
após cada linha de código.

1005
00: 46: 43,870 -> 00: 46: 45.855
Você geralmente quer depois de alguma ação.

1006
00: 46: 45,855 -> 00: 46: 48.730
E você começará a notar esse padrão, embora talvez não seja

1007
00: 46: 48,730 -> 00: 46: 50.560
óbvio no início.

1008
00: 46: 50,560 -> 00: 46: 52.260
Certo, que tal esse?

1009
00: 46: 52,260 -> 00: 46: 55.090
If, else if, else if.

1010
00: 46: 55.090 -> 00: 46: 58.900
Agora, observe que estamos apenas reutilizando o bloco if-else if e depois outro

1011
00: 46: 58,900 -> 00: 47: 00.250
bloco if aqui.

1012
00: 47: 00,250 -> 00: 47: 02.500
Acontece que em C, é quase um pouco mais fácil.

1013
00: 47: 02,500 -> 00: 47: 04.120
Você pode literalmente apenas dizer isso -

1014
00: 47: 04,120 -> 00: 47: 07.060
se x for menor que y, faça isso com chaves.

1015
00: 47: 07,060 -> 00: 47: 10.220
Caso contrário, se x for maior do que y, faça isso entre chaves.

1016
00: 47: 10,220 -> 00: 47: 14.160
Caso contrário, se x for igual a y, faça isso entre chaves.

1017
00: 47: 14,160 -> 00: 47: 16.050
E o que você quer fazer em cada caso?

1018
00: 47: 16,050 -> 00: 47: 20.560
Printf's diferentes com base nas mensagens que queremos exibir.

1019
00: 47: 20,560 -> 00: 47: 23.220
Mas há uma curiosidade aqui.

1020
00: 47: 23,220 -> 00: 47: 26.550
Quase parece um erro de digitação.

1021
00: 47: 26,550 -> 00: 47: 28.278
Sim, o duplo sinal de igual.

1022
00: 47: 28,278 -> 00: 47: 29.070
Mas não é um bug.

1023
00: 47: 29,070 -> 00: 47: 29.940
Não é um engano.

1024
00: 47: 29,940 -> 00: 47: 35.070
Por que estou usando dois iguais aqui em vez de um único sinal de igual,

1025
00: 47: 35,070 -> 00: 47: 36.990
como no Scratch?

1026
00: 47: 36,990 -> 00: 47: 37.980
Deixe-me detalhar aqui.

1027
00: 47: 37,980 -> 00: 47: 38.687
Sim?

1028
00: 47: 38,687 -> 00: 47: 42.335
PÚBLICO: [INAUDÍVEL].

1029
00: 47: 42,335 -> 00: 47: 43.210
DAVID MALAN: Exatamente.

1030
00: 47: 43,210 -> 00: 47: 46.420
Eu disse anteriormente que o único sinal de igual é usado para atribuição da direita

1031
00: 47: 46,420 -> 00: 47: 47.140
para a esquerda.

1032
00: 47: 47,140 -> 00: 47: 49.120
E honestamente, esta é apenas uma situação humana, onde

1033
00: 47: 49,120 -> 00: 47: 50.590
nós nos colocamos em um canto.

1034
00: 47: 50,590 -> 00: 47: 53.050
Já usamos o sinal de igual para atribuição.

1035
00: 47: 53,050 -> 00: 47: 56.570
Então, presumivelmente, algum humano percebeu: "A, nossa, como vamos fazer a pergunta,

1036
00: 47: 56,570 -> 00: 47: 57.808
isso é igual a isso?"

1037
00: 47: 57.808 -> 00: 47: 59.350
Bem, já usamos esse símbolo.

1038
00: 47: 59,350 -> 00: 48: 01.510
Então, os humanos, décadas atrás, decidiram, tudo bem,

1039
00: 48: 01,510 -> 00: 48: 05.200
vamos resolver esse problema usando apenas dois sinais de iguais lado a lado.

1040
00: 48: 05,200 -> 00: 48: 07.690
Portanto, este é o chamado operador de igualdade.
1041
00: 48: 07,690 -> 00: 48: 09.633
Um único sinal de igual é apenas a atribuição.

1042
00: 48: 09,633 -> 00: 48: 12.550
Este é, sem dúvida, um dos erros mais comuns de se cometer no início,

1043
00: 48: 12,550 -> 00: 48: 15.730
especialmente se você usa Scratch ou outras linguagens de antemão.

1044
00: 48: 15,730 -> 00: 48: 18.880
E você só consegue desenvolver a memória muscular ao longo do tempo.

1045
00: 48: 18,880 -> 00: 48: 22.030
Depois que você cometer esse erro algumas vezes, ele desaparecerá.

1046
00: 48: 22,030 -> 00: 48: 24.010
Tudo bem, mas acontece que este programa,

1047
00: 48: 24,010 -> 00: 48: 26.530
embora indiscutivelmente correto - ou este código, embora correto,

1048
00: 48: 26,530 -> 00: 48: 30.340
em que vai fazer isso ou isso ou aquilo - e eu acho que aqueles

1049
00: 48: 30,340 -> 00: 48: 31.960
são as três situações possíveis.

1050
00: 48: 31,960 -> 00: 48: 37.090
Se você tiver dois inteiros, x e y, x é menor que y, maior que y,

1051
00: 48: 37,090 -> 00: 48: 38.530
ou igual a y.

1052
00: 48: 38,530 -> 00: 48: 42.490
Mas uma dessas questões tecnicamente não precisa ser feita.

1053
00: 48: 42,490 -> 00: 48: 45.400
Há tecnicamente três expressões booleanas aqui, certo -

1054
00: 48: 45,400 -> 00: 48: 49.098
x menor que y, x maior que y, x é igual a y.

1055
00: 48: 49,098 -> 00: 48: 50.890
Uma expressão booleana, lembre-se, é uma pergunta

1056
00: 48: 50,890 -> 00: 48: 56.170
que tem uma resposta sim / não ou uma resposta verdadeiro / falso ou uma resposta 1/0.

1057
00: 48: 56,170 -> 00: 48: 59.560
Mas não preciso fazer três perguntas aqui, preciso?

1058
00: 48: 59,560 -> 00: 49: 00.920
Acho que vi sua mão.

1059
00: 49: 00,920 -> 00: 49: 01.654
Por que não?

1060
00: 49: 01,654 -> 00: 49: 05.920
PÚBLICO: Bem, porque se x for menor que [INAUDÍVEL] ..

1061
00: 49: 05,920 -> 00: 49: 09.975


1062
00: 49: 09,975 -> 00: 49: 10.850
DAVID MALAN: Exatamente.

1063
00: 49: 10.850 -> 00: 49: 14.570
Esta terceira pergunta, esta expressão booleana, x é igual a y,

1064
00: 49: 14,570 -> 00: 49: 16.700
nem é preciso dizer logicamente.

1065
00: 49: 16,700 -> 00: 49: 19.655
Porque se x não é menor que, e não é maior que,

1066
00: 49: 19,655 -> 00: 49: 22.280
se for apenas [INAUDÍVEL] o único outro cenário que consigo pensar

1067
00: 49: 22,280 -> 00: 49: 24.020
é que é igual a y.

1068
00: 49: 24,020 -> 00: 49: 28.550
Portanto, podemos realmente simplificar o código Scratch e o código C

1069
00: 49: 28,550 -> 00: 49: 31.978
apenas por ter essa condição "else" abaixo.

1070
00: 49: 31,978 -> 00: 49: 33.770
Então, conversaremos nas próximas semanas,

1071
00: 49: 33,770 -> 00: 49: 36.230
sobre diferentes qualidades de código.

1072
00: 49: 36,230 -> 00: 49: 38.480
Acertividade, tal como, isso faz o que deveria fazer?

1073
00: 49: 38,480 -> 00: 49: 42.770
mas também a qualidade do design, como você escreveu este código tão eficientemente quanto

1074
00: 49: 42,770 -> 00: 49: 45.530
possível, o mais rápido possível, de uma forma que

1075
00: 49: 45,530 -> 00: 49: 49.160
usa a menor quantidade de memória e a menor quantidade de CPU,

1076
00: 49: 49,160 -> 00: 49: 50.420
o cérebro do computador?

1077
00: 49: 50,420 -> 00: 49: 54.047
E isso é apenas uma alusão a esse tipo de capacidade.

1078
00: 49: 54,047 -> 00: 49: 55.880
Tudo bem, apenas mais algumas comparações

1079
00: 49: 55,880 -> 00: 49: 58.070
antes de voltarmos a escrever algum código.

1080
00: 49: 58,070 -> 00: 49: 59.397
Que tal algo como isso?

1081
00: 49: 59,397 -> 00: 50: 02.480
No Scratch, nós, é claro, chamamos isso de loop - um ciclo que acontece novamente

1082
00: 50: 02,480 -> 00: 50: 03.740
e novamente e novamente.

1083
00: 50: 03,740 -> 00: 50: 08.120
E um loop como este pode ser implementado em C não da mesma maneira,

1084
00: 50: 08,120 -> 00: 50: 09.080
mas assim.

1085
00: 50: 09,080 -> 00: 50: 11.480
Acontece que a palavra mais próxima da palavra

1086
00: 50: 11,480 -> 00: 50: 14.820
"forever/para sempre" no Scratch é a palavra "while/enquanto".

1087
00: 50: 14,820 -> 00: 50: 17.900
Isso meio que sugere a ideia de fazer algo repetidamente.

1088
00: 50: 17,900 -> 00: 50: 20.330
Esta foi a palavra que os humanos escolheram anos atrás.

1089
00: 50: 20,330 -> 00: 50: 22.280
Mas você não diz apenas "while/enquanto".

1090
00: 50: 22,280 -> 00: 50: 26.090
Você tem que dizer não só o que você quer fazer para sempre,

1091
00: 50: 26,090 -> 00: 50: 29.910
mas você precisa responder a uma expressão booleana.

1092
00: 50: 29,910 -> 00: 50: 32.540
Então, em C, se você deseja implementar um loop,

1093
00: 50: 32,540 -> 00: 50: 36.090
você precisa literalmente ser capaz de dizer enquanto algo é verdade.

1094
00: 50: 36,090 -> 00: 50: 40.850
Você precisa fazer uma pergunta cuja resposta seja um sim ou verdadeiro ou 1.

1095
00: 50: 40,850 -> 00: 50: 42.980
Todos esses são equivalentes a um programador.

1096
00: 50: 42,980 -> 00: 50: 46.130
Então, o que é um exemplo de uma expressão, uma expressão booleana,

1097
00: 50: 46,130 -> 00: 50: 49.990
isso é sempre verdade, se meu objetivo é fazer algo para sempre?

1098
00: 50: 49,990 -> 00: 50: 51.173
PÚBLICO: Cinco é igual a cinco.

1099
00: 50: 51,173 -> 00: 50: 53.340
DAVID MALAN: cinco é igual a cinco, certo.

1100
00: 50: 53,340 -> 00: 50: 55.220
Eu poderia fazer quatro é igual a quatro.

1101
00: 50: 55,220 -> 00: 50: 56.930
Eu poderia fazer dois é maior que um.

1102
00: 50: 56,930 -> 00: 50: 59.030
Eu poderia fazer um é menor do que dois.

1103
00: 50: 59,030 -> 00: 51: 01.640
Eu poderia chegar a um número infinito de expressões booleanas

1104
00: 51: 01,640 -> 00: 51: 03.800
que logicamente são sempre verdadeiros.

1105
00: 51: 03,800 -> 00: 51: 07.070
Mas a maneira mais simples é dizer literalmente a "true/verdadeiro".

1106
00: 51: 07,070 -> 00: 51: 09.050
É um pouco hackeado, mas talvez seja

1107
00: 51: 09,050 -> 00: 51: 12.440
a pergunta mais simples que você pode fazer, porque é "true", por definição,

1108
00: 51: 12,440 -> 00: 51: 16.520
Acontece que é sempre "verdadeiro", assim como falso é sempre falso.

1109
00: 51: 16,520 -> 00: 51: 19.310
E então posso literalmente apenas dizer enquanto verdadeiro para

1110
00: 51: 19,310 -> 00: 51: 24.008
induzir um loop infinito, por assim dizer, que faz algo para sempre.

1111
00: 51: 24,008 -> 00: 51: 26.300
Tudo bem, vamos tentar outro tipo de construção de loop.

1112
00: 51: 26,300 -> 00: 51: 28.192
Este foi um loop que fez algo 50 vezes.

1113
00: 51: 28,192 -> 00: 51: 30.275
Neste, agora temos que ser um pouco mais espertos,

1114
00: 51: 30,275 -> 00: 51: 32.360
e temos que ligar as coisas.

1115
00: 51: 32,360 -> 00: 51: 35.120
Então, se eu quiser fazer algo 50 vezes, aqui está uma maneira.

1116
00: 51: 35,120 -> 00: 51: 37.850
Por que não me dou uma variável e a chamo de contador?

1117
00: 51: 37,850 -> 00: 51: 40.760
Mas eu poderia chamá-lo do que quiser e inicializá-lo como zero.

1118
00: 51: 40,760 -> 00: 51: 42.980
Então, deixe-me ir em frente - sabe de uma coisa?

1119
00: 51: 42,980 -> 00: 51: 44.510
Counter é realmente muito prolixo.

1120
00: 51: 44,510 -> 00: 51: 46.490
A maioria dos programadores, quando estão apenas contando,

1121
00: 51: 46,490 -> 00: 51: 49.557
eles, por convenção, apenas usam a letra i, i para inteiro.

1122
00: 51: 49,557 -> 00: 51: 51.140
Mas você pode chamá-lo do que quiser.

1123
00: 51: 51,140 -> 00: 51: 53.810
Vou chamá-lo de int i igual a zero.

1124
00: 51: 53,810 -> 00: 51: 56.990
Em seguida, vou prosseguir e fazer o seguinte.

1125
00: 51: 56,990 -> 00: 51: 59.840
"while" a seguinte expressão seja verdadeira, deixe-me apenas

1126
00: 51: 59,840 -> 00: 52: 01.790
fazer uma pergunta de novo e de novo...

1127
00: 52: 01,790 -> 00: 52: 06.170
Enquanto i for menor que 50, vou em frente dizendo, "hello world".

1128
00: 52: 06,170 -> 00: 52: 09.300
Então posso imprimir, olá, mundo.

1129
00: 52: 09,300 -> 00: 52: 12.260
Mas ainda não terminei de construir essa lógica.

1130
00: 52: 12,260 -> 00: 52: 14.330
Inicializei uma variável com zero.

1131
00: 52: 14,330 -> 00: 52: 18.380
Vou, repetidamente, fazer a pergunta: i é menor que 50?

1132
00: 52: 18,380 -> 00: 52: 21.530
Mas para que isso funcione logicamente, que outro pedaço de lógica

1133
00: 52: 21,530 -> 00: 52: 24.360
eu preciso adicionar ao código?

1134
00: 52: 24,360 -> 00: 52: 25.916
Sim?

1135
00: 52: 25,916 -> 00: 52: 27.810
PÚBLICO: Você tem que aumentar i em um.

1136
00: 52: 27,810 -> 00: 52: 29.530
DAVID MALAN: Sim, tenho que incrementar i, certo?

1137
00: 52: 29,530 -> 00: 52: 30.770
Então, mesmo que você não se lembre -

1138
00: 52: 30,770 -> 00: 52: 33.130
e tudo bem - a sintaxe para fazer isso, você vai

1139
00: 52: 33,130 -> 00: 52: 35.090
precisar de uma linha de código como esta.

1140
00: 52: 35,090 -> 00: 52: 38.710
Então, logicamente, você vai fazer o seguinte - definir i igual a zero,

1141
00: 52: 38,710 -> 00: 52: 41.120
e, em seguida, faça o seguinte enquanto i for menor que 50.

1142
00: 52: 41,120 -> 00: 52: 42.430
Bem, i é menor que 50?

1143
00: 52: 42,430 -> 00: 52: 45.200
Obviamente, porque 0 é menor que 50.

1144
00: 52: 45,200 -> 00: 52: 46.660
Então você imprime, olá, mundo.

1145
00: 52: 46,660 -> 00: 52: 48.820
E então, como vocês disseram, precisamos incrementar i.

1146
00: 52: 48,820 -> 00: 52: 51.290
Portanto, agora i é igual a i mais 1.

1147
00: 52: 51,290 -> 00: 52: 53.980
Portanto, neste ponto da história, i é igual a 1.

1148
00: 52: 53,980 -> 00: 52: 57.430
E agora a forma como o código funciona, muito parecido com o nosso pseudo código da semana passada,

1149
00: 52: 57,430 -> 00: 53: 00.220
é você meio que implicitamente voltar a esta linha.

1150
00: 53: 00,220 -> 00: 53: 04.010
Na semana passada, em pseudocódigo, eu disse literalmente, volte para a linha 3.

1151
00: 53: 04,010 -> 00: 53: 09.460
Aqui, isso acontece automaticamente por natureza de como C interpreta essas linhas de código

1152
00: 53: 09,460 -> 00: 53: 10.720
nessas chaves.

1153
00: 53: 10,720 -> 00: 53: 12.980
E posso realmente simplificar isso da seguinte maneira.

1154
00: 53: 12,980 -> 00: 53: 14.568
Posso dizer i plus plus.

1155
00: 53: 14,568 -> 00: 53: 17.110
Agora, não é tão bonito quanto o Scratch, onde você apenas diz,

1156
00: 53: 17,110 -> 00: 53: 18.760
repita as seguintes 50 vezes.

1157
00: 53: 18,760 -> 00: 53: 22.630
Mas usando os princípios da semana passada agora traduzidos para C,

1158
00: 53: 22,630 -> 00: 53: 24.760
você pode conectar sua própria lógica que

1159
00: 53: 24,760 -> 00: 53: 27.610
faz algo inúmeras vezes.

1160
00: 53: 27,610 -> 00: 53: 30.430
E há uma outra maneira de fazer isso, só para você ver aqui.

1161
00: 53: 30,430 -> 00: 53: 33.850
Acontece que a maneira mais comum de fazer algo um número fixo de vezes

1162
00: 53: 33,850 -> 00: 53: 36.430
é usar uma preposição diferente - a palavra "for/para".

1163
00: 53: 36,430 -> 00: 53: 38.710
E um loop for se parece com isso.

1164
00: 53: 38,710 -> 00: 53: 43.180
Um loop for faz algo, como imprimir hello world, de novo e de novo,

1165
00: 53: 43,180 -> 00: 53: 44.740
mas é ainda mais mecânico.

1166
00: 53: 44,740 -> 00: 53: 48.580
Mas ele automatiza em uma linha de código exatamente a mesma lógica

1167
00: 53: 48,580 -> 00: 53: 50.020
que acabamos de implementar.

1168
00: 53: 50,020 -> 00: 53: 52.362
Após a palavra "for", você pode colocar os parênteses.

1169
00: 53: 52,362 -> 00: 53: 54.070
E então dentro desses parênteses, você

1170
00: 53: 54,070 -> 00: 53: 56.740
pode dizer algo como, me dê uma variável chamada "counter/contador"

1171
00: 53: 56,740 -> 00: 53: 58.180
e inicialize-a com zero.

1172
00: 53: 58,180 -> 00: 53: 59.410
Ou isso é um pouco verboso.

1173
00: 53: 59,410 -> 00: 54: 00.760
Vamos apenas usar i.

1174
00: 54: 00,760 -> 00: 54: 04.540
Então, isso é idêntico, logicamente, ao que fizemos agora pouco.

1175
00: 54: 04,540 -> 00: 54: 09.190
Mas o "laço for" realmente tem uma, duas, três entradas dentro

1176
00: 54: 09,190 -> 00: 54: 10.000
de seus parênteses.

1177
00: 54: 10.000 -> 00: 54: 12.520
É um pouco extravagante em termos de sintaxe.

1178
00: 54: 12,520 -> 00: 54: 15.790
o segundo parâmetro do loop for é a expressão Booleana

1179
00: 54: 15,790 -> 00: 54: 20.380
o que você quer perguntar repetidamente, então i é menor que 50?

1180
00: 54: 20,380 -> 00: 54: 22.900
E a última coisa que você pode fazer em um loop for

1181
00: 54: 22,900 -> 00: 54: 27.410
é o terceiro parâmetro, onde você pode fazer sua atualização de uma ou mais variáveis.

1182
00: 54: 27,410 -> 00: 54: 32.830
Então, se eu fizer i igual a i mais 1 ou, mais sucintamente, i mais igual 1,

1183
00: 54: 32,830 -> 00: 54: 36.700
ou ainda mais sucinto, i mais mais, eu agora

1184
00: 54: 36,700 -> 00: 54: 40.210
reduzi para apenas quatro linhas de código o que eu anteriormente

1185
00: 54: 40,210 -> 00: 54: 42.440
fiz com algumas linhas a mais de código.

1186
00: 54: 42,440 -> 00: 54: 43.660
Ambos estão corretos.

1187
00: 54: 43,660 -> 00: 54: 45.800
Ambos fazem exatamente a mesma coisa.

1188
00: 54: 45,800 -> 00: 54: 49.580
E mesmo que o loop "for" não seja um tanto óbvio - porque esta é a etapa um,

1189
00: 54: 49,580 -> 00: 54: 52.090
esta é a etapa dois, esta é a etapa três, então

1190
00: 54: 52,090 -> 00: 54: 54.265
em incrementos - atinge o mesmo resultado.

1191
00: 54: 54,265 -> 00: 54: 56.890
E você vai brincar com isso ao longo do tempo nas próximas semanas

1192
00: 54: 56,890 -> 00: 54: 58.510
quando precisar fazer coisas sucessivamente.

1193
00: 54: 58,510 -> 00: 55: 02.830
Mas está é apenas uma maneira mais sucinta de atingir o mesmo objetivo.

1194
00: 55: 02,830 -> 00: 55: 06.940
Alguma dúvida, então, sobre loops "while" ou loops "for" aqui?

1195
00: 55: 06,940 -> 00: 55: 09.990


1196
00: 55: 09,990 -> 00: 55: 15.180
Tudo bem, então vamos dar uma olhada em um conjunto final de definições.

1197
00: 55: 15,180 -> 00: 55: 18.510
Acontece que em C, temos uma lista completa de tipos de dados

1198
00: 55: 18,510 -> 00: 55: 20.210
além de apenas strings e além de ints.

1199
00: 55: 20,210 -> 00: 55: 22.260
E veremos isso e usaremos com o tempo.

1200
00: 55: 22,260 -> 00: 55: 26.320
Você pode ter um bool, por assim dizer, que é literalmente o valor verdadeiro ou falso.

1201
00: 55: 26,320 -> 00: 55: 29.620
E usamos isso implicitamente agora pouco, quando simplismente disse "while true".

1202
00: 55: 29,620 -> 00: 55: 34.140
Você pode ter um char, ou caractere, que é um único caractere, não dois ou mais

1203
00: 55: 34,140 -> 00: 55: 34.920
ou uma frase.

1204
00: 55: 34,920 -> 00: 55: 39.390
É como a letra S ou N se você estiver perguntando sim ou não.

1205
00: 55: 39,390 -> 00: 55: 42.720
Você pode ter um int, é claro, que é um inteiro, uma string, que

1206
00: 55: 42,720 -> 00: 55: 44.940
é um ou mais caracteres entre aspas duplas.

1207
00: 55: 44,940 -> 00: 55: 47.670
Portanto, é maior do que um char individual, normalmente.

1208
00: 55: 47,670 -> 00: 55: 49.650
E então há alguns outros tipos de dados -

1209
00: 55: 49,650 -> 00: 55: 50.700
int e longo.

1210
00: 55: 50,700 -> 00: 55: 52.890
Portanto, int normalmente tem um determinado tamanho.

1211
00: 55: 52,890 -> 00: 55: 55.260
Você só pode contar até certo ponto com um int.

1212
00: 55: 55,260 -> 00: 55: 58.110
Normalmente, você pode contar até 4 bilhões com um int,

1213
00: 55: 58,110 -> 00: 56: 00.610
e isso não é grande o suficiente para determinados aplicativos.

1214
00: 56: 00,610 -> 00: 56: 03.330
As maiores empresas de hoje, como Facebook, Microsoft e Google

1215
00: 56: 03,330 -> 00: 56: 06.240
tem muito mais dados do que 4 bilhões.

1216
00: 56: 06,240 -> 00: 56: 10.030
Portanto, existem coisas chamadas longs, que na verdade usam mais bits.

1217
00: 56: 10,030 -> 00: 56: 12.640
Eles são valores mais amplos, então podem contar ainda mais.

1218
00: 56: 12,640 -> 00: 56: 14.940
Um float é um valor de ponto flutuante, que é

1219
00: 56: 14,940 -> 00: 56: 18.390
uma maneira elegante de dizer um número real, algo que tem um ponto decimal.

1220
00: 56: 18,390 -> 00: 56: 23.130
E um double é apenas um número real que pode ter ainda mais dígitos

1221
00: 56: 23,130 -> 00: 56: 24.790
após o ponto decimal.

1222
00: 56: 24,790 -> 00: 56: 26.370
Então, veremos isso em breve.

1223
00: 56: 26,370 -> 00: 56: 28.950
Bem, que outros recursos a biblioteca do CS50 oferece?

1224
00: 56: 28,950 -> 00: 56: 31.320
Ele fornece não apenas a função get_string,

12: 25h
00: 56: 31,320 -> 00: 56: 35.567
veremos alguns outros como get_int ou get_float ou get_double ou get_char.

1226
00: 56: 35,567 -> 00: 56: 37.650
Todas essas são funções que irão solicitar do ser humano

1227
00: 56: 37,650 -> 00: 56: 42.360
com o prompt piscando por certos valores que eles podem querer fornecer.

1228
00: 56: 42,360 -> 00: 56: 44.540
E então, para "placeholders/marcadores de posição" vamos completar isso.

1229
00: 56: 44,540 -> 00: 56: 48.090
Printf, lembre-se, tinha um "placeholder" para "%s" para uma string.

1230
00: 56: 48,090 -> 00: 56: 50.580
Acontece que tem alguns outros "placeholders" também.

1231
00: 56: 50,580 -> 00: 56: 53.520
Se você quiser conectar um int, vamos começar a usar o "%i".

1232
00: 56: 53,520 -> 00: 56: 55.920
Se você deseja conectar um float - isto é, um número real -

1233
00: 56: 55,920 -> 00: 56: 57.350
você vai usar o %f.

1234
00: 56: 57,350 -> 00: 57: 00.390
E há alguns outros códigos de formatação também.

1235
00: 57: 00,390 -> 00: 57: 02.430
Mas vimos apenas um deles até agora.

1236
00: 57: 02,430 -> 00: 57: 05.010
E então, em termos de operações aritméticas,

1237
00: 57: 05,010 -> 00: 57: 07.290
você pode fazer muita matemática de forma muito simples.

1238
00: 57: 07,290 -> 00: 57: 09.540
E vamos fazer apenas alguns exemplos, literalmente apenas

1239
00: 57: 09,540 -> 00: 57: 13.320
usando os caracteres que você pode ser tendenciado a digitar na tela.

1240
00: 57: 13,320 -> 00: 57: 18.603
Então, em resumo, suponha que queiramos ir em frente e escrever um programa nosso.

1241
00: 57: 18.603 -> 00: 57: 21.270
Podemos usar qualquer uma dessas funções - get_int e get_float

1242
00: 57: 21,270 -> 00: 57: 22.240
e get_more.

1243
00: 57: 22,240 -> 00: 57: 24.990
Mas antes disso, vamos fazer uma pausa de cinco minutos aqui,

1244
00: 57: 24,990 -> 00: 57: 26.865
porque esta foi uma mangueira de incêndio e tanto.

1245
00: 57: 26,865 -> 00: 57: 30.570
Os biscoitos aguardam no saguão do lado de fora e retomaremos em cinco minutos.

1246
00: 57: 30,570 -> 00: 57: 36.420
Então, estamos de volta, e agora começamos a nos concentrar não apenas em comparações

1247
00: 57: 36,420 -> 00: 57: 39.090
de C com Scratch, mas na verdade escrevendo

1248
00: 57: 39,090 -> 00: 57: 42.960
algum código que veio do Scratch, mas em C. E o objetivo em mãos

1249
00: 57: 42,960 -> 00: 57: 46.050
realmente é começar a desenvolver a memória muscular por meio da qual

1250
00: 57: 46,050 -> 00: 57: 49.860
você pode começar com arquivos literalmente vazios e começar a preenchê-los

1251
00: 57: 49,860 -> 00: 57: 54.090
com implementações C de suas idéias.

1252
00: 57: 54,090 -> 00: 57: 57.660
Portanto, tenha certeza de que todos os exemplos que vamos fazer ao vivo

1253
00: 57: 57,660 -> 00: 57: 59.670
já estão prontos online, então você será

1254
00: 57: 59,670 -> 00: 58: 02.580
capaz de baixar todos esses exemplos do site do curso.

1255
00: 58: 02,580 -> 00: 58: 05.632
Na superseção de Brian, você poderá explorá-los com mais detalhes.

1256
00: 58: 05,632 -> 00: 58: 07.590
E ainda esta semana você terá oportunidades

1257
00: 58: 07,590 -> 00: 58: 11.020
de trabalhar na prática nesses mesmos tipos de programas também.

1258
00: 58: 11,020 -> 00: 58: 16.140
Por enquanto, o objetivo geral é exposição e conceitos e o início

1259
00: 58: 16,140 -> 00: 58: 18.270
de desenvolver essa memória muscular.

1260
00: 58: 18,270 -> 00: 58: 21.947
Com isso dito, deixe-me continuar e criar um novo arquivo chamado int.c,

1261
00: 58: 21,947 -> 00: 58: 24.780
o objetivo do qual será obter um número inteiro do usuário,

1262
00: 58: 24,780 -> 00: 58: 28.530
muito parecido com o de agora pouco, Eu recebi uma string do usuário.

1263
00: 58: 28,530 -> 00: 58: 30.630
Eu vou seguir, como antes, estou

1264
00: 58: 30,630 -> 00: 58: 32.410
incluindo alguns arquivos familiares.

1265
00: 58: 32,410 -> 00: 58: 35.012
Então, vou prosseguir e incluir preventivamente CS50.h

1266
00: 58: 35,012 -> 00: 58: 37.830
para que eu tenha acesso a strings e get_string

1267
00: 58: 37,830 -> 00: 58: 40.800
e get_int e get_float e outros recursos também.

1268
00: 58: 40,800 -> 00: 58: 43.890
Vou incluir stdio.h para ter acesso ao printf

1269
00: 58: 43,890 -> 00: 58: 45.780
para que eu possa realmente ver o que estamos fazendo.

1270
00: 58: 45,780 -> 00: 58: 48.600
Então vou fazer isso, que novamente, para os propósitos de hoje

1271
00: 58: 48,600 -> 00: 58: 51.150
e por algumas semanas, será apenas meio que copiar / colar.

1272
00: 58: 51,150 -> 00: 58: 54.090
Isso é o equivalente a quando a bandeira verde é clicada,

1273
00: 58: 54,090 -> 00: 58: 57.240
mas vamos explicar, em algumas semanas, exatamente por que você está escrevendo int

1274
00: 58: 57,240 -> 00: 58: 59.235
e porque você está escrevendo vazio.

1275
00: 58: 59,235 -> 00: 59: 01.110
Aqui, vou fazer algo assim.

1276
00: 59: 01,110 -> 00: 59: 03.360
Desta vez, não quero uma string, mas um int.

1277
00: 59: 03,360 -> 00: 59: 08.320
Então vamos começar get_int, qual é a sua idade?

1278
00: 59: 08,320 -> 00: 59: 10.860
Agora, para ser justo, provavelmente posso digitar muito rapidamente,

1279
00: 59: 10.860 -> 00: 59: 13.650
porque já tenho a memória muscular para programar em C.

1280
00: 59: 13,650 -> 00: 59: 16.150
Mas se olharmos para isso metodicamente por um momento,

1281
00: 59: 16,150 -> 00: 59: 19.540
esta é apenas outra função, get_int, da biblioteca CS50 que é

1282
00: 59: 19,540 -> 00: 59: 20.800
obter um número inteiro.

1283
00: 59: 20,800 -> 00: 59: 22.550
Este é o prompt que o humano está indo

1284
00: 59: 22,550 -> 00: 59: 25.862
para ver com o cursor se movendo para uma nova linha por causa da barra invertida n.

1285
00: 59: 25,862 -> 00: 59: 27.570
E não importa o que eles digitarem será

1286
00: 59: 27,570 -> 00: 59: 31.350
copiado da direita para a esquerda em uma variável chamada idade, cujo tipo,

1287
00: 59: 31,350 -> 00: 59: 34.140
por assim dizer, é int ou inteiro.

1288
00: 59: 34,140 -> 00: 59: 37.717
Agora deixe-me ir em frente e calcular, tipo, quantos dias de vida essa pessoa tem.

1289
00: 59: 37,717 -> 00: 59: 40.050
Então, se eu quiser fazer isso, posso fazer algo assim.

1290
00: 59: 40,050 -> 00: 59: 41.490
Bem, dê-me um número inteiro.

1291
00: 59: 41,490 -> 00: 59: 42.780
Chame isso de dias.

1292
00: 59: 42,780 -> 00: 59: 45.602
E então faça a idade vezes 365.

1293
00: 59: 45,602 -> 00: 59: 47.310
Eu propus agora a pouco que há um monte

1294
00: 59: 47,310 -> 00: 59: 49.830
de operadores aritméticos como mais e menos

1295
00: 59: 49,830 -> 00: 59: 53.850
e multiplicação e subtração e até mesmo o operador de resto.

1296
00: 59: 53,850 -> 00: 59: 58.680
Portanto, esta linha, 7, diz apenas multiplicar a idade por 365.

1297
00: 59: 58,680 -> 01: 00: 02.800
Copie esse valor, da direita para a esquerda, em uma nova variável chamada dias.

1298
01: 00: 02.800 -> 01: 00: 04.800
E agora posso ir em frente e imprimir isso, se quiser.

1299
01: 00: 04,800 -> 01: 00: 09.090
Então printf algo como, você tem pelo menos percentual -

1300
01: 00: 09,090 -> 01: 00: 13.620
não com "s", porque não é uma string, mas percentual i porque é um inteiro agora -

1301
01: 00: 13,620 -> 01: 00: 15.900
dias de vida, barra invertida n.

1302
01: 00: 15.900 -> 01: 00: 18.190
Mas, novamente, este é um "placeholder", então ainda não terminei.

1303
01: 00: 18,190 -> 01: 00: 23.580
O que devo colocar dentro desses parênteses também na linha 8?

1304
01: 00: 23.580 -> 01: 00: 27.990
Sim, então vírgula, dias, se esse for o valor que eu quero exibir.

1305
01: 00: 27,990 -> 01: 00: 29.377
E estou esquecendo mais uma coisa.

1306
01: 00: 29,377 -> 01: 00: 30.210
PÚBLICO: Ponto e vírgula.

1307
01: 00: 30.210 -> 01: 00: 32.127
DAVID MALAN: Ponto e vírgula no final da linha.

1308
01: 00: 32,127 -> 01: 00: 33.503
Agora, espero, está tudo feito direito.

1309
01: 00: 33,503 -> 01: 00: 35.670
Mas as chances de é a primeira vez que você escreve seus programas,

1310
01: 00: 35.670 -> 01: 00: 37.150
aparecerem mensagens de erro.

1311
01: 00: 37,150 -> 01: 00: 41.040
Mas vamos ver, "make int" é a maneira mais rápida agora de compilar este código.

1312
01: 00: 41,040 -> 01: 00: 41.850
Enter.

1313
01: 00: 41,850 -> 01: 00: 43.860
Tudo bem, o grande e longo comando branco está OK.

1314
01: 00: 43,860 -> 01: 00: 47.490
Contanto que você não veja uma saída vermelha, amarela ou colorida que indique

1315
01: 00: 47,490 -> 01: 00: 49.590
avisos ou erros, você deverá estar indo bem.

1316
01: 00: 49.590 -> 01: 00: 53.910
Vou limpar minha tela agora para executar este programa, ./int.

1317
01: 00: 53.910 -> 01: 00: 56.150
E suponha que sua idade seja, digamos, 50.

1318
01: 00: 56,150 -> 01: 01: 00.422
Bem, você tem pelo menos 18.250 dias de vida.

1319
01: 01: 00,422 -> 01: 01: 03.630
Mas deixe-me usar isso como uma oportunidade não apenas de fazer algo correto, que

1320
01: 01: 03,630 -> 01: 01: 06.690
Eu afirmo que este código é, mas apenas para torná-lo melhor projetado.

1321
01: 01: 06,690 -> 01: 01: 11.580
Não há problema em armazenar esse valor, idade, em uma variável chamada idade.

1322
01: 01: 11.580 -> 01: 01: 13.950
E não há problema em criar uma segunda variável chamada

1323
01: 01: 13,950 -> 01: 01: 19.300
dias, em que minha resposta matemática é idade vezes 365.

1324
01: 01: 19,300 -> 01: 01: 22.530
Mas, estritamente falando, não preciso dessa linha de código adicional.

1325
01: 01: 22.530 -> 01: 01: 26.520
Eu também poderia fazer a idade vezes 365 aqui.

1326
01: 01: 26.520 -> 01: 01: 27.660
Então C é legal assim.

1327
01: 01: 27,660 -> 01: 01: 32.370
Você pode compor, assim como no Scratch, ideias maiores a partir de múltiplas ideias menores

1328
01: 01: 32.370 -> 01: 01: 33.090
peças.

1329
01: 01: 33.090 -> 01: 01: 35.550
E, francamente, se eu realmente quero ficar louco,

1330
01: 01: 35.550 -> 01: 01: 38.040
observe que posso destacar toda a função

1331
01: 01: 38.040 -> 01: 01: 42.000
chamar, por assim dizer, livrar-se da idade todos juntos,

1332
01: 01: 42.000 -> 01: 01: 49.330
e basta conectar aqui vezes 365.

1333
01: 01: 49,330 -> 01: 01: 53.190
Mas neste ponto, estamos começando a cruzar um ponto de inflexão.

1334
01: 01: 53,190 -> 01: 01: 55.342
Sim, isso é correto, porque eu, estritamente falando,

1335
01: 01: 55,342 -> 01: 01: 56.550
não precisa de uma variável, certo?
1336
01: 01: 56.550 -> 01: 01: 58.020
Eu posso passar - vimos semana passada -

1337
01: 01: 58,020 -> 01: 02: 00.870
saída de uma função como entrada de outra função

1338
01: 02: 00,870 -> 01: 02: 02.540
simplesmente aninhando-os dessa maneira.

1339
01: 02: 02.540 -> 01: 02: 05.040
Mas, honestamente, agora estamos no ponto em que esta linha de código

1340
01: 02: 05.040 -> 01: 02: 08.080
é relativamente longa, é muito difícil de ler.

1341
01: 02: 08.080 -> 01: 02: 10.830
E então este é um exemplo onde, pelo bem do design, sabe de uma coisa?

1342
01: 02: 10.830 -> 01: 02: 13.210
A versão anterior provavelmente era um pouco melhor,

1343
01: 02: 13,210 -> 01: 02: 16.950
porque posso ler o código mais de cima para baixo do que da esquerda para a direita.

1344
01: 02: 16.950 -> 01: 02: 18.900
Mas esta é uma decisão de design.
1345
01: 02: 18.900 -> 01: 02: 21.000
E, de fato, você pode concordar ou discordar.

1346
01: 02: 21.000 -> 01: 02: 24.420
Você pode concordar ou discordar de seu professor, ou TF, em última instância.

1347
01: 02: 24.420 -> 01: 02: 28.770
Esses são os tipos de decisões que envolvem a escrita de códigos bons ou ruins

1348
01: 02: 28.770 -> 01: 02: 30.300
ou código bom ou melhor.

1349
01: 02: 30,300 -> 01: 02: 33.000
Muito parecido com uma redação de inglês ou em qualquer idioma escrito,

1350
01: 02: 33.000 -> 01: 02: 36.030
você poderia discutir que uma pessoa escreveu seu documento melhor

1351
01: 02: 36.030 -> 01: 02: 36.730
do que outro.

1352
01: 02: 36.730 -> 01: 02: 40.140
Portanto, começaremos a apreciar essas nuancias com o tempo.

1353
01: 02: 40,140 -> 01: 02: 41.310
Que tal o float?

1354
01: 02: 41,310 -> 01: 02: 45.758
Bem, deixe-me prosseguir e escrever outro programa bem rápido chamado float.c.

1355
01: 02: 45,758 -> 01: 02: 47.550
E este vai usar ponto flutuante

1356
01: 02: 47.550 -> 01: 02: 50.800
valores, que novamente, são apenas sinônimos de números reais com pontos decimais.

1357
01: 02: 50.800 -> 01: 02: 54.150
Deixe-me ir em frente e incluir CS50.h, incluir stdio.h.

1358
01: 02: 54,150 -> 01: 02: 57.840


1359
01: 02: 57.840 -> 01: 03: 02.003
E então int main void e então minhas chaves abertas.

1360
01: 03: 02.003 -> 01: 03: 02.920
E agora vamos fazer isso.

1361
01: 03: 02,920 -> 01: 03: 04.680
Deixe-me ver o preço de alguma coisa.

1362
01: 03: 04,680 -> 01: 03: 10.290
Então, "int price" é igual a get_float, qual é o preço, por exemplo.

1363
01: 03: 10.290 -> 01: 03: 11.450
Ponto e vírgula.

1364
01: 03: 11.450 -> 01: 03: 13.660
E agora deixe-me fazer algo matemático com isso.

1365
01: 03: 13.660 -> 01: 03: 18.120
Deixe-me ir em frente e dizer, seu total é.

1366
01: 03: 18,120 -> 01: 03: 21.330
E agora deixe-me fazer o preço total com imposto, por exemplo.

1367
01: 03: 21,330 -> 01: 03: 24.353
Em Massachusetts, o imposto sobre vendas é de 6,25%.

1368
01: 03: 24,353 -> 01: 03: 26.520
Então, vamos escrever um pequeno programa que faça isso.

1369
01: 03: 26.520 -> 01: 03: 30.540
Seu total é-- não o "%s", porque não é uma string.

1370
01: 03: 30.540 -> 01: 03: 33.190
Não o percentual i, porque não é um número inteiro.

1371
01: 03: 33,190 -> 01: 03: 37.990
Deve ser %f para float.
1372
01: 03: 37,990 -> 01: 03: 39.350
E, de fato, eu me enganei.

1373
01: 03: 39,350 -> 01: 03: 41.860
Na verdade, cometi um erro aqui acidentalmente.

1374
01: 03: 41,860 -> 01: 03: 44.997
Não quero armazenar o preço em um int se estou entendendo como um float.

1375
01: 03: 44,997 -> 01: 03: 47.080
Se estou obtendo um número real com um ponto decimal,

1376
01: 03: 47.080 -> 01: 03: 49.310
Provavelmente quero armazená-lo como um float também.

1377
01: 03: 49,310 -> 01: 03: 52.480
Então, novamente, códigos de formato diferentes, "placeholders" diferentes

1378
01: 03: 52.480 -> 01: 03: 53.787
para contextos diferentes.

1379
01: 03: 53.787 -> 01: 03: 55.120
Agora, deixe-me ir em frente e fazer isso.
1380
01: 03: 55,120 -> 01: 03: 56.995
E se eu quiser adicionar o preço, vou

1381
01: 03: 56,995 -> 01: 04: 05.230
fazer o preço vezes 1,0625, o que significa apenas matematicamente adicionar 106,25% -

1382
01: 04: 05,230 -> 01: 04: 08.770
ou multiplicar, em vez disso, o preço por 106,25%

1383
01: 04: 08,770 -> 01: 04: 11.203
para que você realmente veja o total com impostos.

1384
01: 04: 11.203 -> 01: 04: 13.120
Tudo bem, então vamos compilar isso.

1385
01: 04: 13,120 -> 01: 04: 14.980
"make float", Enter.

1386
01: 04: 14.980 -> 01: 04: 17.320
Sem mensagens de erro, isso já é promissor.

1387
01: 04: 17.320 -> 01: 04: 18.730
./float.

1388
01: 04: 18,730 -> 01: 04: 19.990
E qual é o preço?
1389
01: 04: 19.990 -> 01: 04: 23.170
Que tal $ 100.

1390
01: 04: 23,170 -> 01: 04: 25.180
OK, isso é um pouco excessivamente preciso.

1391
01: 04: 25,180 -> 01: 04: 29.932
O preço total é $ 106,250000.

1392
01: 04: 29.932 -> 01: 04: 33.130
Mas isso é só porque o computador, de acordo com a semana passada,

1393
01: 04: 33,130 -> 01: 04: 35.440
está usando um certo número de bits para armazenar valores.

1394
01: 04: 35.440 -> 01: 04: 40.120
E o computador passa a ser capaz de mostrar todos esses dígitos

1395
01: 04: 40,120 -> 01: 04: 41.140
após o ponto decimal.

1396
01: 04: 41,140 -> 01: 04: 42.830
Mas e se você não quiser fazer isso?

1397
01: 04: 42.830 -> 01: 04: 46.660
Bem, acontece que existem alguns truques bastante misteriosos que você pode fazer.

1398
01: 04: 46.660 -> 01: 04: 48.910
Em vez de fazer "%f", posso realmente

1399
01:04:48,910 --> 01:04:52,360
fazer %2f, o qual novamente, você poderia somente

1400
01: 04: 52,360 -> 01: 04: 55.570
saber por ter ouvido antes, procurando em um livro ou referência.

1401
01: 04: 55.570 -> 01: 04: 59.150
Isso vai me mostrar apenas dois dígitos após a vírgula decimal.

1402
01: 04: 59,150 -> 01: 05: 02.560
Então, se eu recompilar este código e "make float" e fazer ./float,

1403
01: 05: 02.560 -> 01: 05: 07.720
agora observe se o preço é $ 100, agora meu total é um pouco mais amigável -

1404
01: 05: 07,720 -> 01: 05: 09.790
106,25.

1405
01: 05: 09,790 -> 01: 05: 11.953
Resumindo, este é o f em printf.

1406
01: 05: 11.953 -> 01: 05: 13.870
Assim como você pode imprimir algo na tela,

1407
01: 05: 13.870 -> 01: 05: 19.380
você pode formatá-lo dizendo a printf para mostrar apenas alguns dígitos.

1408
01: 05: 19,380 -> 01: 05: 20.810
Bem, deixe-me tentar outra coisa.

1409
01: 05: 20.810 -> 01: 05: 23.470
Vou copiar / colar o início deste código,

1410
01: 05: 23.470 -> 01: 05: 24.940
apenas para acelerar as coisas.

1411
01: 05: 24.940 -> 01: 05: 27.190
Portanto, posso implementar um programa chamado parity.c.

1412
01: 05: 27,190 -> 01: 05: 30.343
Portanto, paridade é uma maneira elegante de dizer que é um valor par ou ímpar.

1413
01: 05: 30,343 -> 01: 05: 32.260
E eu fui em frente e apenas copiei e colei

1414
01: 05: 32,260 -> 01: 05: 35.708
a configuração do código, não a essência da minha função principal.

1415
01: 05: 35.708 -> 01: 05: 38.500
Mas vamos prosseguir, neste programa, e pedir ao usuário um número.

1416
01: 05: 38,500 -> 01: 05: 39.540
Vamos chamá-lo de n.

1417
01: 05: 39.540 -> 01: 05: 41.620
E usaremos get_int para obter esse valor.

1418
01: 05: 41.620 -> 01: 05: 44.620
E vamos apenas dizer ao humano, qual é o valor de n?

1419
01: 05: 44.620 -> 01: 05: 49.540
E vou apenas dizer n espaço-dois-pontos apenas para solicitar algum número inteiro.

1420
01: 05: 49.540 -> 01: 05: 51.460
Então, vou fazer uma pergunta.

1421
01: 05: 51.460 -> 01: 05: 55.570
Quero, em última análise, quero imprimir par se o número for par ou ímpar

1422
01: 05: 55.570 -> 01: 05: 56.830
se o número for ímpar.

1423
01: 05: 56.830 -> 01: 06: 02.650
Então você pode imaginar fazer isso de uma maneira muito tediosa, como se n for igual a 1,

1424
01: 06: 02,650 -> 01: 06: 06.130
Eu poderia ir em frente e imprimir impar.

1425
01: 06: 06,130 -> 01: 06: 12.340
E então, se n for igual a 2, eu poderia imprimir par.

1426
01: 06: 12,340 -> 01: 06: 16.190
E depois disso, eu poderia dar suporte ao número três, senão se n--

1427
01: 06: 16,190 -> 01: 06: 17.440
Quer dizer, isso é estúpido, certo?

1428
01: 06: 17.440 -> 01: 06: 18.880
Eu poderia fazer isso para sempre.

1429
01: 06: 18,880 -> 01: 06: 21.632
Mas está pelo menos mostrando um padrão, certo?

1430
01: 06: 21,632 -> 01: 06: 24.340
Um e depois três e depois cinco, é claro, vão ser impares,

1431
01: 06: 24,340 -> 01: 06: 26.990
e dois e quatro e seis vão ser pares, e assim por diante.

1432
01: 06: 26,990 -> 01: 06: 29.240
Bem, acontece que podemos calcular isso matematicamente.

1433
01: 06: 29.240 -> 01: 06: 30.970
E um truque muito comum pode ser este -

1434
01: 06: 30.970 -> 01: 06: 32.500
podemos realmente fazer isso.

1435
01: 06: 32,500 -> 01: 06: 39.070
Se n dividido por 2 tem um resto de, por exemplo, 0,

1436
01: 06: 39,070 -> 01: 06: 42.850
então, prosseguirei e concluirei que o número é par.

1437
01: 06: 42.850 -> 01: 06: 45.430
Portanto, este sinal de porcentagem é uma construção nova.

1438
01: 06: 45,430 -> 01: 06: 46.090
Não é positivo.

1439
01: 06: 46.090 -> 01: 06: 47.440
Não é menos.

1440
01: 06: 47.440 -> 01: 06: 49.240
Não é multiplicação ou divisão.

1441
01: 06: 49,240 -> 01: 06: 53.150
Esta é a operação de resto, ou a operação de módulo, por assim dizer.

1442
01: 06: 53,150 -> 01: 06: 59.470
E isso significa apenas dividir n por 2, e se a resposta tiver um resto de 0,

1443
01: 06: 59.470 -> 01: 07: 02.670
você pode concluir, por definição de par, que o número é par.

1444
01: 07: 02,670 -> 01: 07: 04.100
Vou imprimir isso.

1445
01: 07: 04,100 -> 01: 07: 08.320
Senão - eu poderia fazer outra coisa se n por cento 2 for igual a 1

1446
01: 07: 08,320 -> 01: 07: 11.380
e tem um resto de 1, você pode imaginar dizendo impar.

1447
01: 07: 11,380 -> 01: 07: 15.405
Mas, como você observou anteriormente, isso não é necessário.

1448
01: 07: 15.405 -> 01: 07: 18.280
O que eu poderia fazer para tornar o programa um pouco melhor projetado,
1449
01: 07: 18,280 -> 01: 07: 19.600
um pouco mais eficiente?

1450
01: 07: 19.600 -> 01: 07: 20.248
Sim?

1451
01: 07: 20,248 -> 01: 07: 22.440
PÚBLICO: Você poderia apenas usar o else e isso seria ótimo.

1452
01: 07: 22,440 -> 01: 07: 22.770
DAVID MALAN: Sim.

1453
01: 07: 22,770 -> 01: 07: 24.687
Então, se estamos falando de inteiros, posso apenas

1454
01: 07: 24.687 -> 01: 07: 28.360
concluir, bem, se não for par, deve ser impar, por definição.

1455
01: 07: 28,360 -> 01: 07: 30.510
E aqui, podemos apenas fazer pares e ímpares.

1456
01: 07: 30.510 -> 01: 07: 33.510
Portanto, este programa, uma vez executado, terá esta aparência.

1457
01: 07: 33.510 -> 01: 07: 35.400
"make parity"

1458
01: 07: 35.400 -> 01: 07: 36.630
Parece que compilou bem.

1459
01: 07: 36.630 -> 01: 07: 38.880
Então ./paridade é como eu o executo.

1460
01: 07: 38,880 -> 01: 07: 40.290
Vamos digitar o número 50.

1461
01: 07: 40.290 -> 01: 07: 40.950
Isso mesmo.

1462
01: 07: 40,950 -> 01: 07: 42.510
Vamos digitar o número 49.

1463
01: 07: 42,510 -> 01: 07: 43.380
este é impar.

1464
01: 07: 43,380 -> 01: 07: 44.850
Prova por exemplo.

1465
01: 07: 44,850 -> 01: 07: 48.060
Isso não é muito convincente, mas aposto que vai ser correto, apenas

1466
01: 07: 48.060 -> 01: 07: 49.480
com base apenas nesses dois exemplos.

1467
01: 07: 49.480 -> 01: 07: 49.980
Sim?

1468
01: 07: 49,980 -> 01: 07: 52.938
PÚBLICO: [INAUDÍVEL] o usuário não entendeu nosso comentário que respondeu

1469
01: 07: 52,938 -> 01: 07: 54.332
um float ou não um inteiro?

1470
01: 07: 54,332 -> 01: 07: 55.790
DAVID MALAN: Desculpe, diga isso de novo?

1471
01: 07: 55,790 -> 01: 07: 58.207
PÚBLICO: E se o usuário não entender, estou dizendo?

1472
01: 07: 58,207 -> 01: 08: 02.783
Tipo, eu faço algo como 1.5 [INAUDÍVEL] ..

1473
01: 08: 02,783 -> 01: 08: 04.200
DAVID MALAN: Boa pergunta.

1474
01: 08: 04,200 -> 01: 08: 06.950
Uma das razões que fornecemos nas primeiras semanas de aula

1475
01: 08: 06,950 -> 01: 08: 10.700
algumas funções na biblioteca CS50 como get_string e get_int e get_float

1476
01: 08: 10.700 -> 01: 08: 14.960
é que força o usuário a se comportar como você espera, para seu programa não

1477
01: 08: 14.960 -> 01: 08: 17.149
travar devido a entrada inesperada do usuário.

1478
01: 08: 17,149 -> 01: 08: 20.180
Então, para seu ponto, suponha que o usuário esteja sendo um pouco difícil e diga:

1479
01: 08: 20,180 -> 01: 08: 22.939
meu número será 1,5.

1480
01: 08: 22.939 -> 01: 08: 27.854
Get_int irá solicitar a mesma pergunta repetidas vezes

1481
01: 08: 27.854 -> 01: 08: 28.729
até que eles cooperem.

1482
01: 08: 28,729 -> 01: 08: 31.819
Se você digitar "maça", será exibido novamente.

1483
01: 08: 31.819 -> 01: 08: 34.880
Somente depois de fornecer um número inteiro real ele cooperará.

1484
01: 08: 34.880 -> 01: 08: 37.540
Portanto, esses estão entre os recursos que você obtém da biblioteca CS50,

1485
01: 08: 37.540 -> 01: 08: 39.410
apenas para que possamos nos concentrar em ideias e não

1486
01: 08: 39.410 -> 01: 08: 44.270
no que chamaríamos de verificação de erros, ou usuários mal-intencionados, neste caso.

1487
01: 08: 44.270 -> 01: 08: 46.670
Tudo bem, então o que mais podemos fazer uma vez que

1488
01: 08: 46.670 -> 01: 08: 49.279
temos a capacidade de expressar condições?

1489
01: 08: 49,279 -> 01: 08: 52.010
Bem, deixe-me ir em frente e abrir um que trouxe comigo.

1490
01: 08: 52.010 -> 01: 08: 54.109
Então, em vez de digitar tudo do zero,

1491
01: 08: 54,109 -> 01: 08: 56.618
deixe-me ir em frente e abrir as conditions1.c.

1492
01: 08: 56.618 -> 01: 08: 58.660
Portanto, este é um programa que já foi escrito.

1493
01: 08: 58.660 -> 01: 09: 00.920
E acontece que tem algumas outras linhas,

1494
01: 09: 00,920 -> 01: 09: 03.643
esses contornos acinzentados que começam com barra barra.

1495
01: 09: 03.643 -> 01: 09: 05.810
Você pode não ter notado isso, mas no Scratch, você

1496
01: 09: 05,810 -> 01: 09: 06.979
pode ter o que se chama de comentários.

1497
01: 09: 06,979 -> 01: 09: 09.050
Eles são como pequenas notas adesivas que você pode adicionar

1498
01: 09: 09,050 -> 01: 09: 10.550
que não fazem nada funcionalmente.

1499
01: 09: 10.550 -> 01: 09: 13.825
É como notas para você mesmo ou para seu amigo ou notas para o seu TF.

1500
01: 09: 13.825 -> 01: 09: 15.950
Isso é o que um comentário é em uma linguagem de programação.

1501
01: 09: 15.950 -> 01: 09: 19.310
Portanto, qualquer coisa que comece com uma barra é uma nota para mim.

1502
01: 09: 19,310 -> 01: 09: 21.873
E é um lembrete para mim do que essa linha de código faz.

1503
01: 09: 21,873 -> 01: 09: 24.040
É um lembrete para seus colegas do mundo real

1504
01: 09: 24,040 -> 01: 09: 27.380
ou seu TF em uma aula para explicar a eles o que esta linha de código

1505
01: 09: 27,380 -> 01: 09: 30.520
deveria estar fazendo, mesmo que você tenha um bug

1506
01: 09: 30.520 -> 01: 09: 32.090
e não está realmente fazendo isso.

1507
01: 09: 32.090 -> 01: 09: 35.840
Então, comecei, nestes exemplos pré-criados, a comentar meu código,

1508
01: 09: 35.840 -> 01: 09: 37.580
mas as linhas são essencialmente as mesmas.

1509
01: 09: 37.580 -> 01: 09: 40.250
Vá em frente e me dê acesso à biblioteca CS50.

1510
01: 09: 40,250 -> 01: 09: 43.010
E uma biblioteca, novamente, é apenas um arquivo de código

1511
01: 09: 43.010 -> 01: 09: 45.080
que outra pessoa escreveu que estamos usando.

1512
01: 09: 45,080 -> 01: 09: 47.960
E me dê acesso à biblioteca padrão de I/O, que contém

1513
01: 09: 47,960 -> 01: 09: 50.430
printf e algumas outras coisas também.

1514
01: 09: 50.430 -> 01: 09: 54.170
Observe aqui, eu tenho x igual a get_int com o objetivo de

1515
01: 09: 54,170 -> 01: 09: 56.390
obter um inteiro do usuário chamado x.

1516
01: 09: 56,390 -> 01: 09: 59.840
Agora vou pedir um segundo inteiro apenas chamando de y

1517
01: 09: 59.840 -> 01: 10: 01.400
e chamando get_int novamente.

1518
01: 10: 01.400 -> 01: 10: 03.840
E agora posso fazer coisas como comparar esses valores.

1519
01: 10: 03.840 -> 01: 10: 07.790
Portanto, esta é agora uma versão completa do programa tipo Scratch

1520
01: 10: 07,790 -> 01: 10: 11.450
Eu puxei antes que nos permite concluir que é x menor do que y,

1521
01: 10: 11.450 -> 01: 10: 15.290
maior que y, ou, por padrão, igual a y.

1522
01: 10: 15,290 -> 01: 10: 19.080
Portanto, a única diferença é que vimos essas linhas de código na tela antes.

1523
01: 10: 19.080 -> 01: 10: 22.340
Agora vemos, no contexto, que, para essas linhas funcionarem,

1524
01: 10: 22,340 -> 01: 10: 25.640
precisamos obter os inteiros do usuário.

1525
01: 10: 25.640 -> 01: 10: 28.520
E precisamos ter o equivalente a quando a bandeira verde é clicada,

1526
01: 10: 28.520 -> 01: 10: 31.115
e precisamos do equivalente a estes includes para que seja

1527
01: 10: 31,115 -> 01: 10: 33.575
um programa completo e independente.

1528
01: 10: 33.575 -> 01: 10: 35.450
E só para ficar claro, embora eu tenha feito isso

1529
01: 10: 35.450 -> 01: 10: 38.710
antecipadamente, se eu quisesse executar este programa, como poderia executá-lo?

1530
01: 10: 38,710 -> 01: 10: 41.770
Chame coditions.c

1531
01: 10: 41.770 -> 01: 10: 45.030
Sim, então estabeleça as condições primeiro.

1532
01: 10: 45.030 -> 01: 10: 45.530
Desculpe.

1533
01: 10: 45.530 -> 01: 10: 48.140
Oh, este é realmente um momento para se ensinar.

1534
01: 10: 48,140 -> 01: 10: 49.670
Por que isso não funcionou?

1535
01: 10: 49.670 -> 01: 10: 54.020
Portanto, nenhuma regra para impedir as condições-alvo, o que é um pouco enfático.

1536
01: 10: 54.020 -> 01: 10: 55.130
Mas o que isso significa?

1537
01: 10: 55,130 -> 01: 10: 58.700
Bem, antecipadamente hoje, o que eu fiz foi baixar para o meu sandbox

1538
01: 10: 58,700 -> 01: 11: 02.630
uma pasta chamada src1, S-R-C que significa "fonte" na linguagem do programador.
1539
01: 11: 02.630 -> 01: 11: 06.140
E acabei de baixar na sandbox para mim.

1540
01: 11: 06,140 -> 01: 11: 08.540
Porque nessa pasta estão todos os exemplos

1541
01: 11: 08.540 -> 01: 11: 12.050
não só que escrevi ao vivo, mas também algumas outras que trouxe comigo.

1542
01: 11: 12.050 -> 01: 11: 15.920
Infelizmente, todos esses arquivos estão em uma pasta chamada src1.

1543
01: 11: 15.920 -> 01: 11: 18.920
Agora, no seu Mac ou PC, se você quiser abrir uma pasta, faça o que eu fiz.

1544
01: 11: 18,920 -> 01: 11: 22.100
Você duplica o ícone e bum, a pasta está aberta.

1545
01: 11: 22,100 -> 01: 11: 25.880
Mas em uma janela de terminal, um ambiente baseado em texto, você não pode fazer isso.

1546
01: 11: 25,880 -> 01: 11: 29.840
Se eu digitar ls, veremos todos os arquivos que criei hoje -

1547
01: 11: 29.840 -> 01: 11: 32.120
float e hello e int.

1548
01: 11: 32,120 -> 01: 11: 34.520
Mas observe aqui, há uma pasta.

1549
01: 11: 34.520 -> 01: 11: 36.145
E é isso que a barra final é.

1550
01: 11: 36,145 -> 01: 11: 38.270
Essa é uma barra que significa, ei, humano,

1551
01: 11: 38,270 -> 01: 11: 40.250
esta é uma pasta, então é óbvio.

1552
01: 11: 40,250 -> 01: 11: 44.150
Assim como o asterisco significa que aqui está um código de máquina que você pode executar.

1553
01: 11: 44,150 -> 01: 11: 47.270
Preciso mudar para esse diretório, mas não consigo clicar duas vezes.

1554
01: 11: 47,270 -> 01: 11: 49.700
Nada vai acontecer se eu clicar duas vezes neste texto.

1555
01: 11: 49,700 -> 01: 11: 53.650
Mas posso digitar cd space src1.

1556
01: 11: 53.650 -> 01: 11: 55.760
cd significa mudança de diretório.

1557
01: 11: 55,760 -> 01: 11: 57.200
E agora eu pressiono Enter.

1558
01: 11: 57,200 -> 01: 11: 59.990
E agora, se eu clicar em ls, percebo que vejo ainda mais arquivos,

1559
01: 11: 59,990 -> 01: 12: 03.110
porque esses são todos os arquivos do site do curso

1560
01: 12: 03,110 -> 01: 12: 05.180
que eu trouxe comigo hoje.

1561
01: 12: 05,180 -> 01: 12: 08.037
E se você digitar um comando como este, pwd,

1562
01: 12: 08,037 -> 01: 12: 10.370
isso revelará ainda mais informações sobre o sistema,

1563
01: 12: 10,370 -> 01: 12: 12.050
mas mais sobre isso nas próximas semanas.

1564
01: 12: 12.050 -> 01: 12: 16.160
Na verdade, você está dentro de uma pasta src1 que está dentro de uma pasta sandbox

1565
01: 12: 16,160 -> 01: 12: 17.840
que está dentro de uma pasta raiz.

1566
01: 12: 17.840 -> 01: 12: 21.140
Agora, as chances são de que, em algum ponto, você ficará confuso sobre onde está.

1567
01: 12: 21,140 -> 01: 12: 23.150
Em caso de dúvida, basta digitar cd.

1568
01: 12: 23,150 -> 01: 12: 25.950
Isso o levará para a pasta padrão onde você começou,

1569
01: 12: 25.950 -> 01: 12: 28.430
não importa onde você se encontre.

1570
01: 12: 28.430 -> 01: 12: 30.470
Digite ls e você estará de volta ao início.

1571
01: 12: 30.470 -> 01: 12: 32.570
Então, em caso de dúvida, basta digitar cd e Enter,

1572
01: 12: 32.570 -> 01: 12: 34.430
e você estará de volta ao início.

1573
01: 12: 34.430 -> 01: 12: 37.610
Bem, deixe-me ir em frente e abrir este programa, mas execute este primeiro.

1574
01: 12: 37.610 -> 01: 12: 40.190
Vou entrar em um programa chamado agree.c.

1575
01: 12: 40,190 -> 01: 12: 44.520
Vou ocultar o código por um momento e chamar agree.

1576
01: 12: 44.520 -> 01: 12: 47.360
Fiz de novo, cd src1, Enter.

1577
01: 12: 47,360 -> 01: 12: 49.800
Agora posso make agree.

1578
01: 12: 49.800 -> 01: 12: 51.500
Parece ter compilado o programa.

1579
01: 12: 51,500 -> 01: 12: 55.700
E se eu fizer ./agree, este programa parece estar me fazendo uma pergunta -

1580
01: 12: 55,700 -> 01: 12: 56.523
você concorda?

1581
01: 12: 56.523 -> 01: 12: 58.940
Agora, não é óbvio no programa o que devo digitar,

1582
01: 12: 58.940 -> 01: 13: 01.220
mas meu instinto me diz, claro, sim.

1583
01: 13: 01,220 -> 01: 13: 04.370
Portanto, vou prosseguir e digitar y para sim e Enter.

1584
01: 13: 04,370 -> 01: 13: 06.050
E parece saber que concordei.

1585
01: 13: 06,050 -> 01: 13: 07.490
Se eu executá-lo novamente -

1586
01: 13: 07.490 -> 01: 13: 11.900
./agree-- e digite n desta vez, não concordado.

1587
01: 13: 11.900 -> 01: 13: 12.650
Mas você sabe o que?

1588
01: 13: 12,650 -> 01: 13: 13.942
Na verdade, é melhor do que isso.

1589
01: 13: 13,942 -> 01: 13: 18.650
Se eu concordar ./agree e talvez digitar um Y maiúsculo, Enter, isso também parece funcionar.

1590
01: 13: 18.650 -> 01: 13: 20.130
Então, como isso está acontecendo?

1591
01: 13: 20,130 -> 01: 13: 21.770
Bem, deixe-me ver o código aqui.

1592
01: 13: 21.770 -> 01: 13: 25.190
O topo do arquivo é quase idêntico a tudo até agora.

1593
01: 13: 25,190 -> 01: 13: 27.650
Inclui esses dois arquivos, int main void.

1594
01: 13: 27,650 -> 01: 13: 30.320
Mas agora estou usando get_char e armazenando minha resposta

1595
01: 13: 30,320 -> 01: 13: 33.710
em uma variável chamada c, mas posso armazená-la em qualquer coisa que eu quiser.

1596
01: 13: 33.710 -> 01: 13: 36.350
E agora observe a sintaxe ligeiramente nova.

1597
01: 13: 36,350 -> 01: 13: 41.300
O que há de novo sobre o que estou fazendo aqui?

1598
01: 13: 41,300 -> 01: 13: 43.910
Que símbolos aparecem?

1599
01: 13: 43.910 -> 01: 13: 45.200
Sim, a barra vertical.

1600
01: 13: 45,200 -> 01: 13: 48.020
Portanto, esta é uma maneira de dizer um ou lógico.

1601
01: 13: 48,020 -> 01: 13: 50.630
Então, em Python e em algumas outras linguagens hoje em dia, você

1602
01: 13: 50,630 -> 01: 13: 52.280
pode escrever literalmente a palavra "or/ou".

1603
01: 13: 52,280 -> 01: 13: 57.500
Isso não funciona em C. Se você quiser fazer esta pergunta ou esta pergunta

1604
01: 13: 57.500 -> 01: 14: 00.740
e aceite qualquer uma das respostas como uma resposta válida,

1605
01: 14: 00,740 -> 01: 14: 03.020
você apenas usa duas barras verticais, que normalmente são

1606
01: 14: 03,020 -> 01: 14: 05.720
acima da tecla Enter em um teclado americano, pelo menos.

1607
01: 14: 05,720 -> 01: 14: 07.760
Portanto, duas barras verticais significam ou.

1608
01: 14: 07,760 -> 01: 14: 10.640
Dois &, ao que parece, significa e.

1609
01: 14: 10.640 -> 01: 14: 13.940
Mas esta é apenas uma maneira de fazer duas perguntas ao mesmo tempo

1610
01: 14: 13,940 -> 01: 14: 16.800
e aceitar qualquer uma das respostas como potencialmente verdadeiras.

1611
01: 14: 16,800 -> 01: 14: 21.650
Portanto, se c for Y maiúsculo ou c for y minúsculo, assuma que o humano concordou.

1612
01: 14: 21.650 -> 01: 14: 26.090
Caso contrário, se c for igual a N maiúsculo ou n minúsculo, assuma que eles não concordaram.

1613
01: 14: 26.090 -> 01: 14: 28.970
E suponha que eu digite alguma outra letra toda junto,

1614
01: 14: 28.970 -> 01: 14: 32.220
o que o programa vai fazer?

1615
01: 14: 32,220 -> 01: 14: 32.720
Repita?

1616
01: 14: 32,720 -> 01: 14: 33.740
PÚBLICO: Perguntar novamente.

1617
01: 14: 33.740 -> 01: 14: 35.000
DAVID MALAN: Não vai me perguntar de novo,

1618
01: 14: 35.000 -> 01: 14: 36.950
porque não há loop aqui, certo?

1619
01: 14: 36.950 -> 01: 14: 41.360
Não há evidência de while ou for aqui.

1620
01: 14: 41,360 -> 01: 14: 46.190
E get_char vai literalmente pegar um char, mas não especifica qual char.

1621
01: 14: 46,190 -> 01: 14: 50.900
O que acontece se eu não digitar y ou n, maiúsculo ou minúsculo?

1622
01: 14: 50,900 -> 01: 14: 52.103
Parece que nada.

1623
01: 14: 52,103 -> 01: 14: 54.020
Nada vai acontecer, e tudo bem.

1624
01: 14: 54,020 -> 01: 14: 56.210
Seu programa não precisa imprimir nada.

1625
01: 14: 56,210 -> 01: 15: 01.060
E, de fato, se eu executar novamente e ./agree x.

1626
01: 15: 01.060 -> 01: 15: 02.130
Não faz nada.

1627
01: 15: 02,130 -> 01: 15: 03.860
Portanto, não concordei nem discordei.

1628
01: 15: 03,860 -> 01: 15: 07.910
No entanto, você pode imaginar escrever um loop que de alguma forma força o humano

1629
01: 15: 07,910 -> 01: 15: 10.117
para cooperar de uma forma ou de outra.

1630
01: 15: 10,117 -> 01: 15: 12.200
Tudo bem, vamos fazer um exemplo diferente, desta vez

1631
01: 15: 12,200 -> 01: 15: 15.800
baseado em uma ideia da última vez - a de abstração.

1632
01: 15: 15,800 -> 01: 15: 18.980
Lembre-se de que no Scratch não havia nenhuma peça do quebra-cabeça para tossir,

1633
01: 15: 18.980 -> 01: 15: 21.620
para fazer o gato [TOSSIR] na tela.

1634
01: 15: 21.620 -> 01: 15: 25.070
E então implementamos isso, realmente, com nossa própria peça de quebra-cabeça personalizada,

1635
01: 15: 25.070 -> 01: 15: 25.850
em última análise.

1636
01: 15: 25.850 -> 01: 15: 30.080
Deixe-me criar um programa chamado cough0.c.

1637
01: 15: 30.080 -> 01: 15: 33.140
Essa é uma definição generosa de inatividade, mas OK.

1638
01: 15: 33,140 -> 01: 15: 35.960
Deixe-me recarregar a tela.

1639
01: 15: 35.960 -> 01: 15: 38.420
Na dúvida, no CS50, como na vida, recarregue.

1640
01: 15: 38.420 -> 01: 15: 39.920
Isso provavelmente vai resolver.

1641
01: 15: 39,920 -> 01: 15: 43.248
Infelizmente, com a programação e a internet, isso às vezes acontece.

1642
01: 15: 43.248 -> 01: 15: 45.290
Então, em um momento, o que vou fazer

1643
01: 15: 45,290 -> 01: 15: 49.730
é traduzir essa ideia do Scratch de implementar a noção de tosse.

1644
01: 15: 49,730 -> 01: 15: 54.060
Mas em vez do bloco de dizer, vou usar o bloco printf ou 

1645
01: 15: 54.060 -> 01: 15: 54.990
a função printf.

1646
01: 15: 54,990 -> 01: 15: 58.700
E então vou prosseguir e projetar esta versão do código ligeiramente

1647
01: 15: 58,700 -> 01: 16: 01.920
cada vez melhor e ligeiramente melhor.

1648
01: 16: 01,920 -> 01: 16: 07.010
Vou prosseguir e abrir um arquivo cough0.c.

1649
01: 16: 07,010 -> 01: 16: 11.900
E vou prosseguir e incluir, digamos, stdio.h.

1650
01: 16: 11.900 -> 01: 16: 16.180
Vou prosseguir e fazer int main void, que, de novo, é apenas o nosso caldeirão

1651
01: 16: 16,180 -> 01: 16: 18.080
de referências ou copiar/colar para hoje.

1652
01: 16: 18.080 -> 01: 16: 21.080
Vou prosseguir, então, e dizer printf, aspas, aspas,

1653
01: 16: 21,080 -> 01: 16: 22.580
tosse e "\n" para uma nova linha.

1654
01: 16: 22.580 -> 01: 16: 25.050
E lembre-se, no Scratch eu queria que isso acontecesse três vezes,

1655
01: 16: 25,050 -> 01: 16: 27.300
então vou fazer assim - tosse, tosse, tosse.

1656
01: 16: 27,300 -> 01: 16: 31.520
Tudo bem, vou me dar uma janela de terminal aqui na parte inferior

1657
01: 16: 31.520 -> 01: 16: 35.330
para que agora eu possa ir em frente e dizer make cough0, Enter.

1658
01: 16: 35,330 -> 01: 16: 39.470
Nada de ruim parece acontecer. ./cough0 e tosse, tosse, tosse.

1659
01: 16: 39.470 -> 01: 16: 42.950
Então, na semana passada, afirmei que, hã, você pode projetar isso melhor, certo?

1660
01: 16: 42.950 -> 01: 16: 44.960
Sempre que você estiver copiando e colando, provávelmente

1661
01: 16: 44,960 -> 01: 16: 46.850
você deve começar a resistir a essa tentação,

1662
01: 16: 46.850 -> 01: 16: 49.933
porque vai levar a um código confuso, um código mais longo do que o necessário.

1663
01: 16: 49,933 -> 01: 16: 52.133
Qual é a solução para esse problema da semana passada?

1664
01: 16: 52,133 -> 01: 16: 52.920
PÚBLICO: Um loop.

1665
01: 16: 52,920 -> 01: 16: 54.390
DAVID MALAN: Sim, um loop, um loop for.

1666
01: 16: 54,390 -> 01: 16: 55.682
Então, deixe-me ir em frente e fazer isso.

1667
01: 16: 55.682 -> 01: 16: 57.693
Deixe-me criar outra versão, cough1.c.

1668
01: 16: 57,693 -> 01: 17: 00.360
E vou copiar/colar este código, apenas como ponto de partida.

1669
01: 17: 00,360 -> 01: 17: 02.400
Mas agora vou limpar tudo.

1670
01: 17: 02.400 -> 01: 17: 04.960
Então, vou prosseguir e, em vez disso, fazer um loop for.

1671
01: 17: 04,960 -> 01: 17: 07.460
E ainda não me lembro bem do que está entre parênteses,

1672
01: 17: 07.460 -> 01: 17: 08.690
mas vamos voltar a isso.

1673
01: 17: 08.690 -> 01: 17: 12.530
Eu sei que o que eu quero fazer algumas vezes é apenas tossir.

1674
01: 17: 12.530 -> 01: 17: 15.333
Portanto, a única coisa em questão é: qual era a sintaxe aqui?

1675
01: 17: 15,333 -> 01: 17: 17.250
Bem, podemos escrever isso de várias maneiras,

1676
01: 17: 17,250 -> 01: 17: 18.890
e poderíamos até usar um loop while.

1677
01: 17: 18,890 -> 01: 17: 22.520
Mas me lembro de dizer int e depois o nome de uma variável.

1678
01: 17: 22.520 -> 01: 17: 24.960
Eu poderia dizer contar, ou poderia apenas dizer

1679
01: 17: 24,960 -> 01: 17: 28.970
i para mantê-lo sucinto, é igual a 0 por padrão.

1680
01: 17: 28.970 -> 01: 17: 32.540
Eu poderia fazer isso desde que i seja menor que 3, por exemplo.

1681
01: 17: 32.540 -> 01: 17: 38.070
E então, em cada iteração, posso dizer que i é igual a i mais 1 ou, mais sucintamente,

1682
01: 17: 38,070 -> 01: 17: 39.710
i mais mais.

1683
01: 17: 39,710 -> 01: 17: 41.223
Portanto, novamente, é uma série de novas sintaxes.

1684
01: 17: 41,223 -> 01: 17: 43.140
E agora há pontos-e-vírgulas por todo o lugar.

1685
01: 17: 43,140 -> 01: 17: 46.700
Mas se eu for em frente e "make cough1",

1686
01: 17: 46,700 -> 01: 17: 48.410
nada de ruim parece ter acontecido.

1687
01: 17: 48.410 -> 01: 17: 51.020
./cough1, tosse, tosse, tosse.

1688
01: 17: 51,020 -> 01: 17: 53.180
Parece ser um pouco melhor projetado.

1689
01: 17: 53,180 -> 01: 17: 55.460
Infelizmente, existe esse paradigma na programação

1690
01: 17: 55.460 -> 01: 18: 00.110
onde humanos, programadores, tendem a pensar ou a contar começando do zero.

1691
01: 18: 00,110 -> 01: 18: 02.240
No entanto, se você não gosta disso, pelo menos no início,

1692
01: 18: 02,240 -> 01: 18: 05.210
não há nada me impedindo de inicializar i com 1

1693
01: 18: 05,210 -> 01: 18: 08.420
e fazer i é menor que 4 ou, ainda mais explicitamente,

1694
01: 18: 08,420 -> 01: 18: 10.655
i é menor ou igual a 3.

1695
01: 18: 10.655 -> 01: 18: 13.280
Não há sinal de menor igual no teclado, normalmente,

1696
01: 18: 13,280 -> 01: 18: 17.390
então você pode imitá-lo fazendo um sinal de menor que e, em seguida, um sinal de igual, dois caracteres.

1697
01: 18: 17,390 -> 01: 18: 18.800
Isso é logicamente o mesmo.

1698
01: 18: 18,800 -> 01: 18: 20.240
Defina i igual a 1.

1699
01: 18: 20.240 -> 01: 18: 23.450
Então vá em frente e imprima a tosse e certifique-se de incrementá-la.

1700
01: 18: 23.450 -> 01: 18: 26.150
E certifique-se de que ainda seja menos de 3 e 2 é.

1701
01: 18: 26,150 -> 01: 18: 28.850
Certifique-se de que ainda é menor ou igual a 3 e ainda é.

1702
01: 18: 28,850 -> 01: 18: 31.620
Portanto, o 2, logicamente, terá o mesmo efeito.

1703
01: 18: 31.620 -> 01: 18: 36.590
No entanto, no interesse da convenção, essa seria a abordagem mais comum.

1704
01: 18: 36.590 -> 01: 18: 42.768
Faça isso enquanto i for igual a 0 e, em seguida, 1 e 2, para um total de 3 vezes.
1705
01: 18: 42,768 -> 01: 18: 44.810
Tudo bem, mas lembre-se do que fizemos da última vez também,

1706
01: 18: 44,810 -> 01: 18: 47.540
é que se eu estou escrevendo muito código, por algum motivo,

1707
01: 18: 47,540 -> 01: 18: 51.800
envolve programas de tosse, seria bom ter a minha própria customização

1708
01: 18: 51,800 -> 01: 18: 52.920
desta função.

1709
01: 18: 52,920 -> 01: 18: 54.450
Então, deixe-me ir em frente e fazer isso.

1710
01: 18: 54.450 -> 01: 18: 58.430
Deixe-me prosseguir e escrever minha primeira função totalmente nova.

1711
01: 18: 58,430 -> 01: 19: 00.570
E vou fazer isso da seguinte maneira.

1712
01: 19: 00,570 -> 01: 19: 04.220
Vou prosseguir e digitar void e, em seguida, o nome da função que desejo.

1713
01: 19: 04,220 -> 01: 19: 07.160
Então vou dizer vazio aqui, por razões às quais voltaremos.

1714
01: 19: 07,160 -> 01: 19: 10.160
E então vou literalmente apenas ir em frente e dizer cough.

1715
01: 19: 10,160 -> 01: 19: 14.120
Portanto, existem funções que usamos hoje - printf, get_int, get_string,
1716
01: 19: 14,120 -> 01: 19: 18.650
get_float-- nenhum dos quais mostramos a implementação feita, porque as pessoas,

1717
01: 19: 18.650 -> 01: 19: 21.270
anos atrás, tanto na equipe quanto no mundo real,

1718
01: 19: 21,270 -> 01: 19: 23.000
implementou essas funções para nós.

1719
01: 19: 23.000 -> 01: 19: 26.270
Você também pode implementar suas próprias funções personalizadas ou, no Scratch,

1720
01: 19: 26,270 -> 01: 19: 29.690
aquelas peças do quebra-cabeça que fizemos nesses blocos rosa.

1721
01: 19: 29.690 -> 01: 19: 31.940
Então, se você quiser fazer sua própria função cujo nome é

1722
01: 19: 31.940 -> 01: 19: 35.960
cough, cujo objetivo na vida é dizer tosse na tela,

1723
01: 19: 35,960 -> 01: 19: 37.010
esta é a sintaxe.

1724
01: 19: 37,010 -> 01: 19: 40.880
Para os fins de hoje, você diz void and void aqui, mas o nome da função

1725
01: 19: 40,880 -> 01: 19: 41.690
é importante.

1726
01: 19: 41,690 -> 01: 19: 43.040
Vou chamar de cough.

1727
01: 19: 43.040 -> 01: 19: 45.000
E então posso usá-lo da seguinte maneira.

1728
01: 19: 45.000 -> 01: 19: 50.750
Eu posso dizer tosse, tosse, tosse agora para tossir três vezes.

1729
01: 19: 50,750 -> 01: 19: 53.150
Ou ainda, já decidimos que era um design ruim.

1730
01: 19: 53,150 -> 01: 19: 57.770
Para int eu obtenho 0, i menor que 3, i mais mais.

1731
01: 19: 57.770 -> 01: 20: 00.230
Agora posso fazer algo como tossir.

1732
01: 20: 00,230 -> 01: 20: 03.290
E agora, novamente, fora de vista, longe da mente.

1733
01: 20: 03.290 -> 01: 20: 07.460
Não preciso saber ou me importar como a função da tosse é implementada.

1734
01: 20: 07.460 -> 01: 20: 10.850
Posso me importar que meu código apenas diga ao computador o que fazer.

1735
01: 20: 10.850 -> 01: 20: 15.260
Para i de 0 em até 3, tosse, tosse, tosse.

1736
01: 20: 15.260 -> 01: 20: 16.480
E isso é uma abstração.

1737
01: 20: 16.480 -> 01: 20: 18.950
Não me importa se a tosse é implementada com printf.

1738
01: 20: 18.950 -> 01: 20: 22.070
Eu só me importo se houver uma função chamada tosse.

1739
01: 20: 22.070 -> 01: 20: 25.490
Então, deixe-me executar isso e ver o que acontece.

1740
01: 20: 25.490 -> 01: 20: 28.710
Deixe-me rolar até o final, faça tosse1.

1741
01: 20: 28,710 -> 01: 20: 29.750
OK, incrível.

1742
01: 20: 29.750 -> 01: 20: 30.830
Sem erros vermelhos agora.

1743
01: 20: 30.830 -> 01: 20: 34.550
Então ./tosse1, tosse, tosse, tosse.

1744
01: 20: 34.550 -> 01: 20: 38.553
Mas observe que este é um projeto um pouco ruim, eu diria,

1745
01: 20: 38.553 -> 01: 20: 39.470
porque você sabe o quê?

1746
01: 20: 39.470 -> 01: 20: 42.890
Se você continuar escrevendo funções personalizadas aqui, aqui, aqui,

1747
01: 20: 42.890 -> 01: 20: 46.145
a parte principal de seu programa será empurrada para baixo.

1748
01: 20: 46,145 -> 01: 20: 48.770
E é uma convenção humana geralmente ter a função principal

1749
01: 20: 48.770 -> 01: 20: 49.790
na parte superior do seu arquivo.

1750
01: 20: 49,790 -> 01: 20: 50.790
Parece bastante razoável.

1751
01: 20: 50,790 -> 01: 20: 53.420
Então você abre o arquivo, bum, a função principal está bem ali.

1752
01: 20: 53.420 -> 01: 20: 54.620
Então, vamos mantê-lo lá.

1753
01: 20: 54.620 -> 01: 20: 58.448
Então, deixe-me mover a função da cough para baixo, apenas para

1754
01: 20: 58,448 -> 01: 21: 01.490
que, novamente, a primeira coisa que vejo é de fato a parte principal do meu programa.

1755
01: 21: 01,490 -> 01: 21: 03.020
E onde quer que esteja a tosse, não me importo.

1756
01: 21: 03,020 -> 01: 21: 05.090
Esse foi o objetivo de implementá-lo.

1757
01: 21: 05.090 -> 01: 21: 08.990
Deixe-me ir agora para a janela do meu terminal e "make cough1".

1758
01: 21: 08,990 -> 01: 21: 12.500
Oh meu Deus, alguns erros vermelhos passaram voando.

1759
01: 21: 12.500 -> 01: 21: 14.030
O que há de errado aqui?

1760
01: 21: 14.030 -> 01: 21: 19.130
So error, implicit declaration of function cough is invalid in C '99.

1761
01: 21: 19,130 ​​-> 01: 21: 22.610
C '99 significa a versão de C inventada em 1999.

1762
01: 21: 22.610 -> 01: 21: 23.690
O que está acontecendo?

1763
01: 21: 23.690 -> 01: 21: 25.100
Implicit declaration/Declaração Implicita?

1764
01: 21: 25,100 -> 01: 21: 27.500
Então é aqui que C difere do Scratch novamente.

1765
01: 21: 27,500 -> 01: 21: 29.840
C é velho e meio burro.

1766
01: 21: 29.840 -> 01: 21: 32.840
Ele só sabe o que você diz, e só

1767
01: 21: 32.840 -> 01: 21: 36.290
sabe o que você diz em ordem de cima para baixo, da esquerda para a direita.

1768
01: 21: 36,290 -> 01: 21: 41.480
Portanto, neste programa agora, incluí stdio.h, como antes.

1769
01: 21: 41,480 -> 01: 21: 43.700
Eu incluí o início de a função "main".

1770
01: 21: 43,700 -> 01: 21: 45.480
Eu comecei um loop for.

1771
01: 21: 45,480 -> 01: 21: 48.320
E então estou usando uma função que aparentemente é chamada de cough.

1772
01: 21: 48,320 -> 01: 21: 52.640
No entanto, onde a função cough está implementada agora?

1773
01: 21: 52.640 -> 01: 21: 54.880
Bem aqui na linha 11 em diante.

1774
01: 21: 54,880 -> 01: 21: 56.600
C não é tão inteligente.

1775
01: 21: 56.600 -> 01: 21: 59.510
Não vai presumir e procurar mais adiante em seu arquivo para ver,

1776
01: 21: 59.510 -> 01: 22: 02.150
talvez eles coloquem a função tosse abaixo.

1777
01: 22: 02,150 -> 01: 22: 04.070
Só vai fazer o que você mandar.

1778
01: 22: 04,070 -> 01: 22: 05.503
Portanto, há uma solução para isso.

1779
01: 22: 05,503 -> 01: 22: 07.670
Você pode fazer o que eu fiz inicialmente, que é colocar

1780
01: 22: 07,670 -> 01: 22: 09.268
todas as suas funções personalizadas no topo.

1781
01: 22: 09,268 -> 01: 22: 11.810
Mas isso é uma espécie de ciclo vicioso, porque você não pode para sempre

1782
01: 22: 11.810 -> 01: 22: 13.107
coloque as novas funções no topo.

1783
01: 22: 13,107 -> 01: 22: 15.690
Eventualmente, você encontrará algum tipo de restrição.

1784
01: 22: 15.690 -> 01: 22: 19.070
E meu Deus, você quer que a função principal, por convenção, esteja no topo.

1785
01: 22: 19,070 -> 01: 22: 20.880
Portanto, há outra solução aqui.

1786
01: 22: 20,880 -> 01: 22: 23.900
E este é o único momento em que copiar/colar é atraente.

1787
01: 22: 23,900 -> 01: 22: 29.210
Você literalmente copia a primeira linha do código de sua função na linha 11 lá.

1788
01: 22: 29,210 -> 01: 22: 33.660
E você vai em frente e cola no topo do seu arquivo com um ponto e vírgula.

1789
01: 22: 33.660 -> 01: 22: 38.113
Portanto, esta é uma espécie de enganar C para, oh, você já viu cough antes.

1790
01: 22: 38,113 -> 01: 22: 40.530
Você não viu tudo isso, mas você já viu o suficiente -

1791
01: 22: 40.530 -> 01: 22: 41.720
você viu seu nome -

1792
01: 22: 41,720 -> 01: 22: 45.870
para agora tolere o aparecimento em minha função "main".

1793
01: 22: 45,870 -> 01: 22: 49.130
Então, deixe-me recompilar este código.

1794
01: 22: 49,130 ​​-> 01: 22: 51.770
Vou seguir em frente e fazer cough1 entrar.

1795
01: 22: 51,770 -> 01: 22: 53.510
OK, agora está compilado.

1796
01: 22: 53.510 -> 01: 22: 59.370
./cough1 e viola, estamos de volta aos negócios lá.

1797
01: 22: 59,370 -> 01: 23: 00.740
Mas deixe-me fazer um refinamento.

1798
01: 23: 00,740 -> 01: 23: 05.810
E vou pular para o que chamei nos exemplos online cough3.c.

1799
01: 23: 05,810 -> 01: 23: 08.600
Acontece que suas próprias funções personalizadas podem receber entrada.

1800
01: 23: 08.600 -> 01: 23: 11.610
Esta palavra "void" significa que não é necessária nenhuma entrada.

1801
01: 23: 11,610 -> 01: 23: 15.938
E esta palavra "void" significa que não retorna nenhum valor, como get_int e get_string manda

1802
01: 23: 15.938 -> 01: 23: 16.730
algo de volta para você.

1803
01: 23: 16,730 -> 01: 23: 18.647
Isso não é aplicável agora, mas vamos voltar

1804
01: 23: 18.647 -> 01: 23: 20.450
para isso em uma ou duas semanas.

1805
01: 23: 20.450 -> 01: 23: 24.770
Suponha que você queira tornar a função cough mais versátil

1806
01: 23: 24.770 -> 01: 23: 28.190
de forma que ele vai tossir várias vezes para você.

1807
01: 23: 28,190 -> 01: 23: 29.660
Você sabe o que pode fazer, é isso.

1808
01: 23: 29.660 -> 01: 23: 34.670
Você pode alterar a entrada para a função de tosse para algum valor como n,

1809
01: 23: 34,670 -> 01: 23: 38.840
e você pode fazer algo assim - para int eu obtenho 0.

1810
01: 23: 38,840 -> 01: 23: 43.730
i é menor que n, portanto, não é mais "hardcoded/fixo no código". i mais mais.

1811
01: 23: 43.730 -> 01: 23: 48.650
E então, dentro das chaves, você pode imprimir esta linha de tosse.

1812
01: 23: 48.650 -> 01: 23: 52.520
Então agora, observe, a tosse foi parametrizada.

1813
01: 23: 52.520 -> 01: 23: 55.430
Agora, leva a entrada de um inteiro chamado n, e

1814
01: 23: 55.430 -> 01: 23: 58.220
usa essa entrada, n, exatamente como você poderia ter feito

1815
01: 23: 58,220 -> 01: 24: 00.740
no Scratch, para fazer algo n vezes -

1816
01: 24: 00,740 -> 01: 24: 04.010
não uma, não três vezes, mas um número variável de vezes.

1817
01: 24: 04,010 -> 01: 24: 06.360
Tenho que mudar minha primeira linha aqui.

1818
01: 24: 06,360 -> 01: 24: 07.520
Isso é chamado de protótipo.

1819
01: 24: 07.520 -> 01: 24: 09.860
Está função de linha única é o que chamamos de protótipo,

1820
01: 24: 09,860 -> 01: 24: 12.140
e é só copiar/colar da sua função real.

1821
01: 24: 12,140 -> 01: 24: 13.700
Mas agora observe o que posso fazer.

1822
01: 24: 13,700 -> 01: 24: 16.550
Minha função principal, novamente, é a essência do meu programa.

1823
01: 24: 16.550 -> 01: 24: 19.190
É um pouco complicado agora.

1824
01: 24: 19,190 -> 01: 24: 23.150
Não seria melhor se eu pudesse dizer "cough" três vezes?

1825
01: 24: 23,150 -> 01: 24: 28.040
E, de fato, agora não preciso saber ou me importar como a cough é implementada.

1826
01: 24: 28.040 -> 01: 24: 30.950
É um programa bem desenhado, sem dúvida.

1827
01: 24: 30.950 -> 01: 24: 32.300
É uma linha de código.

1828
01: 24: 32,300 -> 01: 24: 33.137
É descritivo.

1829
01: 24: 33,137 -> 01: 24: 33.720
diga tosse.

1830
01: 24: 33,720 -> 01: 24: 35.990
É preciso uma entrada, o que significa que custará três vezes.

1831
01: 24: 35,990 -> 01: 24: 38.823
E o que está abaixo no arquivo, embora eu certamente pudesse trazê-lo

1832
01: 24: 38,823 -> 01: 24: 40.770
de volta para cima, é exatamente o que um cientista da computação

1833
01: 24: 40.770 -> 01: 24: 43.250
chamaria um detalhe de implementação.

1834
01: 24: 43,250 -> 01: 24: 45.620
Alguém se preocupa em como você implementa a cough,

1835
01: 24: 45,620 -> 01: 24: 48.200
mas você não precisa se preocupar em como implementar a tosse.

1836
01: 24: 48,200 -> 01: 24: 50.530
Você não precisa saber como obtemos inteiros.

1837
01: 24: 50.530 -> 01: 24: 52.930
Você não precisa se preocupar com a forma de imprimir.

1838
01: 24: 52.930 -> 01: 24: 56.140
Você só se importa se outra pessoa implementou essa função

1839
01: 24: 56,140 -> 01: 25: 00.280
para que você possa se apoiar nos  ombros deles e construir programas mais interessantes que

1840
01: 25: 00,280 -> 01: 25: 03.310
são realmente interessantes para você.

1841
01: 25: 03,310 -> 01: 25: 06.235
Deixe-me ir em frente e abrir um exemplo que se baseia nessa mesma ideia.

1842
01: 25: 06,235 -> 01: 25: 08.740


1843
01: 25: 08.740 -> 01: 25: 14.030
Em, vamos ver, positive.c, temos este exemplo aqui,

1844
01: 25: 14.030 -> 01: 25: 16.040
o que torna isso ainda mais claro.

1845
01: 25: 16.040 -> 01: 25: 20.100
Então, aqui está um programa que usa nossas duas bibliotecas, CS50 em I/O padrão.

1846
01: 25: 20,100 -> 01: 25: 22.330
Acontece que a biblioteca CS50 não

1847
01: 25: 22,330 -> 01: 25: 24.730
vem com uma função chamada get_positive_int.

1848
01: 25: 24,730 -> 01: 25: 25.772
Ele vem com get_int.

1849
01: 25: 25.772 -> 01: 25: 27.730
E você pode imaginar programas onde você realmente

1850
01: 25: 27,730 -> 01: 25: 31.450
quer um número inteiro positivo do humano, porque os números negativos para um jogo

1851
01: 25: 31.450 -> 01: 25: 33.820
ou para algum programa simplesmente não faria sentido.

1852
01: 25: 33.820 -> 01: 25: 35.380
Então, como podemos implementar isso?

1853
01: 25: 35,380 -> 01: 25: 38.350
Bem, seria bom criá-lo para que você pudesse simplesmente

1854
01: 25: 38,350 -> 01: 25: 40.930
escrever um programa de duas linhas como este, onde você chama

1855
01: 25: 40.930 -> 01: 25: 42.820
uma função chamada get_positive_int.

1856
01: 25: 42,820 -> 01: 25: 46.720
E se eu rolar para baixo, noto que há um novo recurso

1857
01: 25: 46,720 -> 01: 25: 49.810
aqui que ainda não vimos, mas é um exemplo interessante

1858
01: 25: 49,810 -> 01: 25: 52.600
de outro recurso de C. O que destaquei aqui

1859
01: 25: 52,600 -> 01: 25: 56.350
entre as linhas 15 e 24 é essa lógica.

1860
01: 25: 56,350 -> 01: 25: 58.510
Aqui está uma função chamada get_positive_int.

1861
01: 25: 58.510 -> 01: 26: 01.690
Não requer entradas, então não preciso passar nada entre parênteses.

1862
01: 26: 01,690 -> 01: 26: 03.850
Eu só quero obter qualquer número positivo inteiro.

1863
01: 26: 03,850 -> 01: 26: 06.670
Mas eu quero que essa função me devolva algo,

1864
01: 26: 06,670 -> 01: 26: 09.850
assim como get_int me devolveu um valor que eu poderia colocar em uma variável,

1865
01: 26: 09,850 -> 01: 26: 11.170
assim como get_string faz.

1866
01: 26: 11,170 -> 01: 26: 13.030
Portanto, isso não é vazio.

1867
01: 26: 13,030 -> 01: 26: 13.990
Isso é int.

1868
01: 26: 13,990 -> 01: 26: 17.290
Portanto, esta palavra à esquerda de uma função é o tipo de sua saída.

1869
01: 26: 17,290 -> 01: 26: 20.920
Esta palavra entre parênteses é o tipo de entrada, se houver.

1870
01: 26: 20,920 -> 01: 26: 24.640
E se não houver nada, basta dizer "void" em um ou nos dois lugares.

1871
01:26:24,640 --> 01:26:26,190
Now, here's a curiosity--

1872
01:26:26,190 --> 01:26:30,280
on line 17, we've not seen this before, but this is just a hint to the computer

1873
01:26:30,280 --> 01:26:32,425
saying give me a variable called n.

1874
01:26:32,425 --> 01:26:34,300
I'm not sure what I'm going to put in it yet.

1875
01:26:34,300 --> 01:26:36,580
So you literally just say int n semicolon.

1876
01:26:36,580 --> 01:26:38,405
You don't need to assign it anything yet.

1877
01:26:38,405 --> 01:26:40,030
It has what we'll call a garbage value.

1878
01:26:40,030 --> 01:26:42,322
You have no idea what's in it, but that doesn't matter.

1879
01:26:42,322 --> 01:26:43,730
You'll put something in it later.

1880
01:26:43,730 --> 01:26:45,820
Then there's this loop, which we haven't seen yet,

1881
01:26:45,820 --> 01:26:47,800
but in C, it's called a do-while loop.

1882
01:26:47,800 --> 01:26:52,120
It literally says do the following while this Boolean expression is true.

1883
01:26:52,120 --> 01:26:53,320
So what do I want to do?

1884
01:26:53,320 --> 01:26:55,330
I want to get an int from the user, prompting

1885
01:26:55,330 --> 01:26:58,540
the human for a positive integer, and store it in n.

1886
01:26:58,540 --> 01:27:03,010
However, I want to keep doing this while n is less than 1.

1887
01:27:03,010 --> 01:27:06,370
Because if the human types in 0 or negative 1 or negative 50

1888
01:27:06,370 --> 01:27:12,040
or anything non-positive, I do want to prompt them again and again and again.

1889
01:27:12,040 --> 01:27:14,530
So a do-while loop is kind of neat, because it

1890
01:27:14,530 --> 01:27:17,090
will do this first thing at least once.

1891
01:27:17,090 --> 01:27:20,200
Then it will check the condition and potentially do it again

1892
01:27:20,200 --> 01:27:22,450
if the human has not cooperated.

1893
01:27:22,450 --> 01:27:25,900
A while loop, if you think back, actually checked the condition first.

1894
01:27:25,900 --> 01:27:29,590
It was while some Boolean expression is true, do the following.

1895
01:27:29,590 --> 01:27:34,210
This one gives you one such iteration, one pass for free,

1896
01:27:34,210 --> 01:27:35,767
and then it checks the condition.

1897
01:27:35,767 --> 01:27:37,600
So it's just a different way of programming,

1898
01:27:37,600 --> 01:27:40,090
but we could do everything we've done thus far using

1899
01:27:40,090 --> 01:27:46,550
while loops or even for loops, as well.

1900
01:27:46,550 --> 01:27:50,080
All right, well let's go ahead now and make this a little more user friendly.

1901
01:27:50,080 --> 01:27:54,790
Let me go ahead and pull up some examples here of some screens that

1902
01:27:54,790 --> 01:27:56,060
might look familiar.

1903
01:27:56,060 --> 01:27:58,488
So if I go ahead and open up, for instance,

1904
01:27:58,488 --> 01:28:00,280
this slide here, you might recall this game

1905
01:28:00,280 --> 01:28:04,000
from yesteryear, Super Mario Brothers 1, from the very original Nintendo.

1906
01:28:04,000 --> 01:28:07,510
And there's some screens in that game that look a little something like this.

1907
01:28:07,510 --> 01:28:09,100
For instance, these are little bricks in the air

1908
01:28:09,100 --> 01:28:11,200
that if Mario or Luigi hits their head up against,

1909
01:28:11,200 --> 01:28:13,450
like a coin or something else pops out.

1910
01:28:13,450 --> 01:28:16,810
But this is kind of a nice idea, because it lends itself to actually doing

1911
01:28:16,810 --> 01:28:18,535
something a little programmatically.

1912
01:28:18,535 --> 01:28:21,160
For instance, how might I go about writing a program that quite

1913
01:28:21,160 --> 01:28:23,800
simply prints out four question marks?

1914
01:28:23,800 --> 01:28:26,920
Well, let me go ahead and open up, for instance, in code,

1915
01:28:26,920 --> 01:28:30,100
an example called mario0.c.

1916
01:28:30,100 --> 01:28:33,087
And I claim that this could be one way of implementing this program.

1917
01:28:33,087 --> 01:28:35,170
It's very simple, and it really doesn't do justice

1918
01:28:35,170 --> 01:28:39,400
to the other graphics on the screen, but it does implement that one idea.

1919
01:28:39,400 --> 01:28:41,800
And indeed, somewhere in the code for Mario,

1920
01:28:41,800 --> 01:28:43,600
there was probably some line of code that

1921
01:28:43,600 --> 01:28:47,950
told the console game to print question mark, question mark, question

1922
01:28:47,950 --> 01:28:48,970
mark, question mark.

1923
01:28:48,970 --> 01:28:51,760
In C, we could certainly do this with four question marks.

1924
01:28:51,760 --> 01:28:55,048
Or how else could we do something that many times?

1925
01:28:55,048 --> 01:28:55,840
AUDIENCE: For loop.

1926
01:28:55,840 --> 01:28:57,465
DAVID MALAN: Something like a for loop.

1927
01:28:57,465 --> 01:29:00,310
So let me go ahead and jump ahead a couple of iterations

1928
01:29:00,310 --> 01:29:05,200
to an example I'll call mario2.c, which just does all of this.

1929
01:29:05,200 --> 01:29:08,500
So this is actually pretty involved, but notice what it's doing.

1930
01:29:08,500 --> 01:29:12,010
In main, I'm saying, hey, give me an integer called n.

1931
01:29:12,010 --> 01:29:14,630
Do the following while n is less than 1.

1932
01:29:14,630 --> 01:29:18,820
So this is just a way of asking, what is the width of the blocks

1933
01:29:18,820 --> 01:29:20,140
that you want to print?

1934
01:29:20,140 --> 01:29:24,190
Then, once I have that answer, I can go ahead and, just as before,

1935
01:29:24,190 --> 01:29:28,940
print that many question marks n times, one at a time.

1936
01:29:28,940 --> 01:29:32,080
And at the very end, I'll print just a new line.

1937
01:29:32,080 --> 01:29:35,470
So in short, if you want to create a program, albeit in text,

1938
01:29:35,470 --> 01:29:37,760
that does something like this, and I make mario2--

1939
01:29:37,760 --> 01:29:38,410
whoops.

1940
01:29:38,410 --> 01:29:43,510
And I make mario2, Enter, and type ./mario2,

1941
01:29:43,510 --> 01:29:46,510
I can do a width of four and get four question marks.

1942
01:29:46,510 --> 01:29:49,730
Or I can do 50 and get many more on the screen, all

1943
01:29:49,730 --> 01:29:51,480
by just using these basic building blocks.

1944
01:29:51,480 --> 01:29:54,660
But notice, because of that do-while loop, if I don't cooperate

1945
01:29:54,660 --> 01:29:58,110
and I do something like 0 or negative 1 or negative 50,

1946
01:29:58,110 --> 01:30:02,160
I just keep getting prompted again and again, because n is less than 1.

1947
01:30:02,160 --> 01:30:05,130
That's the kind of logic that you can impose there.

1948
01:30:05,130 --> 01:30:10,018
But let's go ahead and skip ahead, say, to something like this in Mario,

1949
01:30:10,018 --> 01:30:12,060
where you have a whole lot of bricks underground.

1950
01:30:12,060 --> 01:30:16,000
And this time, it's not just a column or a row of bricks.

1951
01:30:16,000 --> 01:30:17,755
This time, it's kind of two dimensions.

1952
01:30:17,755 --> 01:30:20,130
Well, this is kind of interesting, because now how do you

1953
01:30:20,130 --> 01:30:23,200
go about printing block, block, block, block, block, block, block, block,

1954
01:30:23,200 --> 01:30:25,158
block, block, block, block, and actually making

1955
01:30:25,158 --> 01:30:26,700
a two-dimensional structure instead?

1956
01:30:26,700 --> 01:30:30,090
Well, there's nothing stopping us in C, as in Scratch,

1957
01:30:30,090 --> 01:30:33,540
from doing something, for instance, with loops.

1958
01:30:33,540 --> 01:30:35,650
So let me show this example here.

1959
01:30:35,650 --> 01:30:38,070
So suppose that with these first lines of code,

1960
01:30:38,070 --> 01:30:41,938
I've asked the user for the size of this block.

1961
01:30:41,938 --> 01:30:44,730
So I want to create something that's square-like like this-- block,

1962
01:30:44,730 --> 01:30:47,710
block, block, block, block, block, block, block, block, and so forth.

1963
01:30:47,710 --> 01:30:51,270
Well, I can go ahead and prompt them for an int again and again

1964
01:30:51,270 --> 01:30:53,500
and again until I know that size.

1965
01:30:53,500 --> 01:30:54,930
And then notice this.

1966
01:30:54,930 --> 01:30:58,770
This is starting to escalate again, but consider the logic.

1967
01:30:58,770 --> 01:31:02,520
This now is for int i get 0, i less than n, i plus plus.

1968
01:31:02,520 --> 01:31:04,500
So do the following n times, right?

1969
01:31:04,500 --> 01:31:08,220
This is a very cryptic, C-like way of saying, do the following n times.

1970
01:31:08,220 --> 01:31:10,170
What about line 16?

1971
01:31:10,170 --> 01:31:13,740
What is line 16 saying?

1972
01:31:13,740 --> 01:31:16,710
Even though it's using a different variable.

1973
01:31:16,710 --> 01:31:18,869
I'm using j just because instead of i.

1974
01:31:18,869 --> 01:31:19,744
AUDIENCE: Same thing.

1975
01:31:19,744 --> 01:31:20,786
Do the following n times.

1976
01:31:20,786 --> 01:31:24,180
DAVID MALAN: Yeah, it says the exact same thing-- do the following n times.

1977
01:31:24,180 --> 01:31:26,880
However, it's counting using j instead of i,

1978
01:31:26,880 --> 01:31:30,100
just so that my math doesn't kind of commingle incorrectly.

1979
01:31:30,100 --> 01:31:32,580
So if you think about what this Mario block is,

1980
01:31:32,580 --> 01:31:35,318
this is like printing rows and columns.

1981
01:31:35,318 --> 01:31:37,860
Kind of like an old school typewriter that's got to move from

1982
01:31:37,860 --> 01:31:41,250
left to right and then top to bottom, top to bottom, left to right,

1983
01:31:41,250 --> 01:31:44,610
and so forth just to print different blocks on different lines.

1984
01:31:44,610 --> 01:31:47,010
So the effect here-- if I open up mario8--

1985
01:31:47,010 --> 01:31:48,730
might be this, make-- oops.

1986
01:31:48,730 --> 01:31:53,193
Let me go ahead and make mario8, ./mario8.

1987
01:31:53,193 --> 01:31:54,360
What's the size going to be?

1988
01:31:54,360 --> 01:31:55,680
Well, maybe three.

1989
01:31:55,680 --> 01:32:00,030
And now I've printed out three rows and three columns.

1990
01:32:00,030 --> 01:32:03,930
These essentially represent each of my rows.

1991
01:32:03,930 --> 01:32:05,830
I'm counting from i up to--

1992
01:32:05,830 --> 01:32:07,450
oh.

1993
01:32:07,450 --> 01:32:10,980
I'm teaching myself now only, OK.

1994
01:32:10,980 --> 01:32:11,760
Let's rewind.

1995
01:32:11,760 --> 01:32:13,950
Here is what was amazing me a moment ago.

1996
01:32:13,950 --> 01:32:16,770
When I was running what's the size of this program,

1997
01:32:16,770 --> 01:32:19,140
I saw a three-by-three grid of blocks.

1998
01:32:19,140 --> 01:32:21,450
And if I run it again, maybe with 10, I now

1999
01:32:21,450 --> 01:32:24,003
see an even bigger grid of 10-by-10 bricks.

2000
01:32:24,003 --> 01:32:26,670
It's a little taller than it is wide, because the hash marks are

2001
01:32:26,670 --> 01:32:27,960
taller than they are wide.

2002
01:32:27,960 --> 01:32:30,390
And you'll see that now this program is dynamic.

2003
01:32:30,390 --> 01:32:31,950
So how is that working?

2004
01:32:31,950 --> 01:32:33,950
Well, if I actually look at the code here,

2005
01:32:33,950 --> 01:32:36,750
notice that, effectively, what line 14 is doing

2006
01:32:36,750 --> 01:32:39,030
is it's doing one row at a time.

2007
01:32:39,030 --> 01:32:43,170
It's giving me n rows, and each of those rows I'm thinking of this is i at 0,

2008
01:32:43,170 --> 01:32:46,020
i1, i2, and so forth.

2009
01:32:46,020 --> 01:32:50,650
Meanwhile, within each row, I'm using this inner loop,

2010
01:32:50,650 --> 01:32:54,900
which is deliberately nested inside, to kind of do each of the characters

2011
01:32:54,900 --> 01:32:55,990
from left to right.

2012
01:32:55,990 --> 01:32:58,680
So within each row, I want hash, hash, hash, hash.

2013
01:32:58,680 --> 01:33:00,750
Within each row-- hash, hash, hash, hash.

2014
01:33:00,750 --> 01:33:03,670
So it's like implementing this two-dimensional process.

2015
01:33:03,670 --> 01:33:06,900
But again, using the same fundamental ideas.

2016
01:33:06,900 --> 01:33:11,370
Just a for loop that's very carefully counting from zero on up

2017
01:33:11,370 --> 01:33:16,032
to some value to do something again and again and again.

2018
01:33:16,032 --> 01:33:18,240
And so if you think about really any of today's games

2019
01:33:18,240 --> 01:33:21,150
or graphics or programs, anytime you see redundancy,

2020
01:33:21,150 --> 01:33:24,600
whether it's this in two dimensions-- maybe it's this vertically in one

2021
01:33:24,600 --> 01:33:26,712
dimension or this horizontally in another.

2022
01:33:26,712 --> 01:33:29,670
Odds are, there's just some repetition that's happening again and again

2023
01:33:29,670 --> 01:33:33,510
and again that can be reduced in C or in Scratch or some other language

2024
01:33:33,510 --> 01:33:36,780
to ultimately just lines of code.

2025
01:33:36,780 --> 01:33:39,270
And indeed, this is an allusion to one of the first things

2026
01:33:39,270 --> 01:33:41,760
you'll do for the first problem set, problem set 1.

2027
01:33:41,760 --> 01:33:45,180
You'll use CS50 Lab, which is identical to CS50 Sandbox, which

2028
01:33:45,180 --> 01:33:48,090
I've been using thus far, but which adds instructions,

2029
01:33:48,090 --> 01:33:52,170
the actual problems to solve, alongside of your sandbox.

2030
01:33:52,170 --> 01:33:55,470
But before we tease you with that, let's just

2031
01:33:55,470 --> 01:34:00,720
consider now that there are a bunch of little assumptions I've been making.

2032
01:34:00,720 --> 01:34:03,060
Like thus far, all of the mistakes in my code

2033
01:34:03,060 --> 01:34:06,990
have been my own-- some intentional, but several unintentional, as well, today.

2034
01:34:06,990 --> 01:34:10,560
But it turns out that computers themselves do have limitations.

2035
01:34:10,560 --> 01:34:12,810
Inside of your Mac or PC is generally stuff like this.

2036
01:34:12,810 --> 01:34:14,372
This is called memory, or RAM.

2037
01:34:14,372 --> 01:34:16,080
And you don't typically see it unless you

2038
01:34:16,080 --> 01:34:18,900
remove the cover from your phone or your laptop or desktop.

2039
01:34:18,900 --> 01:34:22,680
RAM is where all of your programs are stored while they're running.

2040
01:34:22,680 --> 01:34:26,190
RAM is where all of your programs-- where all of your files are

2041
01:34:26,190 --> 01:34:27,540
stored while they're open.

2042
01:34:27,540 --> 01:34:30,930
It's what your computer uses to do multiple things at once

2043
01:34:30,930 --> 01:34:32,440
and keep things in memory.

2044
01:34:32,440 --> 01:34:35,430
However, it is, by nature of hardware, finite.

2045
01:34:35,430 --> 01:34:38,610
You have maybe one gigabyte, one billion bytes, of memory.

2046
01:34:38,610 --> 01:34:41,400
Maybe you have four gigabytes, or four billion bytes, of memory.

2047
01:34:41,400 --> 01:34:44,280
You have fixed amount of memory in your computer,

2048
01:34:44,280 --> 01:34:48,040
which means there is some fundamental limitation on what your computer can

2049
01:34:48,040 --> 01:34:48,540
do.

2050
01:34:48,540 --> 01:34:52,350
It cannot necessarily count to infinity, because how could it count to infinity

2051
01:34:52,350 --> 01:34:57,020
if it can't store all possible numbers using a finite amount of space?

2052
01:34:57,020 --> 01:34:59,370
Indeed, there are some limits of computation

2053
01:34:59,370 --> 01:35:01,230
that we've only just begun to see.

2054
01:35:01,230 --> 01:35:02,890
In fact, let me go ahead and do this.

2055
01:35:02,890 --> 01:35:06,445
Let me write a program that I'm going to go ahead and call float.c.

2056
01:35:06,445 --> 01:35:09,570
And this is just going to be a program that gets a couple of floating point

2057
01:35:09,570 --> 01:35:11,980
values from the user.

2058
01:35:11,980 --> 01:35:15,000
Let me go ahead and include the CS50 library.

2059
01:35:15,000 --> 01:35:19,420
Let's go ahead and include stdio.h, int main void, as before.

2060
01:35:19,420 --> 01:35:22,488
And all I want to do here with this program is get a couple of floats.

2061
01:35:22,488 --> 01:35:23,280
So give me a float.

2062
01:35:23,280 --> 01:35:24,420
We'll call it x.

2063
01:35:24,420 --> 01:35:26,808
Get_float, and I'll prompt the human for x.

2064
01:35:26,808 --> 01:35:28,350
Then let me go ahead and get another.

2065
01:35:28,350 --> 01:35:29,370
I'll call it y.

2066
01:35:29,370 --> 01:35:31,380
Get_float, quote unquote y.

2067
01:35:31,380 --> 01:35:34,110
And recall that a float is just a number that

2068
01:35:34,110 --> 01:35:36,475
has a decimal point in it, a so-called real number.

2069
01:35:36,475 --> 01:35:38,100
Now let's just do some simple division.

2070
01:35:38,100 --> 01:35:40,990
I claim that computers can do addition, subtraction, and so forth.

2071
01:35:40,990 --> 01:35:41,920
So let's do that.

2072
01:35:41,920 --> 01:35:46,410
Let's just tell it that x divided by y is going to equal the following--

2073
01:35:46,410 --> 01:35:52,150
percent f backslash n x divided by y semicolon.

2074
01:35:52,150 --> 01:35:55,110
So that's just sort of a very simplistic calculator

2075
01:35:55,110 --> 01:35:57,510
that I've implemented that only supports division.

2076
01:35:57,510 --> 01:36:04,170
Let me go ahead and compile this by going and typing make floats.

2077
01:36:04,170 --> 01:36:05,820
And you'll see that it did compile.

2078
01:36:05,820 --> 01:36:07,980
So floats with dot slash.

2079
01:36:07,980 --> 01:36:09,570
x is going to be, say, 1.

2080
01:36:09,570 --> 01:36:10,960
y is going to be 10.

2081
01:36:10,960 --> 01:36:12,120
OK, viola.

2082
01:36:12,120 --> 01:36:15,501
x divided by y equals 0.10000.

2083
01:36:15,501 --> 01:36:16,440
That's pretty nice.

2084
01:36:16,440 --> 01:36:19,570
And recall, if you don't want to see all those zeros, you can just say,

2085
01:36:19,570 --> 01:36:23,160
show me one decimal point by adding 0.1.

2086
01:36:23,160 --> 01:36:25,950
Recompile and then rerun it.

2087
01:36:25,950 --> 01:36:27,790
And now do 1, 10.

2088
01:36:27,790 --> 01:36:29,820
OK, so now it's 1/10.

2089
01:36:29,820 --> 01:36:30,930
Or is it?

2090
01:36:30,930 --> 01:36:33,660
Now that I have this ability to look past the decimal point,

2091
01:36:33,660 --> 01:36:36,900
why don't I look not a few places or one place.

2092
01:36:36,900 --> 01:36:40,440
Let me go ahead and look maybe 10 places after the decimal point.

2093
01:36:40,440 --> 01:36:48,210
Let me rerun this as make floats, ./floats, 1, 10.

2094
01:36:48,210 --> 01:36:49,920
Interesting.

2095
01:36:49,920 --> 01:36:51,627
All right, that seems a little strange.

2096
01:36:51,627 --> 01:36:52,710
Maybe it was just a fluke.

2097
01:36:52,710 --> 01:36:54,043
Let's look out a little further.

2098
01:36:54,043 --> 01:36:56,080
Let's look 50 decimal places out.

2099
01:36:56,080 --> 01:36:57,887
Let's go ahead and recompile this.

2100
01:36:57,887 --> 01:36:59,970
And it turns out, there's some keyboard shortcuts.

2101
01:36:59,970 --> 01:37:02,100
I'm now hitting up and down on my keyboard, which

2102
01:37:02,100 --> 01:37:04,302
will scroll through your entire history of commands

2103
01:37:04,302 --> 01:37:06,010
so you don't have to remember everything.

2104
01:37:06,010 --> 01:37:08,130
So to save time, I'm now just going up and down.

2105
01:37:08,130 --> 01:37:11,850
Let me go ahead and do ./floats now, 1, 10.

2106
01:37:11,850 --> 01:37:14,820
Oh my god, division is a lie.

2107
01:37:14,820 --> 01:37:18,660
So when your grade school teachers or whatnot taught you that 1 divided by 10

2108
01:37:18,660 --> 01:37:24,690
is 1/10, or 0.10000 infinitely, apparently that's not true.

2109
01:37:24,690 --> 01:37:28,810
According to this computer, 1/10 is actually this value.

2110
01:37:28,810 --> 01:37:31,500
So how do we reconcile that?

2111
01:37:31,500 --> 01:37:36,180
Who is right, grade school math or computers?

2112
01:37:36,180 --> 01:37:39,150
And what might explain?

2113
01:37:39,150 --> 01:37:40,860
Any thoughts?

2114
01:37:40,860 --> 01:37:41,850
Yeah?

2115
01:37:41,850 --> 01:37:45,550
AUDIENCE: It only stores so much so then half of that,

2116
01:37:45,550 --> 01:37:47,300
you don't know what's going on over there.

2117
01:37:47,300 --> 01:37:48,800
DAVID MALAN: Yeah, that's a good way of putting it.

2118
01:37:48,800 --> 01:37:51,200
Computers can only store so much, so after a certain point,

2119
01:37:51,200 --> 01:37:52,908
you don't know what's going on out there.

2120
01:37:52,908 --> 01:37:53,480
I like that.

2121
01:37:53,480 --> 01:37:54,710
Because that's indeed true.

2122
01:37:54,710 --> 01:37:57,120
If you only have a finite amount of hardware,

2123
01:37:57,120 --> 01:38:00,830
like a finite amount of memory, at some point, the computer has to decide,

2124
01:38:00,830 --> 01:38:02,780
I can count no higher than this value.

2125
01:38:02,780 --> 01:38:06,890
Or I can store no more than this many numbers after the decimal point.

2126
01:38:06,890 --> 01:38:09,290
You might be using 32 bits, which a float is.

2127
01:38:09,290 --> 01:38:12,470
You could use more bits, like a double, as I described it earlier,

2128
01:38:12,470 --> 01:38:14,720
literally uses twice as many bits, 64 bits.

2129
01:38:14,720 --> 01:38:19,580
So that means we could get farther out before we see that imprecision.

2130
01:38:19,580 --> 01:38:20,870
But you will see it.

2131
01:38:20,870 --> 01:38:24,440
Computers are, indeed, not perfect in this sense.

2132
01:38:24,440 --> 01:38:26,780
They can only store a finite amount of information.

2133
01:38:26,780 --> 01:38:31,190
And so in that sense, the computer is storing the closest possible match

2134
01:38:31,190 --> 01:38:34,190
for 1 divided by 10 that it can.

2135
01:38:34,190 --> 01:38:38,090
Because you can't possibly store an infinite number of numbers 100%

2136
01:38:38,090 --> 01:38:42,080
precisely using a finite amount of information.

2137
01:38:42,080 --> 01:38:44,060
And we see this in another context, too.

2138
01:38:44,060 --> 01:38:48,530
Let me go ahead and write one other program here called overflow.c.

2139
01:38:48,530 --> 01:38:50,990
And we'll see the same issue in another context.

2140
01:38:50,990 --> 01:38:54,350
Let me go ahead and include stdio.h.

2141
01:38:54,350 --> 01:38:57,410
Let me go ahead and do int main void.

2142
01:38:57,410 --> 01:39:01,190
Let me go ahead and do for int i gets one.

2143
01:39:01,190 --> 01:39:07,478
I'm going to go ahead and just say no condition and do i times equals 2.

2144
01:39:07,478 --> 01:39:09,020
And let me go ahead and just do this.

2145
01:39:09,020 --> 01:39:11,840
Print out the value of i.

2146
01:39:11,840 --> 01:39:15,440
So I'm doing the super quickly, but I just have written a program here

2147
01:39:15,440 --> 01:39:17,510
that's going to start counting at zero.

2148
01:39:17,510 --> 01:39:19,430
It's going to multiply i.

2149
01:39:19,430 --> 01:39:22,562
Star equals just means times two again and again.

2150
01:39:22,562 --> 01:39:25,520
And it's going to do this forever, because I literally and deliberately

2151
01:39:25,520 --> 01:39:27,380
didn't ask a Boolean expression here.

2152
01:39:27,380 --> 01:39:29,352
I could actually just say something like true,

2153
01:39:29,352 --> 01:39:30,810
but I can also just leave it blank.

2154
01:39:30,810 --> 01:39:32,310
So this just means do this forever.

2155
01:39:32,310 --> 01:39:33,590
It's an infinite loop.

2156
01:39:33,590 --> 01:39:36,950
Well, let me go ahead and this is going to fly past the screen here.

2157
01:39:36,950 --> 01:39:40,190
So I'm going to also sleep for one second in between.

2158
01:39:40,190 --> 01:39:43,010
And indeed, there's a function in C called sleep.

2159
01:39:43,010 --> 01:39:45,230
But to use it, you actually have to include

2160
01:39:45,230 --> 01:39:50,092
another file called unistandard.h.

2161
01:39:50,092 --> 01:39:52,550
You would only know this from looking in the documentation,

2162
01:39:52,550 --> 01:39:55,820
but it's a handy function that lets me sleep one second at a time.

2163
01:39:55,820 --> 01:39:57,920
Let me go ahead and make overflow.

2164
01:39:57,920 --> 01:39:58,650
No errors.

2165
01:39:58,650 --> 01:40:00,650
Let me increase the size of my screen.

2166
01:40:00,650 --> 01:40:02,600
And let me go ahead and run overflow.

2167
01:40:02,600 --> 01:40:06,530
And we'll see that every one second, it prints out a value starting at one,

2168
01:40:06,530 --> 01:40:08,780
and then it doubles it, and then it doubles it,

2169
01:40:08,780 --> 01:40:10,760
and then it doubles it again.

2170
01:40:10,760 --> 01:40:13,220
So you might recall some of these values from last week,

2171
01:40:13,220 --> 01:40:16,620
where I proposed that were 1,024 pages in a phone book,

2172
01:40:16,620 --> 01:40:18,893
and then it just got smaller and smaller and smaller.

2173
01:40:18,893 --> 01:40:20,310
Now we're just doing the opposite.

2174
01:40:20,310 --> 01:40:22,970
We're doubling by two, by two, by two.

2175
01:40:22,970 --> 01:40:26,090
We're just past a million now, 2 million, 4 million, 8 million,

2176
01:40:26,090 --> 01:40:27,077
16 million.

2177
01:40:27,077 --> 01:40:28,160
So we're getting up there.

2178
01:40:28,160 --> 01:40:30,770
So it looks like integers are pretty big.

2179
01:40:30,770 --> 01:40:35,720
They're indeed using 32 bits in a computer that apparently--

2180
01:40:35,720 --> 01:40:38,150
what just happened?

2181
01:40:38,150 --> 01:40:39,170
Another lie.

2182
01:40:39,170 --> 01:40:44,360
If you just multiply some integer by two forever, it eventually becomes zero,

2183
01:40:44,360 --> 01:40:46,310
it would seem.

2184
01:40:46,310 --> 01:40:48,153
That, too, is not right.

2185
01:40:48,153 --> 01:40:49,070
But what has happened?

2186
01:40:49,070 --> 01:40:51,770
And there's kind of an illusion to it, both in my program's name

2187
01:40:51,770 --> 01:40:53,240
and in the red error.

2188
01:40:53,240 --> 01:40:56,750
Well, at some point, you only have so many bits

2189
01:40:56,750 --> 01:40:59,840
after which if you keep incrementing, incrementing, incrementing,

2190
01:40:59,840 --> 01:41:02,600
you don't have enough bits to sort of carry the one, so to speak,

2191
01:41:02,600 --> 01:41:04,580
and remember the even bigger value.

2192
01:41:04,580 --> 01:41:08,000
After all, if we go back to some of our discussion last week to discuss now

2193
01:41:08,000 --> 01:41:12,240
what's called floating point imprecision or now integer overflow,

2194
01:41:12,240 --> 01:41:14,720
which means floats can only be so precise

2195
01:41:14,720 --> 01:41:16,830
and integers can only be so big.

2196
01:41:16,830 --> 01:41:18,670
What you have is the following scenario.

2197
01:41:18,670 --> 01:41:21,253
123 in decimal, in our human world--

2198
01:41:21,253 --> 01:41:23,170
of course, you can just keep adding one to it.

2199
01:41:23,170 --> 01:41:26,630
And as soon as you hit nine, it rolls over to zero.

2200
01:41:26,630 --> 01:41:29,240
You then carry the one, and you have 130.

2201
01:41:29,240 --> 01:41:30,380
That works great.

2202
01:41:30,380 --> 01:41:36,050
But of course, even in decimal, if you're at 999 using only three digits

2203
01:41:36,050 --> 01:41:39,440
and you try to add one more, you carry the one, you carry the one,

2204
01:41:39,440 --> 01:41:41,000
you lose the one.

2205
01:41:41,000 --> 01:41:41,840
Sorry.

2206
01:41:41,840 --> 01:41:43,110
What happens next?

2207
01:41:43,110 --> 01:41:47,030
This becomes 1, 0, 0, 0.

2208
01:41:47,030 --> 01:41:50,420
But if you only have three digits, you lose that initial one,

2209
01:41:50,420 --> 01:41:51,890
and you're left with just zero.

2210
01:41:51,890 --> 01:41:53,150
Same thing happens in binary.

2211
01:41:53,150 --> 01:41:54,690
Now if you context switch--

2212
01:41:54,690 --> 01:41:58,860
and this is, in binary, what number?

2213
01:41:58,860 --> 01:42:01,580
This is the fours place, twos place, ones.

2214
01:42:01,580 --> 01:42:02,420
So it's seven.

2215
01:42:02,420 --> 01:42:04,280
4 plus 2 plus 1, this is 7.

2216
01:42:04,280 --> 01:42:06,230
So of course, if you add 1 to 7, you'd like

2217
01:42:06,230 --> 01:42:10,010
to get 8, which would give you 1, 0, 0.

2218
01:42:10,010 --> 01:42:13,370
But if you only have three bits, three digits,

2219
01:42:13,370 --> 01:42:15,740
you're going to overflow, so to speak.

2220
01:42:15,740 --> 01:42:19,400
You're going to lose the carried one so that the value you're actually storing

2221
01:42:19,400 --> 01:42:20,600
is just zero.

2222
01:42:20,600 --> 01:42:23,600
That's why if I count high enough with an integer in a program,

2223
01:42:23,600 --> 01:42:28,010
once I hit the billions, eventually that one has gotten carried too far.

2224
01:42:28,010 --> 01:42:30,620
It's only 32 bits large.

2225
01:42:30,620 --> 01:42:33,530
We can't fit a number even bigger than that.

2226
01:42:33,530 --> 01:42:35,240
That's what's called integer overflow.

2227
01:42:35,240 --> 01:42:38,340
And if you ever heard of the Y2K problem,

2228
01:42:38,340 --> 01:42:43,340
this was a horrible, very simple problem that humans created for themselves

2229
01:42:43,340 --> 01:42:46,960
back in the day when computers were invented in the mid 1900s, really.

2230
01:42:46,960 --> 01:42:50,410
Humans decided to save space, very reasonable, because space was expensive

2231
01:42:50,410 --> 01:42:51,260
early on.

2232
01:42:51,260 --> 01:42:58,452
So instead of storing the year as 1999 or 1970 for 1970, what did they do?

2233
01:42:58,452 --> 01:43:00,160
Yeah, they just stored two digits, right?

2234
01:43:00,160 --> 01:43:01,480
Like oh my god, we're not going to be using

2235
01:43:01,480 --> 01:43:03,190
these computers 50 years from now.

2236
01:43:03,190 --> 01:43:04,570
Let's just store two digits.

2237
01:43:04,570 --> 01:43:06,573
Unfortunately, that was not the case.

2238
01:43:06,573 --> 01:43:09,490
And there was a lot of code out there and a lot of computers out there

2239
01:43:09,490 --> 01:43:12,040
that were still running in 1999.

2240
01:43:12,040 --> 01:43:17,080
But if you're only storing two digits and you plus plus one value

2241
01:43:17,080 --> 01:43:20,020
to the year, what you'd like to be 2000 was

2242
01:43:20,020 --> 01:43:25,120
misinterpreted in lots of systems as 1900, at which point stuff broke.

2243
01:43:25,120 --> 01:43:27,580
And the world spent millions of dollars, presumably,

2244
01:43:27,580 --> 01:43:30,160
having programmers start using more memory

2245
01:43:30,160 --> 01:43:32,650
to fix this problem in anticipation of what was called

2246
01:43:32,650 --> 01:43:35,860
Y2K to get ahead of this problem.

2247
01:43:35,860 --> 01:43:38,890
And in the end, the world did not end in 1999, which was great.

2248
01:43:38,890 --> 01:43:40,930
But it was a very real and a very expensive

2249
01:43:40,930 --> 01:43:43,570
problem because of that lack of foresight.

2250
01:43:43,570 --> 01:43:46,400
It turns out that there's other examples of this, as well.

2251
01:43:46,400 --> 01:43:50,980
So this one, as an example, will just about end on Boeing 787.

2252
01:43:50,980 --> 01:43:53,737
So Boeing has not been getting great press recently.

2253
01:43:53,737 --> 01:43:55,570
And even a few years ago, did they have what

2254
01:43:55,570 --> 01:43:58,150
appeared to be a very straightforward software bug.

2255
01:43:58,150 --> 01:44:01,300
Pictured here is a model 787 airplane.

2256
01:44:01,300 --> 01:44:04,210
And the article from The New York Times explained as follows--

2257
01:44:04,210 --> 01:44:09,130
"A model 787 airplane that has been powered continuously for 248 days

2258
01:44:09,130 --> 01:44:12,070
can lose all alternating current, electrical power,

2259
01:44:12,070 --> 01:44:14,380
due to the generator control units simultaneously

2260
01:44:14,380 --> 01:44:15,940
going into failsafe mode.

2261
01:44:15,940 --> 01:44:17,920
This condition is caused by a software counter

2262
01:44:17,920 --> 01:44:20,920
internal to the counters that will overflow

2263
01:44:20,920 --> 01:44:24,550
after 248 days of continuous power.

2264
01:44:24,550 --> 01:44:26,920
Boeing, according to the statement, is in the process

2265
01:44:26,920 --> 01:44:30,550
of developing a software upgrade that will remedy the safe condition."

2266
01:44:30,550 --> 01:44:31,578
So what does this mean?

2267
01:44:31,578 --> 01:44:33,370
Well, if you actually dig into the numbers,

2268
01:44:33,370 --> 01:44:41,560
248 days is roughly the value of 2 raised to the 32nd power,

2269
01:44:41,560 --> 01:44:44,467
give or take, in 1/100 of a second.

2270
01:44:44,467 --> 01:44:47,050
Which is to say that Boeing, in some crucial piece of hardware

2271
01:44:47,050 --> 01:44:51,640
in their 787 actual airplanes, were using integers

2272
01:44:51,640 --> 01:44:56,140
that were counting so high that after the 248th day of the airplane being

2273
01:44:56,140 --> 01:44:59,230
powered on would actually overflow, the result of which

2274
01:44:59,230 --> 01:45:01,900
is that the power in the plane could cut off entirely.

2275
01:45:01,900 --> 01:45:05,140
And so the solution, if you read through all the technical speak and jargon

2276
01:45:05,140 --> 01:45:09,970
there, is they literally had to reboot their planes every 248 days

2277
01:45:09,970 --> 01:45:13,270
in order to reset that variable back to zero.

2278
01:45:13,270 --> 01:45:16,870
This happens even today in the real world with issues like that.

2279
01:45:16,870 --> 01:45:19,540
And so you'll begin to notice these trends anytime people talk

2280
01:45:19,540 --> 01:45:21,760
about hardware mistakes or software mistakes.

2281
01:45:21,760 --> 01:45:24,700
Quite honestly, can you typically reduce them to problems

2282
01:45:24,700 --> 01:45:26,690
you yourselves have run into.

2283
01:45:26,690 --> 01:45:30,310
And let me go ahead and tease just a couple of things, a couple of features

2284
01:45:30,310 --> 01:45:31,390
now ahead.

2285
01:45:31,390 --> 01:45:34,450
It turns out that now that we have the ability to write code,

2286
01:45:34,450 --> 01:45:37,630
our programs, of course, can do any number of things, saying or printing

2287
01:45:37,630 --> 01:45:38,657
things on the screen.

2288
01:45:38,657 --> 01:45:40,990
We, of course, might do something like this in a program

2289
01:45:40,990 --> 01:45:43,900
we might call figlet, which actually comes with some systems.

2290
01:45:43,900 --> 01:45:46,630
And I can say something like, this is CS50,

2291
01:45:46,630 --> 01:45:49,540
and actually print it out in what's called ASCII art using characters

2292
01:45:49,540 --> 01:45:51,707
on the screen that kind of sort of look like letters

2293
01:45:51,707 --> 01:45:55,520
and create fairly beautiful, if old school, art on the screen.

2294
01:45:55,520 --> 01:45:58,210
Of course, if you write code and you understand

2295
01:45:58,210 --> 01:46:01,450
not only how numbers and letters are represented, but also sounds,

2296
01:46:01,450 --> 01:46:04,270
per our chat last week, you can do even more powerful things,

2297
01:46:04,270 --> 01:46:08,900
such as this note, which we will literally end on today.

2298
01:46:08,900 --> 01:46:10,217
SPEAKER 2: This is CS50.

2299
01:46:10,217 --> 01:46:11,550
DAVID MALAN: That's it for CS50.

2300
01:46:11,550 --> 01:46:13,210
We will see you next week.

2301
01:46:13,210 --> 01:46:15,060
[APPLAUSE]

