0
00: 00: 00.000 -> 00: 01: 22.668


1
00: 01: 22,668 -> 00: 01: 24.080
DAVID MALAN: Muito bem.

2
00: 01: 24,080 -> 00: 01: 28.193
Este é o CS50, e hoje olhamos cada vez mais por baixo do capô, por assim dizer,

3
00: 01: 28,193 -> 00: 01: 30.860
da programação, que temos feito nas últimas semanas,

4
00: 01: 30,860 -> 00: 01: 32.015
e de C em particular.

5
00: 01: 32,015 -> 00: 01: 33.890
E, de fato, vamos tentar nos concentrar hoje

6
00: 01: 33,890 -> 00: 01: 37.410
além de algumas novas técnicas de programação, realmente nos primeiros princípios,

7
00: 01: 37,410 -> 00: 01: 40.100
de modo que o que você tem visto nas últimas semanas

8
00: 01: 40,100 -> 00: 01: 42.720
já não se parece tanto com mágica.

9
00: 01: 42,720 -> 00: 01: 44.920
Se você está digitando esses encantamentos mágicos

10
00: 01: 44,920 -> 00: 01: 46.670
e você não tem certeza de por que as coisas funcionam,

11
00: 01: 46,670 -> 00: 01: 49.250
saiba que você vai entender e apreciar

12
00: 01: 49,250 -> 00: 01: 52.788
ainda mais com a prática e com a aplicação dessas idéias, que

13
00: 01: 52,788 -> 00: 01: 53.580
é o que você está fazendo.

14
00: 01: 53,580 -> 00: 01: 56.750
Mas hoje, vamos voltar aos primeiros princípios, mais ou menos na matéria

15
00: 01: 56,750 -> 00: 01: 59.300
da semana 0, para ter certeza de que você entendeu

16
00: 01: 59,300 -> 00: 02: 02.960
que o que estamos fazendo agora na semana 2 é um pouco diferente do que fizemos

17
00: 02: 02,960 -> 00: 02: 04.040
na semana 0.

18
00: 02: 04,040 -> 00: 02: 07.164
Então, na verdade, vamos dar uma olhada em um dos primeiros programas que vimos em C,

19
00: 02: 07,164 -> 00: 02: 08.789
que era um pouco mais ou menos assim.

20
00: 02: 08,789 -> 00: 02: 10.430
Este é o nosso código-fonte, por assim dizer.

21
00: 02: 10,430 -> 00: 02: 13.130
Houve algumas características salientes da semana passada

22
00: 02: 13,130 -> 00: 02: 15.830
isso se encaixou com a primeira semana, semana 0.

23
00: 02: 15,830 -> 00: 02: 18.740
E era essa coisa chamada main, que é apenas a função principal.

24
00: 02: 18,740 -> 00: 02: 20.490
Este é o principal ponto de entrada para seu programa.

25
00: 02: 20,490 -> 00: 02: 23.210
É o equivalente ao Scratch quando a bandeira verde é clicada.

26
00: 02: 23,210 -> 00: 02: 25.880
Este é claro um exemplo de outra função,

27
00: 02: 25,880 -> 00: 02: 28.730
uma que vem com C que permite imprimir na tela.

28
00: 02: 28,730 -> 00: 02: 31.340
Esta pode receber entradas, pelo menos uma entrada aqui,

29
00: 02: 31,340 -> 00: 02: 35.720
que normalmente é uma string entre aspas duplas, como a mensagem "olá, mundo".

30
00: 02: 35,720 -> 00: 02: 38.900
Mas é claro, para usar printf em primeiro lugar,

31
00: 02: 38,900 -> 00: 02: 40.910
você precisava dessa coisa aqui.

32
00: 02: 40,910 -> 00: 02: 45.650
E o Standard io.h representa o que, como você o entende agora?

33
00: 02: 45,650 -> 00: 02: 50.320
Alguma ideia do que é o padrão io.h?

34
00: 02: 50,320 -> 00: 02: 50.820
Sim?

35
00: 02: 50,820 -> 00: 02: 54.648
PÚBLICO: Uma biblioteca sobre como [INAUDÍVEL].

36
00: 02: 54,648 -> 00: 02: 56.690
DAVID MALAN: Sim, é uma manifestação do que é

37
00: 02: 56,690 -> 00: 02: 59.910
chamado de biblioteca, código que outra pessoa escreveu anos atrás.

38
00: 02: 59,910 -> 00: 03: 02.780
Especificamente, o Standard io.h é um arquivo de cabeçalho.

39
00: 03: 02,780 -> 00: 03: 05.090
É um arquivo escrito em C, mas com uma extensão de arquivo

40
00: 03: 05,090 -> 00: 03: 10.070
terminando no ponto h que, entre outras coisas, declara que possui uma prototipação,
41
00: 03: 10,070 -> 00: 03: 13.290
por assim dizer, para printf e para Clang, quando você está compilando seu código,

42
00: 03: 13,290 -> 00: 03: 15.230
saberá o que printf realmente é.

43
00: 03: 15,230 -> 00: 03: 17.100
E, claro, essa coisinha aqui atrás,

44
00: 03: 17,100 -> 00: 03: 20.460
você provavelmente agora adquiriu o hábito de usar \n que é nova linha.

45
00: 03: 20,460 -> 00: 03: 22.460
E isso força o cursor a ir para a próxima linha.

46
00: 03: 22,460 -> 00: 03: 26.300
Essas foram algumas das características mais feias do código na semana passada,

47
00: 03: 26,300 -> 00: 03: 29.000
e vamos separar o int e o vazio e algumas outras coisas

48
00: 03: 29.000 -> 00: 03: 31.140
ao longo de hoje e além.

49
00: 03: 31,140 -> 00: 03: 35.030
Então, quando você compila seu código com Clang, hello.c,

50
00: 03: 35,030 -> 00: 03: 38.780
e então executa aquele programa, ./a.out, que você provavelmente não fez

51
00: 03: 38,780 -> 00: 03: 42.080
por conta própria, porque lhe oferecemos uma maneira mais simples de fazer isso,

52
00: 03: 42,080 -> 00: 03: 45.650
esse processo consistia em criar um arquivo contendo zeros e uns que

53
00: 03: 45,650 -> 00: 03: 48.410
o computador entende, chamado a.out, que você pode executar.

54
00: 03: 48,410 -> 00: 03: 50.780
Claro, a.out é um nome muito estúpido para um programa.

55
00: 03: 50,780 -> 00: 03: 53.030
É pouco descritivo, embora seja o padrão.

56
00: 03: 53,030 -> 00: 03: 55.880
Então, o próximo programa que escrevemos e compilamos,

57
00: 03: 55,880 -> 00: 04: 00.290
usamos -o hello, que é o chamado argumento da linha de comando do Clang.

58
00: 04: 00,290 -> 00: 04: 02.480
É como uma opção que permite que você

59
00: 04: 02,480 -> 00: 04: 04.752
especifique o nome do arquivo de saída.

60
00: 04: 04,752 -> 00: 04: 06.710
Então você fez isso na semana passada com o conjunto de problemas,

61
00: 04: 06,710 -> 00: 04: 09.020
com alguns programas que você mesmo escreveu.

62
00: 04: 09,020 -> 00: 04: 13.376
Mas o que realmente acontece quando você compila seu código por meio desse processo?
63
00: 04: 13,376 -> 00: 04: 16.459
Bem, acontece que, se tornarmos este programa um pouco mais interessante,

64
00: 04: 16.459 -> 00: 04: 19.190
isso se torna ainda mais importante com códigos como este.

65
00: 04: 19,190 -> 00: 04: 20.899
Agora adicionei algumas linhas de código.

66
00: 04: 20,899 -> 00: 04: 24.440
CS50.h, que é representativo da biblioteca CS50.

67
00: 04: 24,440 -> 00: 04: 28.310
Novamente, o código que outras pessoas escreveram, neste caso nossa equipe alguns anos atrás,

68
00: 04: 28,310 -> 00: 04: 33.020
que declara que tem protótipos para funções em uma linha

69
00: 04: 33,020 -> 00: 04: 36.590
como GetString, sendo assim você pode usar mais recursos do que o C oferece por padrão.

70
00: 04: 36,590 -> 00: 04: 39.840
E tem coisas como a própria String, um tipo de dado.

71
00: 04: 39,840 -> 00: 04: 41.840
Portanto, GetString é declarado nesse arquivo.

72
00: 04: 41,840 -> 00: 04: 45.260
Name é, obviamente, uma variável na qual armazenamos meu nome na semana passada.

73
00: 04: 45,260 -> 00: 04: 47.990
String é o tipo de variável em que armazenamos um nome.

74
00: 04: 47,990 -> 00: 04: 51.680
E tudo isso é enviado olá vírgula alguma coisa,

75
00: 04: 51,680 -> 00: 04: 53.990
onde o %S de relembrem era um espaço reservado,

76
00: 04: 53,990 -> 00: 04: 58.130
name é a variável que conectamos a esse código de formato e, em seguida, tudo isso

77
00: 04: 58,130 -> 00: 05: 01.700
é possível por causa de CS50.h, que declara string e também

78
00: 05: 01,700 -> 00: 05: 03.120
nos dá GetString.

79
00: 05: 03,120 -> 00: 05: 05.453
Esse é um paradigma que, no momento, é específico do CS50,

80
00: 05: 05,453 -> 00: 05: 07.787
mas é representativo de qualquer número de outras funções

81
00: 05: 07,787 -> 00: 05: 10.220
vamos começar a usar hoje e nas próximas semanas.

82
00: 05: 10,220 -> 00: 05: 12.780
O processo agora será o mesmo.

83
00: 05: 12,780 -> 00: 05: 17.327
No entanto, quando você compilou esse programa que usou a biblioteca CS50,

84
00: 05: 17,327 -> 00: 05: 20.160
você deve se lembrar e pode ter ficado preso nisso na semana passada

85
00: 05: 20,160 -> 00: 05: 24.365
se você usou o Clang e não outro programa, você precisa deste -lcs50,

86
00: 05: 24,365 -> 00: 05: 26.510
e você precisa disso no final porque.

87
00: 05: 26,510 -> 00: 05: 27.905
É assim que Clang espera.

88
00: 05: 27,905 -> 00: 05: 29.780
Esta é uma bandeira especial que vamos deixar de lado

89
00: 05: 29,780 -> 00: 05: 34.290
em apenas alguns minutos, um argumento para o Clang que o instrui como se conectar,

90
00: 05: 34,290 -> 00: 05: 38.180
por assim dizer, ligue todos os zeros e uns da biblioteca do CS50.

91
00: 05: 38,180 -> 00: 05: 40.108
Mas veremos isso em apenas um momento.

92
00: 05: 40,108 -> 00: 05: 41.900
Claro, é assim que você provavelmente deveria

93
00: 05: 41,900 -> 00: 05: 43.480
compilar seu código aqui em diante.

94
00: 05: 43,480 -> 00: 05: 46.700
É super simples, além de automatizar tudo o que acabamos de

95
00: 05: 46,700 -> 00: 05: 49.310
ver mais pedantemente, passo a passo.

96
00: 05: 49,310 -> 00: 05: 51.870
Então estamos compilando nosso código desde a semana passada,

97
00: 05: 51,870 -> 00: 05: 54.620
e vamos continuar fazendo isso nas próximas semanas, até -

98
00: 05: 54,620 -> 00: 05: 56.330
spoiler - chegamos ao Python, e você não

99
00: 05: 56,330 -> 00: 05: 57.860
vai ter que compilar mais nada.

100
00: 05: 57,860 -> 00: 05: 59.860
Isso vai acontecer automaticamente para você.

101
00: 05: 59,860 -> 00: 06: 03.710
Mas até então, a compilação é, na verdade, uma simplificação exagerada

102
00: 06: 03,710 -> 00: 06: 05.630
do que aconteceu na semana passada.

103
00: 06: 05,630 -> 00: 06: 09.290
Acontece que há quatro etapas distintas que todos vocês

104
00: 06: 09,290 -> 00: 06: 12.410
estavam induzindo executando o Make ou mesmo executando

105
00: 06: 12,410 -> 00: 06: 14.180
Clang manualmente no prompt de comando.

106
00: 06: 14,180 -> 00: 06: 16.460
E só para que, novamente, possamos entender

107
00: 06: 16,460 -> 00: 06: 18.930
o que você está fazendo quando executa esses comandos,

108
00: 06: 18,930 -> 00: 06: 21.380
vamos aos primeiros princípios, entenda essas quatro etapas,

109
00: 06: 21,380 -> 00: 06: 25.170
mas então continuaremos como na semana 0 e estipularemos, OK, entendi.

110
00: 06: 25,170 -> 00: 06: 27.690
Não preciso pensar neste nível baixo depois de hoje.

111
00: 06: 27,690 -> 00: 06: 30.925
Mas espero que você compreenda de baixo para cima essas quatro etapas.

112
00: 06: 30,925 -> 00: 06: 32.550
Então, vamos dar uma olhada no pré-processamento.

113
00: 06: 32,550 -> 00: 06: 35.580
Este é um termo da arte em programação que se refere ao seguinte.

114
00: 06: 35,580 -> 00: 06: 38.260
Quando você tem um código-fonte parecido com este,

115
00: 06: 38,260 -> 00: 06: 40.280
você tem algumas linhas no topo que

116
00: 06: 40,280 -> 00: 06: 43.470
diz: # include dois arquivos, dois arquivos de biblioteca.

117
00: 06: 43,470 -> 00: 06: 47.040
Bem, quando você realmente executa o Clang ou induz

118
00: 06: 47,040 -> 00: 06: 50.610
Clang para executar usando Make, o que acontece são essas linhas

119
00: 06: 50,610 -> 00: 06: 54.330
que começam com o símbolo "hash" são, na verdade, meio que substituídos

120
00: 06: 54,330 -> 00: 06: 56.920
com o conteúdo real desse arquivo.

121
00: 06: 56,920 -> 00: 07: 00.240
Então, em vez de este código permanecer, inclua CS50.h,

122
00: 07: 00,240 -> 00: 07: 03.600
literalmente o que o Clang faz é entrar no CS50.h,

123
00: 07: 03,600 -> 00: 07: 06.990
pegue as linhas de código relevantes e basicamente copie e cole-as

124
00: 07: 06,990 -> 00: 07: 10.380
em seu arquivo, hello.c ou qualquer que seja seu nome.

125
00: 07: 10,380 -> 00: 07: 12.870
A próxima linha aqui, standard io.h da mesma forma

126
00: 07: 12,870 -> 00: 07: 17.460
é substituído por quaisquer linhas de código que estejam nesse arquivo, o standard io.h.

127
00: 07: 17,460 -> 00: 07: 21.030
Não importa para nós o que eles são, mas eles se parecem um pouco com isso,

128
00: 07: 21,030 -> 00: 07: 22.740
embora eu tenha simplificado no slide aqui.

129
00: 07: 22,740 -> 00: 07: 25.573
E há um monte de outras coisas acima e abaixo dessas linhas

130
00: 07: 25,573 -> 00: 07: 27.330
certamente nesses arquivos.

131
00: 07: 27,330 -> 00: 07: 28.830
O que acontece depois disso?

132
00: 07: 28,830 -> 00: 07: 31.110
Bem, compilando, mesmo que esta seja a palavra

133
00: 07: 31,110 -> 00: 07: 33.630
usamos e continuaremos usando para descrever

134
00: 07: 33,630 -> 00: 07: 38.070
transformar o código-fonte em código de máquina, na verdade é uma etapa mais precisa do que isso.

135
00: 07: 38,070 -> 00: 07: 40.980
Quando um computador - quando um programa é compilado,

136
00: 07: 40,980 -> 00: 07: 44.340
tecnicamente começa assim depois de ter sido pré-processado - novamente,

137
00: 07: 44,340 -> 00: 07: 45.510
essa foi a etapa 1.

138
00: 07: 45,510 -> 00: 07: 47.730
Este código é então convertido por um compilador,

139
00: 07: 47,730 -> 00: 07: 51.950
como Clang, para algo que parece ainda mais assustador do que C. Isso é algo

140
00: 07: 51,950 -> 00: 07: 53.700
chamado de código assembly, e você pode realmente

141
00: 07: 53.700 -> 00: 07: 55.530
receber sequências completas de código assembly.

142
00: 07: 55,530 -> 00: 07: 58.740
E não faz muitas décadas que os humanos estavam manualmente

143
00: 07: 58,740 -> 00: 08: 02.400
programando códigos parecidos com este, então não eram exatamente zeros e uns.

144
00: 08: 02,400 -> 00: 08: 04.560
Mas meu Deus, C está parecendo muito bom agora,

145
00: 08: 04,560 -> 00: 08: 06.810
se esta fosse a linguagem alternativa naquela época.

146
00: 08: 06,810 -> 00: 08: 08.730
Portanto, este é um exemplo de linguagem assembly.

147
00: 08: 08,730 -> 00: 08: 11.460
Mas mesmo que pareça bastante misteriosa,

148
00: 08: 11,460 -> 00: 08: 13.680
se eu destacar em amarelo algumas características,

149
00: 08: 13,680 -> 00: 08: 15.390
há algumas coisas que são familiares.

150
00: 08: 15,390 -> 00: 08: 16.520
O principal está aqui.

151
00: 08: 16,520 -> 00: 08: 17.730
get_string está aqui embaixo.

152
00: 08: 17,730 -> 00: 08: 19.290
Printf está aqui embaixo.

153
00: 08: 19,290 -> 00: 08: 23.760
Então, quando seu código é compilado pelo Clang, ele parte do seu código-fonte em C

154
00: 08: 23,760 -> 00: 08: 27.480
para este passo intermediário, código assembly, e isso está

155
00: 08: 27,480 -> 00: 08: 30.960
um pouco mais perto do que a CPU, o cérebro do seu computador,

156
00: 08: 30,960 -> 00: 08: 31.980
realmente entende.

157
00: 08: 31,980 -> 00: 08: 35.070
Na verdade, agora destacados em amarelo estão as chamadas instruções.

158
00: 08: 35,070 -> 00: 08: 38.070
Então, se você já ouviu falar da Intel ou AMD ou de um grupo de empresas

159
00: 08: 38,070 -> 00: 08: 40.500
que fazem CPUs, unidades de processamento central,

160
00: 08: 40,500 -> 00: 08: 43.679
o cérebro de um computador, o que essas CPUs entendem

161
00: 08: 43,679 -> 00: 08: 47.310
são essas operações de nível muito, muito baixo como esta.

162
00: 08: 47,310 -> 00: 08: 50.520
E isso se relaciona a mover coisas na memória e copiar coisas

163
00: 08: 50,520 -> 00: 08: 52.770
e lendo e colocando coisas na tela.

164
00: 08: 52,770 -> 00: 08: 55.227
Mas muito mais misteriosamente do que C.

165
00: 08: 55,227 -> 00: 08: 57.060
Mas, novamente, não precisamos nos preocupar com isso,

166
00: 08: 57,060 -> 00: 08: 59.710
porque o Clang faz tudo isso por nós.

167
00: 08: 59,710 -> 00: 09: 02.040
Mas uma vez que você está naquele ponto de ter o código assembly,

168
00: 09: 02,040 -> 00: 09: 04.582
você precisa fazer com que ele codifique os zeros e uns reais.

169
00: 09: 04,582 -> 00: 09: 07.350
E é aí que o Clang faz o que chamamos de montagem.

170
00: 09: 07,350 -> 00: 09: 10.950
Há outra parte do Clang, como algumas funcionalidades integradas, que

171
00: 09: 10.950 -> 00: 09: 13.470
pega como entrada esse código assembly e o converte

172
00: 09: 13,470 -> 00: 09: 17.530
daqui para os zeros e uns sobre os quais falamos na semana 0.

173
00: 09: 17.530 -> 00: 09: 21.510
Mas para um programa como o hello.c, que envolvia alguns arquivos diferentes.

174
00: 09: 21,510 -> 00: 09: 25.470
Por exemplo, este código envolveu novamente o meu código que escrevemos na semana passada.

175
00: 09: 25,470 -> 00: 09: 28.650
Envolve a biblioteca CS50, que a equipe escreveu anos atrás.

176
00: 09: 28,650 -> 00: 09: 30.390
E envolve o standard io.h.

177
00: 09: 30,390 -> 00: 09: 31.650
Que é mais um arquivo.

178
00: 09: 31,650 -> 00: 09: 36.000
São três arquivos diferentes que o Clang, francamente, precisa compilar para você.

179
00: 09: 36.000 -> 00: 09: 39.630
Seria muito entediante se tivéssemos que executar o Clang três vezes

180
00: 09: 39,630 -> 00: 09: 41.310
para fazer toda essa compilação.

181
00: 09: 41,310 -> 00: 09: 42.300
Felizmente, não precisamos.

182
00: 09: 42,300 -> 00: 09: 44.020
Tudo acontece automaticamente.

183
00: 09: 44,020 -> 00: 09: 48.420
Portanto, a última etapa na compilação de um programa depois que ele foi pré-processado,

184
00: 09: 48,420 -> 00: 09: 51.300
depois de compilado, depois de montado,

185
00: 09: 51,300 -> 00: 09: 54.960
é combinar todos os zeros e uns dos arquivos envolvidos

186
00: 09: 54,960 -> 00: 09: 58.590
em um grande arquivo, como Hello ou a.out.

187
00: 09: 58,590 -> 00: 10: 03.360
Então, se hello.c começou como código-fonte, como fez CS50.C, em algum lugar do computador

188
00: 10: 03,360 -> 00: 10: 07.410
disco rígido, assim como Standard IO.C, em algum lugar do disco rígido do computador,

189
00: 10: 07,410 -> 00: 10: 12.480
Acontece que o printf está na verdade em seu próprio arquivo no Standard IO.

190
00: 10: 12,480 -> 00: 10: 13.380
a biblioteca.

191
00: 10: 13,380 -> 00: 10: 16.780
Mas esses são os três arquivos envolvidos no programa que acabei de descrever.

192
00: 10: 16,780 -> 00: 10: 19.020
Então, uma vez que realmente vamos em frente e montamos este,

193
00: 10: 19,020 -> 00: 10: 20.812
torna-se um monte de zeros e uns.

194
00: 10: 20,812 -> 00: 10: 23.062
Montamos este aqui, um monte de zeros e uns.

195
00: 10: 23,062 -> 00: 10: 24.840
Este aqui, um monte de zeros e uns.

196
00: 10: 24,840 -> 00: 10: 26.880
São três arquivos separados que então

197
00: 10: 26,880 -> 00: 10: 32.640
são ligados, meio que misturados, em um grande arquivo chamado Hello,

198
00: 10: 32,640 -> 00: 10: 34.480
ou chamado a.out.

199
00: 10: 34,480 -> 00: 10: 36.512
E meu Deus, como isto traz muita complexidade!

200
00: 10: 36,512 -> 00: 10: 38.220
Mas é isso que os humanos vêm construindo

201
00: 10: 38,220 -> 00: 10: 41.090
e desenvolvendo nas últimas décadas quando se trata de escrever software.

202
00: 10: 41,090 -> 00: 10: 43.320
Antigamente, começava como zeros e uns.

203
00: 10: 43,320 -> 00: 10: 44.310
Isso não foi divertido.

204
00: 10: 44,310 -> 00: 10: 46.530
Linguagem assembly, por mais assustador que pareça,

205
00: 10: 46,530 -> 00: 10: 50.010
era na verdade um pouco mais fácil, um pouco mais acessível para humanos escreverem.

206
00: 10: 50,010 -> 00: 10: 51.810
Mas eventualmente nós, humanos, nos cansamos disso,

207
00: 10: 51,810 -> 00: 10: 56.940
e assim nasceram linguagens como C e C ++ e Python e PHP e Ruby

208
00: 10: 56,940 -> 00: 10: 57.790
e outros.

209
00: 10: 57,790 -> 00: 11: 00.640
Tem sido uma evolução das línguas ao longo do caminho.

210
00: 11: 00,640 -> 00: 11: 04.140
Portanto, agora podemos apenas abstrair na compilação.

211
00: 11: 04,140 -> 00: 11: 07.337
Quando você compila seu código, todas essas coisas acontecem.

212
00: 11: 07,337 -> 00: 11: 09.420
Mas tudo o que realmente importa no final das contas

213
00: 11: 09,420 -> 00: 11: 12.360
é a entrada, seu código-fonte, a saída em código de máquina.

214
00: 11: 12,360 -> 00: 11: 14.400
Mas essas são as várias etapas acontecendo.

215
00: 11: 14,400 -> 00: 11: 16.858
E se você ver comandos de aparência misteriosa na tela,

216
00: 11: 16,858 -> 00: 11: 20.510
pode estar relacionado, de fato, a algumas dessas etapas intermediárias.

217
00: 11: 20,510 -> 00: 11: 24.920
Tudo bem, qualquer dúvida sobre o que é compilação ou pré-processamento,

218
00: 11: 24,920 -> 00: 11: 28.310
compilar, montar ou vincular?

219
00: 11: 28,310 -> 00: 11: 31.630
Nada mesmo?

220
00: 11: 31,630 -> 00: 11: 32.660
Tudo certo.

221
00: 11: 32,660 -> 00: 11: 36.440
Além disso, tenho certeza que você encontrou agora, depois de apenas um

222
00: 11: 36,440 -> 00: 11: 38.310
semana, bugs em seu software.

223
00: 11: 38,310 -> 00: 11: 41.560
E, de fato, uma das maiores habilidades que você pode adquirir nas aulas de programação

224
00: 11: 41,560 -> 00: 11: 45.860
não é apenas como escrever código, mas como depurar código, provavelmente o seu próprio.

225
00: 11: 45,860 -> 00: 11: 48.560
E se você já se perguntou de onde vem essa frase,

226
00: 11: 48,560 -> 00: 11: 52.240
essa noção de depuração, então isso é realmente parte da mitologia.

227
00: 11: 52,240 -> 00: 11: 55.550
Este é, na verdade, um caderno mantido por Grace Hopper,

228
00: 11: 55,550 -> 00: 11: 59.600
um cientista da computação muito famoso, trabalhando anos atrás com alguns colegas

229
00: 11: 59,600 -> 00: 12: 01.142
no que foi chamado de sistema Mark 2.
230
00: 12: 01,142 -> 00: 12: 03.350
Se você já andou pelo Harvard Science Center,

231
00: 12: 03,350 -> 00: 12: 06.470
há uma grande parte de uma máquina no andar térreo do Centro de Ciências.

232
00: 12: 06,470 -> 00: 12: 08.230
Esse é o Mark 1, o precursor.

233
00: 12: 08,230 -> 00: 12: 10.490
Bem, o Mark 2 em algum momento foi descoberto

234
00: 12: 10,490 -> 00: 12: 14.180
como se tivesse literalmente um bug dentro dele, o que estava causando um problema.

235
00: 12: 14,180 -> 00: 12: 15.320
Uma espécie de mariposa.

236
00: 12: 15,320 -> 00: 12: 18.140
E Grace Hopper realmente fez esse registro aqui, se aumentarmos o zoom,

237
00: 12: 18,140 -> 00: 12: 20.817
o primeiro caso real de bug sendo encontrado.

238
00: 12: 20,817 -> 00: 12: 23.150
E mesmo que outras pessoas tenham usado a expressão bug

239
00: 12: 23,150 -> 00: 12: 26.030
antes para se referir a erros ou problemas em sistemas,

240
00: 12: 26,030 -> 00: 12: 30.070
esse é realmente o tipo de tradição que o pessoal da ciência da computação relembra.

241
00: 12: 30,070 -> 00: 12: 34.730
Portanto, bugs são apenas erros em programas, coisas que você certamente não pretendia.
242
00: 12: 34,730 -> 00: 12: 37.430
E vamos considerar hoje como podemos empodera-lo,

243
00: 12: 37,430 -> 00: 12: 41.420
muito mais do que na semana passada, para resolver seus próprios problemas

244
00: 12: 41,420 -> 00: 12: 44.083
e depurar seu software.

245
00: 12: 44,083 -> 00: 12: 46.250
Então, quais são os mecanismos pelos quais podemos fazer isso?

246
00: 12: 46,250 -> 00: 12: 49.682
Portanto, o Help50 é uma das ferramentas que o próprio CS50 oferece.

247
00: 12: 49,682 -> 00: 12: 51.890
E vamos dar uma olhada em um exemplo rápido

248
00: 12: 51,890 -> 00: 12: 54.570
que nos permite usar esta ferramenta.

249
00: 12: 54,570 -> 00: 12: 57.198
Vou prosseguir e abrir meu CS50 Sandbox aqui.

250
00: 12: 57,198 -> 00: 12: 59.240
Vou prosseguir e criar um programa chamado

251
00: 12: 59,240 -> 00: 13: 03.360
Buggy 0.C, sabendo de antemão que vou cometer um erro aqui.

252
00: 13: 03,360 -> 00: 13: 07.560
E vou prosseguir e fazer main void, assim como todos os meus programas começam.

253
00: 13: 07,560 -> 00: 13: 12.740
E eu vou prosseguir e fazer printf hello world barra invertida n ponto-e-vírgula.
254
00: 13: 12,740 -> 00: 13: 14.720
Tudo bem, então esse é o buggy 0.c.

255
00: 13: 14,720 -> 00: 13: 16.970
E, novamente, embora eu pudesse executar os comandos do Clang,

256
00: 13: 16,970 -> 00: 13: 19.220
daqui em diante, vou apenas executar coisas como Make.

257
00: 13: 19,220 -> 00: 13: 21.170
Então faça buggy 0 Enter.

258
00: 13: 21,170 -> 00: 13: 23.190
E tudo bem, aqui está o primeiro dos meus erros.

259
00: 13: 23,190 -> 00: 13: 25.520
Deixe-me aumentar o tamanho da janela do meu terminal,

260
00: 13: 25,520 -> 00: 13: 29.750
focando como sempre, sempre no primeiro erro, que é o que está em vermelho aqui.

261
00: 13: 29,750 -> 00: 13: 34.290
Declarando implicitamente a função de biblioteca printf com o tipo int const char *w,

262
00: 13: 34,290 -> 00: 13: 34.790
erro--

263
00: 13: 34,790 -> 00: 13: 35.957
Quer dizer, há muito aí.

264
00: 13: 35,957 -> 00: 13: 39.560
Há muito para digerir, embora agora você possa reconhecer pelo menos alguns

265
00: 13: 39,560 -> 00: 13: 40.370
desses símbolos.
266
00: 13: 40,370 -> 00: 13: 43.700
Mas suponha que você não faça isso e queira ajuda para entender esta mensagem.

267
00: 13: 43,700 -> 00: 13: 46.700
Além de pedir ajuda a um humano, alguém que é mais familiar,

268
00: 13: 46,700 -> 00: 13: 48.080
em vez disso, você pode fazer isso.

269
00: 13: 48,080 -> 00: 13: 52.760
Execute novamente o mesmo comando de antes, mas prefixe-o com o help50 e pressione Enter.

270
00: 13: 52,760 -> 00: 13: 55.730
E o que vai acontecer é que vamos fazer de novo para você.

271
00: 13: 55,730 -> 00: 13: 59.340
Veremos o resultado do make, por mais enigmático que possa ser para você,

272
00: 13: 59,340 -> 00: 14: 03.500
execute-o em nosso próprio software Help50 e procure as mensagens que entendemos.

273
00: 14: 03,500 -> 00: 14: 07.157
E se reconhecermos uma das mensagens de erro em sua saída,

274
00: 14: 07,157 -> 00: 14: 08.990
vamos destacar em amarelo uma mensagem

275
00: 14: 08,990 -> 00: 14: 12.620
como este - buggy 0, ponto C3, dois pontos 5, erro,

276
00: 14: 12,620 -> 00: 14: 16.730
declarando implicitamente a função de biblioteca printf com type, dot, dot, dot.

277
00: 14: 16,730 -> 00: 14: 18.803
Você se esqueceu de incluir Io ponto h padrão

278
00: 14: 18,803 -> 00: 14: 20.970
e com printf é declarado no topo do seu arquivo.

279
00: 14: 20,970 -> 00: 14: 23.540
Então essa é, neste caso, a resposta exata.

280
00: 14: 23,540 -> 00: 14: 25.788
E agora, você verá que não apenas

281
00: 14: 25,788 -> 00: 14: 28.580
ainda mostramos o erro, destacamos onde ele está.

282
00: 14: 28,580 -> 00: 14: 33.280
E, de fato, zero com erros, ponto c, linha 3, caractere 5 ou coluna 5,

283
00: 14: 33,280 -> 00: 14: 37.010
é apenas uma maneira de nos concentrarmos em qual é o problema.

284
00: 14: 37,010 -> 00: 14: 43.300
Deixe-me ir em frente e abrir outro arquivo aqui, ou aprimorá-lo como buggy1.c

285
00: 14: 43,300 -> 00: 14: 47.520
e cometer um erro semelhante, mas que acione uma mensagem de erro

286
00: 14: 47,520 -> 00: 14: 48.020
diferente.

287
00: 14: 48,020 -> 00: 14: 50.728
Neste caso, vou prosseguir e acertar desta vez,

288
00: 14: 50,728 -> 00: 14: 53.420
incluir stdio.h.

289
00: 14: 53,420 -> 00: 14: 56.925
E então eu vou prosseguir e fazer int main void, e então, como antes,

290
00: 14: 56,925 -> 00: 14: 58.550
Vou fazer este programa canônico.

291
00: 14: 58,550 -> 00: 15: 00.620
string name recebe get_string.

292
00: 15: 00,620 -> 00: 15: 03.890
E pergunte ao usuário, qual é o seu nome -

293
00: 15: 03,890 -> 00: 15: 05.150
barra invertida, n.

294
00: 15: 05,150 -> 00: 15: 10.850
E então vou dizer olá para eles com um %s vírgula nome.

295
00: 15: 10.850 -> 00: 15: 12.480
Então isso também parece bom.

296
00: 15: 12,480 -> 00: 15: 16.760
Vou prosseguir e rolar de volta aqui, make buggy desta vez.

297
00: 15: 16,760 -> 00: 15: 20.030
Mas, claro, parece que, meu Deus, como antes, eu tenho duas linhas de código,

298
00: 15: 20,030 -> 00: 15: 21.740
mas de alguma forma, cinco ou seis erros.

299
00: 15: 21,740 -> 00: 15: 23.120
Sempre foque no topo.

300
00: 15: 23,120 -> 00: 15: 27.180
Provavelmente está relacionado a algo assim, mas este é mais confuso.

301
00: 15: 27,180 -> 00: 15: 29.960
O identificador string não declarado-- você quis dizer stdio?

302
00: 15: 29,960 -> 00: 15: 31.040
Bem não.

303
00: 15: 31,040 -> 00: 15: 34.310
Então, se você não adivinhar isso, vá em frente e execute o mesmo comando,

304
00: 15: 34,310 -> 00: 15: 36.360
help50, make buggy1.

305
00: 15: 36,360 -> 00: 15: 38.960
E, desta vez, veremos a saída deste comando,

306
00: 15: 38,960 -> 00: 15: 42.470
esperançosamente, depois de pedir ajuda, uma pista sobre o que

307
00: 15: 42,470 -> 00: 15: 44.840
é isso que estamos procurando.

308
00: 15: 44,840 -> 00: 15: 47.780
E, de fato, agora notamos que, pelo identificador não declarado,

309
00: 15: 47,780 -> 00: 15: 50.495
clang quer dizer que você usou o nome string na linha cinco do buggy1.c

310
00: 15: 50,495 -> 00: 15: 52.040
que não foi definido.

311
00: 15: 52,040 -> 00: 15: 55.400
Você se esqueceu de incluir cs50.h, neste ponto.

312
00: 15: 55,400 -> 00: 15: 58.550
Resumindo, sempre que você tiver problemas para executar um comando

313
00: 15: 58,550 -> 00: 16: 02.270
e você está vendo mensagens enigmáticas, chame help50 como um comando

314
00: 16: 02,270 -> 00: 16: 04.100
por realmente explicar isso para você.

315
00: 16: 04,100 -> 00: 16: 08.122
E depois disso, provavelmente você não terá que executar o mesmo comando novamente.

316
00: 16: 08,122 -> 00: 16: 09.080
Mas e quanto ao outro?

317
00: 16: 09,080 -> 00: 16: 12.950
Deixe-me ir em frente e abrir um programa que escrevi com antecedência aqui,

318
00: 16: 12,950 -> 00: 16: 17.250
e vou em frente e abrir este.

319
00: 16: 17,250 -> 00: 16: 17.750
Sim?

320
00: 16: 17,750 -> 00: 16: 18.565
Certo.

321
00: 16: 18,565 -> 00: 16: 23.925
PÚBLICO: [INAUDÍVEL] basta pressionar mais botões.

322
00: 16: 23,925 -> 00: 16: 25.550
DAVID MALAN: Para executar novamente o mesmo comando?

323
00: 16: 25,550 -> 00: 16: 27.890
PÚBLICO: Não para excluir, mas para [INAUDÍVEL]

324
00: 16: 27,890 -> 00: 16: 30.560
DAVID MALAN: Oh, sim, apenas para manter as coisas organizadas na aula,

325
00: 16: 30,560 -> 00: 16: 32.600
Tenho o hábito de apertar muito o Control l,

326
00: 16: 32,600 -> 00: 16: 34.460
que apenas limpa minha janela de terminal.

327
00: 16: 34,460 -> 00: 16: 35.630
Não tem impacto funcional.

328
00: 16: 35,630 -> 00: 16: 37.490
Isso apenas tira a desordem da tela.

329
00: 16: 37,490 -> 00: 16: 40.515
Você também pode digitar literalmente, por exemplo, clear, Enter.

330
00: 16: 40,515 -> 00: 16: 42.890
Isso é um pouco mais prolixo do que apertar o Controle l.

331
00: 16: 42,890 -> 00: 16: 45.932
Portanto, há muitos pequenos atalhos de teclado e interrupções a qualquer momento

332
00: 16: 45,932 -> 00: 16: 47.520
se você tiver dúvidas sobre eles.

333
00: 16: 47,520 -> 00: 16: 49.670
Então, aqui está um programa que também tem bugs.

334
00: 16: 49,670 -> 00: 16: 52.160
Eu escrevi com antecedência e é chamado de buggy2.c.

335
00: 16: 52,160 -> 00: 16: 53.180
Tem um laço for.

336
00: 16: 53,180 -> 00: 16: 54.590
Ele está imprimindo alguns hashes.

337
00: 16: 54,590 -> 00: 16: 58.010
E o objetivo deste programa é imprimir algo 10 vezes.s

338
00: 16: 58,010 -> 00: 17: 00.560
Portanto, tenho meu laço for de zero a 10.

339
00: 17: 00,560 -> 00: 17: 02.870
Estou imprimindo um hash com barra invertida n.

340
00: 17: 02,870 -> 00: 17: 06.450
Então, vamos prosseguir e executar isso, make buggy2

341
00: 17: 06,450 -> 00: 17: 06.950
Opa.

342
00: 17: 06,950 -> 00: 17: 08.033
Eu não estou neste diretório.

343
00: 17: 08,033 -> 00: 17: 10.609
Deixe-me ir em frente make buggy2 -

344
00: 17: 10.609 -> 00: 17: 11.510
parece compilar.

345
00: 17: 11,510 -> 00: 17: 14.089
Portanto, este não é um problema para help50 ainda,

346
00: 17: 14,089 -> 00: 17: 17.030
porque isso seria quando o próprio comando não está funcionando.

347
00: 17: 17,030 -> 00: 17: 19.880
Buggy2 - tudo bem, parece bom, mas vamos

348
00: 17: 19,880 -> 00: 17: 23.798
apenas tenha certeza - um, dois, três, quatro, cinco, seis, sete, oito, nove,

349
00: 17: 23,798 -> 00: 17: 26.000
10, 11.

350
00: 17: 26.000 -> 00: 17: 28.550
Portanto, é falho, se meu objetivo é imprimir apenas 10 hashes.

351
00: 17: 28,550 -> 00: 17: 30.230
E, obviamente, isso é muito artificial.

352
00: 17: 30,230 -> 00: 17: 32.960
Provavelmente, você pode raciocinar qual é o problema aqui,

353
00: 17: 32,960 -> 00: 17: 36.320
mas isso é uma representação de outro tipo de problema

354
00: 17: 36,320 -> 00: 17: 41.870
isso não é um bug sintaticamente, por meio do qual você digitou algum símbolo ou comando errado.

355
00: 17: 41,870 -> 00: 17: 43.370
Este é mais um erro lógico.

356
00: 17: 43,370 -> 00: 17: 45.500
Meu objetivo é imprimir algo 10 vezes.

357
00: 17: 45,500 -> 00: 17: 46.370
Este obviamente não está.

358
00: 17: 46,370 -> 00: 17: 47.787
Está imprimindo algo 11 vezes.

359
00: 17: 47,787 -> 00: 17: 50.370
E suponha que o objetivo em questão seja envolver sua mente,

360
00: 17: 50,370 -> 00: 17: 51.960
porque isso esta acontecendo

361
00: 17: 51,960 -> 00: 17: 55.280
Bem, a próxima ferramenta de depuração que vamos propor que você considere,

362
00: 17: 55,280 -> 00: 17: 57.170
é na verdade simplesmente printf.

363
00: 17: 57,170 -> 00: 18: 00.980
É talvez a ferramenta mais simples que você pode usar para realmente entender

364
00: 18: 00,980 -> 00: 18: 04.190
o que está acontecendo dentro de seu programa, e podemos usá-lo neste caso

365
00: 18: 04,190 -> 00: 18: 05.240
do seguinte modo.

366
00: 18: 05,240 -> 00: 18: 08.023
Obviamente, já estou imprimindo o símbolo hash,

367
00: 18: 08,023 -> 00: 18: 10.940
mas deixe-me ir em frente e dizer algo mais deliberado, apenas para mim,

368
00: 18: 10.940 -> 00: 18: 18.830
algo como i é agora, %i, e então vamos em frente e apenas colocar um espaço,

369
00: 18: 18,830 -> 00: 18: 21.690
e aí, imprime i ponto-e-vírgula.

370
00: 18: 21,690 -> 00: 18: 23.460
Portanto, esse não é o objetivo do programa.

371
00: 18: 23,460 -> 00: 18: 25.400
É apenas uma mensagem de diagnóstico temporária,

372
00: 18: 25,400 -> 00: 18: 28.850
de modo que agora, se eu prosseguir e aumentar minha janela de terminal,

373
00: 18: 28,850 -> 00: 18: 33.620
recompilar o buggy2 e executar novamente ./buggy2 -

374
00: 18: 33,620 -> 00: 18: 35.930
[RISOS] buffy dois -

375
00: 18: 35,930 -> 00: 18: 41.000
buggy2 - agora verei, oh, um pouco mais de informações interessantes.

376
00: 18: 41.000 -> 00: 18: 44.600
Não só ainda estou vendo os hashes, estou vendo agora, em tempo real,

377
00: 18: 44,600 -> 00: 18: 45.617
o valor de i.

378
00: 18: 45,617 -> 00: 18: 47.450
E agora, provavelmente deve saltar para você,

379
00: 18: 47,450 -> 00: 18: 50.210
se isto já não estava no laço for sozinho, o que é

380
00: 18: 50,210 -> 00: 18: 53.256
o erro que cometi no meu código?

381
00: 18: 53,256 -> 00: 18: 54.613
PÚBLICO: [INAUDÍVEL]

382
00: 18: 54,613 -> 00: 18: 55.571
DAVID MALAN: Diga novamente.

383
00: 18: 55,571 -> 00: 18: 58.220
PÚBLICO: [INAUDÍVEL]

384
00: 18: 58,220 -> 00: 19: 02.100
DAVID MALAN: Sim, meu primeiro valor para i foi zero, e isso normalmente está OK.

385
00: 19: 02,100 -> 00: 19: 04.100
Os programadores tendem a começar a contar do zero,

386
00: 19: 04,100 -> 00: 19: 07.730
mas se você fizer isso, não poderá continuar contando até 10.

387
00: 19: 07,730 -> 00: 19: 09.860
Você precisa fazer alguns ajustes aqui.

388
00: 19: 09,860 -> 00: 19: 11.462
Então, o que podemos fazer para consertar?

389
00: 19: 11,462 -> 00: 19: 15.457
PÚBLICO: [INAUDÍVEL]

390
00: 19: 15,457 -> 00: 19: 18.290
DAVID MALAN: Sim, então essa seria a maneira canônica de fazer isso.

391
00: 19: 18,290 -> 00: 19: 20.480
Não é a única maneira, mas geralmente começa do zero

392
00: 19: 20,480 -> 00: 19: 23.330
e aumentar para menos do que o valor de seu interesse.

393
00: 19: 23,330 -> 00: 19: 27.290
Então, agora, se eu executar isso novamente, posso prosseguir e executar o buggy2 novamente,

394
00: 19: 27,290 -> 00: 19: 30.860
limpar minha tela, ./buggy2, Enter.

395
00: 19: 30,860 -> 00: 19: 33.557
E agora eu realmente tenho 10, embora nunca diga 10,

396
00: 19: 33,557 -> 00: 19: 35.390
mas tudo bem, porque estou começando do zero,

397
00: 19: 35,390 -> 00: 19: 38.330
e agora que encontrei meu erro lógico, onde simplesmente não

398
00: 19: 38,330 -> 00: 19: 41.810
estava funcionando como pretendia, agora posso ir em frente e deletar essa linha.

399
00: 19: 41,810 -> 00: 19: 47.000
Posso ir em frente e make buggy2 mais uma vez, ./buggy2, Enter.

400
00: 19: 47.000 -> 00: 19: 51.140
E pronto, agora posso enviar meu programa ou enviá-lo para meu usuário real.

401
00: 19: 51,140 -> 00: 19: 53.652
Então printf é uma maneira muito tradicional

402
00: 19: 53,652 -> 00: 19: 56.360
de apenas envolver sua mente em torno do que está acontecendo em seu programa

403
00: 19: 56,360 -> 00: 19: 57.530
apenas bisbilhotando.

404
00: 19: 57.530 -> 00: 20: 00.870
Use printf para ver o que está acontecendo dentro de seu programa,

405
00: 20: 00,870 -> 00: 20: 03.740
então você não está apenas olhando para uma tela tentando raciocinar

406
00: 20: 03,740 -> 00: 20: 05.810
sem a ajuda do computador.

407
00: 20: 05,810 -> 00: 20: 09.405
Mas é claro, isso é tão versátil quanto sandbox cs50

408
00: 20: 09,405 -> 00: 20: 11.030
obtém quando se trata de resolver problemas.

409
00: 20: 11,030 -> 00: 20: 12.500
Você pode escrever o código aqui.

410
00: 20: 12,500 -> 00: 20: 14.630
Você pode compilar e executar o código aqui.

411
00: 20: 14,630 -> 00: 20: 16.850
E existem comandos como help50 e alguns outros

412
00: 20: 16,850 -> 00: 20: 19.400
veremos que você pode executar para melhorar seu código,

413
00: 20: 19,400 -> 00: 20: 22.215
mas a própria sandbox é bastante limitada.

414
00: 20: 22,215 -> 00: 20: 25.340
E hoje, vamos apresentar outro ambiente de programação que

415
00: 20: 25,340 -> 00: 20: 29.720
fundamentalmente é a mesma coisa, apenas tem recursos adicionais, especialmente

416
00: 20: 29,720 -> 00: 20: 31.880
aqueles relacionados à depuração.

417
00: 20: 31,880 -> 00: 20: 36.200
Então aqui está o que é chamado de CS50 IDE.

418
00: 20: 36,200 -> 00: 20: 39.113
IDE é um termo da arte para ambiente de desenvolvimento integrado.

419
00: 20: 39,113 -> 00: 20: 41.030
Você pode ter usado se você programou antes

420
00: 20: 41,030 -> 00: 20: 44.270
no ensino médio, coisas como Eclipse ou Visual Studio ou NetBeans

421
00: 20: 44,270 -> 00: 20: 45.830
ou um monte de outras ferramentas também.

422
00: 20: 45,830 -> 00: 20: 47.420
Se você já usou alguma dessas ferramentas, tudo bem.

423
00: 20: 47,420 -> 00: 20: 48.590
A maioria dos alunos não.

424
00: 20: 48,590 -> 00: 20: 52.940
Mas o CS50 IDE é apenas uma versão mais sofisticada do CS50 sandbox

425
00: 20: 52,940 -> 00: 20: 56.420
que adiciona algumas ferramentas adicionais, como ferramentas de depuração.

426
00: 20: 56,420 -> 00: 21: 00.140
E então aqui eu fui em frente e loguei antecipadamente no IDE CS50,

427
00: 21: 00,140 -> 00: 21: 01.970
e é praticamente o mesmo layout.

428
00: 21: 01,970 -> 00: 21: 05.660
No topo da janela é onde minhas abas com meu código irão.

429
00: 21: 05,660 -> 00: 21: 07.220
Na parte inferior está a janela do meu terminal.

430
00: 21: 07,220 -> 00: 21: 10.530
Acontece que é azul em vez de preto, mas isso é apenas um detalhe estético.

431
00: 21: 10,530 -> 00: 21: 13.108
Mas você verá um divisor aqui de outros recursos,

432
00: 21: 13,108 -> 00: 21: 16.400
incluindo o que é chamado de depurador, um programa que vai me permitir

433
00: 21: 16,400 -> 00: 21: 19.470
passo a passo pelo meu código.

434
00: 21: 19,470 -> 00: 21: 21.710
Então, vamos prosseguir e fazer isso depois de apresentar

435
00: 21: 21,710 -> 00: 21: 25.850
um outro comando que existe no IDE e é chamado de debug50.

436
00: 21: 25,850 -> 00: 21: 28.790
Basta dizer, que qualquer comando neste semestre que termina em 50

437
00: 21: 28,790 -> 00: 21: 30.958
é um tipo de roda de treinamento específica do CS50.

438
00: 21: 30,958 -> 00: 21: 32.750
Mas no final do semestre, bem, temos essencialmente

439
00: 21: 32,750 -> 00: 21: 36.980
tirou todas as ferramentas específicas do CS50 para que tudo o que você está usando

440
00: 21: 36,980 -> 00: 21: 39.660
é o padrão da indústria, por assim dizer.

441
00: 21: 39,660 -> 00: 21: 46.110
Portanto, se olharmos agora para o IDE CS50, vamos prosseguir e talvez executar o mesmo programa.

442
00: 21: 46,110 -> 00: 21: 49.520
Então, se eu clicar neste ícone de pasta aqui, você verá um monte de arquivos,

443
00: 21: 49,520 -> 00: 21: 50.810
assim como na caixa de areia.

444
00: 21: 50,810 -> 00: 21: 53.810
E eu pré baixei todo o código-fonte de hoje do site do CS50

445
00: 21: 53,810 -> 00: 21: 56.960
e apenas carreguei no IDE, assim como você faz na sandbox.

446
00: 21: 56,960 -> 00: 22: 00.780
E faremos isso em seção ou em super seção, manualmente, se desejar.

447
00: 22: 00,780 -> 00: 22: 03.950
Vou prosseguir e abrir o mesmo programa buggy2, que é

448
00: 22: 03,950 -> 00: 22: 06.053
agora no IDE em vez da sandbox, e você

449
00: 22: 06,053 -> 00: 22: 07.470
veja que parece praticamente o mesmo.

450
00: 22: 07,470 -> 00: 22: 09.060
O código de cores pode ser um pouco diferente,

451
00: 22: 09,060 -> 00: 22: 10.648
mas isso é apenas um detalhe estético.

452
00: 22: 10,648 -> 00: 22: 11.690
E ainda posso executar isso.

453
00: 22: 11,690 -> 00: 22: 14.540
make buggy2 aqui.

454
00: 22: 14,540 -> 00: 22: 19.340
Mas observe aqui, este erro, eu poderia usar o help50 sobre isso, mas observe com antecedência,

455
00: 22: 19,340 -> 00: 22: 22.490
Baixei todo o meu código para uma pasta chamada "source two".

456
00: 22: 22,490 -> 00: 22: 25.100
É o que está no arquivo zip, no site do curso.

457
00: 22: 25,100 -> 00: 22: 29.960
Então, novamente, assim como fizemos brevemente na semana passada, se você souber que seu código não está apenas

458
00: 22: 29,960 -> 00: 22: 32.420
no local padrão, mas em outro diretório,

459
00: 22: 32,420 -> 00: 22: 34.005
o que significa cd?

460
00: 22: 34,005 -> 00: 22: 35.250
PÚBLICO: Alterar diretório.

461
00: 22: 35,250 -> 00: 22: 35.600
DAVID MALAN: OK.

462
00: 22: 35,600 -> 00: 22: 37.225
Portanto, mudar de diretório - não é tão difícil.

463
00: 22: 37,225 -> 00: 22: 38.210
Ele muda de diretório.

464
00: 22: 38,210 -> 00: 22: 39.980
E agora observe o que a sandbox faz.

465
00: 22: 39,980 -> 00: 22: 42.950
É um pouco mais poderoso, embora seja um pouco mais enigmático.

466
00: 22: 42,950 -> 00: 22: 45.200
Sempre coloca um lembrete constante de onde

467
00: 22: 45,200 -> 00: 22: 48.800
você está nas pastas do seu IDE, enquanto o sandbox escondeu

468
00: 22: 48,800 -> 00: 22: 49.880
este detalhe completamente.

469
00: 22: 49,880 -> 00: 22: 52.547
Então, novamente, estamos removendo uma roda de treinamento apenas para lembrá-lo,

470
00: 22: 52,547 -> 00: 22: 55.730
você está na source dois e o til é apenas uma convenção de computador,

471
00: 22: 55,730 -> 00: 22: 57.560
o que significa que é o seu diretório pessoal, que

472
00: 22: 57.560 -> 00: 23: 02.450
é sua pasta pessoal com seus arquivos CS50, demarcada com apenas um til.

473
00: 23: 02,450 -> 00: 23: 05.150
Portanto, agora vou prosseguir e make buggy2.

474
00: 23: 05,150 -> 00: 23: 08.130
Ele compila, porque, novamente, este não é um erro de sintaxe.

475
00: 23: 08,130 -> 00: 23: 09.660
Este é um problema lógico.

476
00: 23: 09,660 -> 00: 23: 12.480
Eu devo ir em frente agora e ponto ./buggy2

477
00: 23: 12,480 -> 00: 23: 16.550
E se eu contar isso, ainda tenho 11 hashes na tela.

478
00: 23: 16,550 -> 00: 23: 18.800
Eu poderia entrar e adicionar printf, mas isso não é realmente

479
00: 23: 18,800 -> 00: 23: 20.790
aproveitando todas as novas ferramentas.

480
00: 23: 20,790 -> 00: 23: 22.610
Mas observe o que posso fazer em vez disso.

481
00: 23: 22,610 -> 00: 23: 26.310
Deixe-me rolar isso um pouco para baixo para ver todo o meu código.

482
00: 23: 26,310 -> 00: 23: 31.700
Deixe-me ir em frente e clicar à esquerda dos números das linhas no IDE,

483
00: 23: 31,700 -> 00: 23: 35.360
como no main, e colocar um ponto vermelho, como uma placa de pare que diz pare aqui.

484
00: 23: 35,360 -> 00: 23: 37.040
Isso é chamado de ponto de interrupção.

485
00: 23: 37,040 -> 00: 23: 39.950
Esta é uma característica de muitos ambientes de desenvolvimento integrados,

486
00: 23: 39,950 -> 00: 23: 42.830
como CS50 IDE que informa o computador com antecedência,

487
00: 23: 42,830 -> 00: 23: 45.590
quando executo este programa, não o execute como de costume,

488
00: 23: 45,590 -> 00: 23: 50.450
pare aí e permita que eu, o humano, analise meu código,

489
00: 23: 50,450 -> 00: 23: 52.220
passo a passo.

490
00: 23: 52,220 -> 00: 23: 55.880
Então, para fazer isso, você não precisa apenas executar o buggy2 novamente.

491
00: 23: 55,880 -> 00: 23: 58.340
Em vez disso, você executa o debug50.

492
00: 23: 58,340 -> 00: 24: 02.310
Assim como o help50 ajuda a entender as mensagens de erro, debug50

493
00: 24: 02,310 -> 00: 24: 05.930
permite que você percorra o programa passo a passo.

494
00: 24: 05,930 -> 00: 24: 07.550
Deixe-me ir em frente e pressione Enter.

495
00: 24: 07,550 -> 00: 24: 10.760
Você notará agora no lado direito uma nova janela

496
00: 24: 10,760 -> 00: 24: 12.523
que a sandbox não abriu.

497
00: 24: 12,523 -> 00: 24: 15.690
E há muita coisa acontecendo lá, mas logo veremos as peças que importam.

498
00: 24: 15,690 -> 00: 24: 16.980
Esse é o depurador.

499
00: 24: 16,980 -> 00: 24: 19.560
E você verá que esta linha aqui, linha sete,

500
00: 24: 19,560 -> 00: 24: 23.192
é destacado, porque é a primeira parte real do código dentro do principal

501
00: 24: 23,192 -> 00: 24: 24.900
que potencialmente será executado.

502
00: 24: 24,900 -> 00: 24: 26.775
Nada realmente acontece com as chaves.

503
00: 24: 26,775 -> 00: 24: 28.630
Sete é a primeira linha real de código.

504
00: 24: 28,630 -> 00: 24: 30.450
Então, o que essa barra amarela ou esverdeada significa

505
00: 24: 30,450 -> 00: 24: 34.500
é que o depurador pausou seu programa naquele momento,

506
00: 24: 34,500 -> 00: 24: 38.460
não percorreu todo o caminho, então podemos começar a vasculhar.

507
00: 24: 38,460 -> 00: 24: 41.790
E, de fato, se eu ampliar à direita, vamos nos concentrar hoje

508
00: 24: 41,790 -> 00: 24: 46.890
basicamente em variáveis, você notará uma pequena pista visual agradável

509
00: 24: 46,890 -> 00: 24: 48.810
que você tem uma variável chamada i.

510
00: 24: 48,810 -> 00: 24: 50.430
No momento, seu valor é zero.

511
00: 24: 50,430 -> 00: 24: 51.570
Qual é o seu tipo?

512
00: 24: 51,570 -> 00: 24: 52.740
Inteiro.

513
00: 24: 52,740 -> 00: 24: 56.400
Então, observe o que acontece agora quando eu aproveito alguns dos ícones

514
00: 24: 56,400 -> 00: 24: 57.688
que estão um pouco mais acima.

515
00: 24: 57,688 -> 00: 25: 00.480
Vou apenas rolar para cima no depurador, e a maior parte disso vamos

516
00: 25: 00,480 -> 00: 25: 03.010
ignore por hoje, mas há alguns ícones aqui.

517
00: 25: 03,010 -> 00: 25: 05.730
Então, se eu clicar em Play, isso apenas retomará meu programa

518
00: 25: 05,730 -> 00: 25: 07.950
e executá-lo até o fim - não é muito útil

519
00: 25: 07,950 -> 00: 25: 09.610
se meu objetivo era passar por isso.

520
00: 25: 09,610 -> 00: 25: 13.530
Mas se você passar o mouse sobre esses outros ícones, passe por cima,

521
00: 25: 13,530 -> 00: 25: 17.320
isso vai passar por cima de uma linha de código por vez,

522
00: 25: 17,320 -> 00: 25: 19.740
e executá-lo um por um, tão literalmente

523
00: 25: 19,740 -> 00: 25: 21.960
permitindo que você percorra seu próprio código.

524
00: 25: 21,960 -> 00: 25: 23.010
E então vamos tentar isso.

525
00: 25: 23,010 -> 00: 25: 27.570
Quando clico em Avançar, observe que a cor se move.

526
00: 25: 27,570 -> 00: 25: 30.600
Observe minha janela de terminal agora, a grande janela azul na parte inferior.

527
00: 25: 30,600 -> 00: 25: 31.980
Eu vou ver o hash.

528
00: 25: 31,980 -> 00: 25: 33.990
Agora observe que a linha sete está destacada novamente,

529
00: 25: 33,990 -> 00: 25: 35.400
porque apenas com um loop for, algo

530
00: 25: 35,400 -> 00: 25: 37.020
vai acontecer novamente e novamente.

531
00: 25: 37,020 -> 00: 25: 41.274
Então, o que devemos ver acontecer quando eu clico em avançar mais uma vez?

532
00: 25: 41,274 -> 00: 25: 42.215
PÚBLICO: [INAUDÍVEL]

533
00: 25: 42,215 -> 00: 25: 43.590
DAVID MALAN: i deveria se tornar um.

534
00: 25: 43,590 -> 00: 25: 46.757
É um pouco pequeno, mas observe o lado direito da tela, onde

535
00: 25: 46,757 -> 00: 25: 49.650
diz a variável i, e eu clico em Step Over--

536
00: 25: 49,650 -> 00: 25: 51.630
voila, agora vemos um.

537
00: 25: 51,630 -> 00: 25: 54.840
E se eu continuar fazendo isso, nada muito de interesse acontece0.

538
00: 25: 54,840 -> 00: 25: 57.990
Eu realmente diminuí o mesmo programa.

539
00: 25: 57,990 -> 00: 26: 01.590
Mas você notará que i está aumentando continuamente.

540
00: 26: 01,590 -> 00: 26: 03.690
Mas o que é interessante aqui é que eu não tive

541
00: 26: 03,690 -> 00: 26: 07.238
entrar e mudar meu código adicionando um monte de instruções printf confusas

542
00: 26: 07,238 -> 00: 26: 09.780
que vou ter que excluir mais tarde apenas para enviar meu código

543
00: 26: 09,780 -> 00: 26: 11.100
ou enviá-lo pela Internet.

544
00: 26: 11,100 -> 00: 26: 15.150
Em vez disso, posso assistir o que está acontecendo na memória do meu computador

545
00: 26: 15,150 -> 00: 26: 17.160
enquanto estou executando este programa.

546
00: 26: 17,160 -> 00: 26: 21.750
E o fato de que agora o valor de i é 10,

547
00: 26: 21,750 -> 00: 26: 26.830
e, no entanto, estou prestes a imprimir outro hash, aí reside o mesmo erro lógico.

548
00: 26: 26,830 -> 00: 26: 30.790
Portanto, estamos vendo apenas graficamente o mesmo problema de antes.

549
00: 26: 30,790 -> 00: 26: 33.040
Agora, neste ponto, o programa está praticamente pronto.

550
00: 26: 33,040 -> 00: 26: 35.750
Se eu continuar clicando em Step Over, ele simplesmente vai encerrar.

551
00: 26: 35,750 -> 00: 26: 37.500
Se neste ponto, eu estou tipo, oh meu Deus, agora

552
00: 26: 37,500 -> 00: 26: 41.240
Eu sei que está errado, você pode sair de quase qualquer programa no IDE

553
00: 26: 41,240 -> 00: 26: 43.847
ou no sandbox pressionando Control c, para cancelar,

554
00: 26: 43,847 -> 00: 26: 45.930
e isso vai matar o depurador, fechar a janela,

555
00: 26: 45,930 -> 00: 26: 47.860
e voltar para a janela do terminal.

556
00: 26: 47,860 -> 00: 26: 51.660
E eu não posso enfatizar isso o suficiente, avançando ainda esta semana,

557
00: 26: 51,660 -> 00: 26: 56.247
use o help50 quando tiver um bug ao compilar seu código, alguma mensagem de erro

558
00: 26: 56,247 -> 00: 26: 57.330
que você não entende.

559
00: 26: 57,330 -> 00: 26: 59.160
Isso o ajudará apenas como um membro da equipe faria.

560
00: 26: 59,160 -> 00: 27: 01.827
E então, certamente, entre em contato conosco se você não entender isso.

561
00: 27: 01,827 -> 00: 27: 04.800
Mas o debug50 deve, seguindo em frente, será seu primeiro instinto.

562
00: 27: 04,800 -> 00: 27: 06.960
Se você tiver um bug em que algo que não está funcionando,

563
00: 27: 06,960 -> 00: 27: 08.670
a quantidade de alterações em seu computador está errada,

564
00: 27: 08,670 -> 00: 27: 10.503
os números do cartão de crédito que você está analisando estão

565
00: 27: 10,503 -> 00: 27: 14.790
errados, use debug50, começando esta semana, não daqui a duas semanas,

566
00: 27: 14,790 -> 00: 27: 16.890
para desenvolver a memória muscular de usar um depurador.

567
00: 27: 16,890 -> 00: 27: 21.630
E é realmente uma habilidade para toda a vida, não apenas para C, mas para outras línguas

568
00: 27: 21,630 -> 00: 27: 23.310
também.

569
00: 27: 23,310 -> 00: 27: 26.400
Alguma dúvida sobre isso?

570
00: 27: 26,400 -> 00: 27: 29.910
Você verá mais disso na seção e além.

571
00: 27: 29,910 -> 00: 27: 33.480
Então, o que mais temos em termos de ferramentas em nosso kit de ferramentas aqui?

572
00: 27: 33,480 -> 00: 27: 35.888
Vamos prosseguir e apresentar um ao outro agora.

573
00: 27: 35,888 -> 00: 27: 38.430
Aquele que você provavelmente usou na semana passada, chamado check50.

574
00: 27: 38,430 -> 00: 27: 41.740
Esta é uma ferramenta que permite analisar a correção do seu código.

575
00: 27: 41,740 -> 00: 27: 45.090
E você deve se lembrar com o check50, você fez algo assim.

576
00: 27: 45,090 -> 00: 27: 50.520
Se eu fosse em frente e criasse um programa, como meu típico hello.c--

577
00: 27: 50,520 -> 00: 27: 54.160
por isso, cliquei em Salvar, salvando este arquivo como hello dot c.

578
00: 27: 54,160 -> 00: 27: 57.900
Deixe-me ir em frente e incluir o stdio.h, int main void.

579
00: 27: 57,900 -> 00: 27: 59.940
Deixe-me ir em frente agora e printf.

580
00: 27: 59,940 -> 00: 28: 03.720
Olá, vírgula mundo \n ponto e vírgula.

581
00: 28: 03,720 -> 00: 28: 06.870
E eu sei, pelos conjuntos de problemas, que a maneira

582
00: 28: 06,870 -> 00: 28: 09.660
para verificar a exatidão deste código com CS50 -

583
00: 28: 09,660 -> 00: 28: 12.570
check50 e, em seguida, um log, um identificador exclusivo.

584
00: 28: 12,570 -> 00: 28: 17.280
Estou usando um mais curto, apenas para a palestra de hoje chamada CS50 problems hello.

585
00: 28: 17,280 -> 00: 28: 20.760
Esse é apenas o conjunto exclusivo de testes que desejo executar em meu código

586
00: 28: 20,760 -> 00: 28: 22.095
chamado hello dot c.

587
00: 28: 22,095 -> 00: 28: 24.720
O que está acontecendo aqui é que estou sendo solicitado a autenticar.

588
00: 28: 24,720 -> 00: 28: 27.120
É o GitHub que ele usa, como você viu.

589
00: 28: 27,120 -> 00: 28: 29.220
Vou usar minha conta de aluno.

590
00: 28: 29,220 -> 00: 28: 32.020
Vou prosseguir e fazer login.

591
00: 28: 32,020 -> 00: 28: 34.170
Você notará que uma estrela representa sua senha,

592
00: 28: 34,170 -> 00: 28: 37.140
então meio que mascara, mesmo que todos no mundo agora

593
00: 28: 37,140 -> 00: 28: 39.007
sabe o tamanho minha senha tem.

594
00: 28: 39,007 -> 00: 28: 41.340
E agora estamos nos preparando, estamos enviando o envio,

595
00: 28: 41,340 -> 00: 28: 43.423
e em apenas alguns segundos, receberemos algum feedback

596
00: 28: 43,423 -> 00: 28: 46.650
do servidor CS50 que nos diz, esperançosamente,

597
00: 28: 46,650 -> 00: 28: 49.110
que meu código está perfeitamente correto -

598
00: 28: 49,110 -> 00: 28: 50.520
perfeitamente correto.

599
00: 28: 50,520 -> 00: 28: 52.740
Mas não, não é neste caso.

600
00: 28: 52,740 -> 00: 28: 54.570
E se você se lembrar do conjunto de problemas 1, você

601
00: 28: 54,570 -> 00: 28: 56.362
não deveria apenas imprimir hello world.

602
00: 28: 56,362 -> 00: 28: 59.550
Você deveria imprimir oi fulano de tal, qualquer que seja o nome do humano.

603
00: 28: 59,550 -> 00: 29: 03.020
Você verá dois smileys verdes aqui dizendo hello.c existe.

604
00: 29: 03,020 -> 00: 29: 04.140
Então eu acertei.

605
00: 29: 04,140 -> 00: 29: 05.580
Eu nomeei o arquivo corretamente.

606
00: 29: 05,580 -> 00: 29: 08.400
Etapa dois, compilado, portanto, não houve mensagens de erro

607
00: 29: 08,400 -> 00: 29: 10.140
quando executamos make em seu código.

608
00: 29: 10,140 -> 00: 29: 12.660
Mas de fato recebemos 2 carinhas tristes.

609
00: 29: 12,660 -> 00: 29: 16.230
Esperávamos ao passar em nome de Emma, ​​que você dissesse olá Emma.

610
00: 29: 16,230 -> 00: 29: 19.590
E quando esperávamos passar no Rodrigo, esperávamos olá Rodrigo,

611
00: 29: 19,590 -> 00: 29: 22.510
então você não passou nesses dois testes.

612
00: 29: 22,510 -> 00: 29: 26.970
Portanto, verificar 50 é específico do CS50, que os TFs e eu usamos para avaliar

613
00: 29: 26,970 -> 00: 29: 29.460
e fornecer feedback automatizado sobre o código, mas é

614
00: 29: 29,460 -> 00: 29: 33.120
representativos do que no mundo real são simplesmente chamados de testes.

615
00: 29: 33,120 -> 00: 29: 36.300
Sempre que você trabalha para uma empresa ou escreve software, parte desse processo

616
00: 29: 36,300 -> 00: 29: 39.150
normalmente não é apenas escrever o código que resolve seu problema,

617
00: 29: 39,150 -> 00: 29: 43.650
mas para escrever testes que garantam que seu próprio código está correto, especialmente

618
00: 29: 43,650 -> 00: 29: 47.160
de modo que se você adicionar recursos aos seus programas no futuro ou outra pessoa

619
00: 29: 47,160 -> 00: 29: 50.490
tenta adicionar recursos ao seu código, eles e você não o quebram -

620
00: 29: 50,490 -> 00: 29: 54.690
você constantemente tem a capacidade de garantir que seu código ainda esteja

621
00: 29: 54,690 -> 00: 29: 56.140
trabalhando como esperado.

622
00: 29: 56,140 -> 00: 29: 59.460
Então, embora o usemos no contexto acadêmico para pontuar conjuntos de problemas,

623
00: 29: 59,460 -> 00: 30: 02.610
é fundamentalmente representativo de um processo do mundo real

624
00: 30: 02,610 -> 00: 30: 06.270
de testar o próprio código repetidamente.

625
00: 30: 06,270 -> 00: 30: 08.760
E, por último, há essa coisa - style50.

626
00: 30: 08,760 -> 00: 30: 11.490
Portanto, não é incomum aprender a programar, especialmente

627
00: 30: 11,490 -> 00: 30: 13.830
em uma linguagem como C, ser um pouco descuidado quando

628
00: 30: 13,830 -> 00: 30: 15.150
trata-se de escrever seu código.

629
00: 30: 15,150 -> 00: 30: 18.300
Tecnicamente falando, este mesmo programa aqui,

630
00: 30: 18,300 -> 00: 30: 19.800
Eu poderia apenas fazer isso ficar assim.

631
00: 30: 19,800 -> 00: 30: 23.058
E, francamente, se eu realmente quiser, posso fazer com que fique assim,

632
00: 30: 23,058 -> 00: 30: 24.600
e o computador não vai se importar.

633
00: 30: 24,600 -> 00: 30: 27.142
É inteligente o suficiente para ser capaz de distinguir as várias 

634
00: 30: 27,142 -> 00: 30: 29.280
chaves dos parênteses aos ponto e vírgulas.

635
00: 30: 29,280 -> 00: 30: 32.100
Mas meu Deus, isso não é muito agradável de se olhar.

636
00: 30: 32,100 -> 00: 30: 34.470
Ou se for agora, quebre essa mentalidade.

637
00: 30: 34,470 -> 00: 30: 36.610
Isso não é muito agradável de se olhar.

638
00: 30: 36,610 -> 00: 30: 40.440
Você deve escrever um código que seja mais fácil de ler, para outras pessoas

639
00: 30: 40,440 -> 00: 30: 42.940
para ler e, honestamente, mais fácil de manter.

640
00: 30: 42,940 -> 00: 30: 46.530
Não há nada pior do que escrever um código realmente ruim, voltando

641
00: 30: 46,530 -> 00: 30: 49.140
semanas ou meses depois para consertar algo, acrescentar algo,

642
00: 30: 49,140 -> 00: 30: 52.590
e você nem sabe o que está olhando porque é o seu próprio código.

643
00: 30: 52,590 -> 00: 30: 56.130
Portanto, o style50 é uma ferramenta que apenas ajuda a desenvolver a memória

644
00: 30: 56,130 -> 00: 30: 58.410
muscular para escrever códigos mais bonitos.

645
00: 30: 58,410 -> 00: 31: 00.870
O estilo não tem nada a ver com a correção do seu treinador.

646
00: 31: 00,870 -> 00: 31: 04.500
É mais uma estética exigente que o torna agradável de se olhar.

647
00: 31: 04,500 -> 00: 31: 08.100
E pessoas razoáveis ​​irão discordar quanto ao que constitui um código bonito.

648
00: 31: 08,100 -> 00: 31: 11.160
Com o style50, nós, como uma empresa, padronizamos

649
00: 31: 11,160 -> 00: 31: 14.010
sobre como proporíamos a aparência do seu código C,

650
00: 31: 14,010 -> 00: 31: 17.470
para que possamos ter uma medida objetiva de quão limpo ele é.

651
00: 31: 17,470 -> 00: 31: 22.170
Então, se eu prosseguir e executar, depois de salvar meu arquivo, estilo 50 em hello dot c,

652
00: 31: 22,170 -> 00: 31: 24.660
Entre, você verá alguma saída como esta.

653
00: 31: 24,660 -> 00: 31: 27.510
Você verá o mesmo código em preto e branco na parte inferior,

654
00: 31: 27,510 -> 00: 31: 30.665
mas você verá um texto verde informando onde você deve adicionar espaço.

655
00: 31: 30,665 -> 00: 31: 32.790
Então você deve literalmente bater na barra de espaço quatro vezes

656
00: 31: 32,790 -> 00: 31: 35.130
e isso deixará o style50 feliz.

657
00: 31: 35,130 -> 00: 31: 39.150
Por outro lado, se eu fizer algo assim, deixe-me ir em frente

658
00: 31: 39,150 -> 00: 31: 41.580
e corrigi-lo incorretamente.

659
00: 31: 41,580 -> 00: 31: 45.190
Existem pessoas no mundo que escrevem códigos assim.

660
00: 31: 45,190 -> 00: 31: 46.950
Isso é desaprovado.

661
00: 31: 46,950 -> 00: 31: 50.310
Mas se eu prosseguir e executar o style50 agora neste arquivo -

662
00: 31: 50,310 -> 00: 31: 52.140
Entre - você verá o oposto.

663
00: 31: 52,140 -> 00: 31: 54.390
E fica um pouco mais assustador com essa sintaxe,

664
00: 31: 54,390 -> 00: 31: 57.780
porque estamos fazendo o nosso melhor para explicar o que queremos que você faça.

665
00: 31: 57,780 -> 00: 32: 02.100
Mas queremos que você exclua a nova linha, a tecla Enter que você pressionou aqui,

666
00: 32: 02,100 -> 00: 32: 04.380
e queremos que você o puxe até o topo aqui,

667
00: 32: 04,380 -> 00: 32: 06.090
e queremos que você exclua essa leitura aqui.

668
00: 32: 06,090 -> 00: 32: 08.430
Admito que às vezes é difícil para o computador

669
00: 32: 08,430 -> 00: 32: 11.950
para lhe dar conselhos muito diretos sobre o que está acontecendo.

670
00: 32: 11,950 -> 00: 32: 14.850
Então, você verá, com o tempo, certos padrões.

671
00: 32: 14,850 -> 00: 32: 17.850
Então, na verdade, se eu for ao próprio site do CS50 aqui,

672
00: 32: 17,850 -> 00: 32: 20.980
deixe-me prosseguir e puxar o que é chamado de guia de estilo.

673
00: 32: 20,980 -> 00: 32: 22.740
E esta é a resposta oficial quando

674
00: 32: 22,740 -> 00: 32: 25.995
trata-se de como seu código deve ser em uma classe ou em uma empresa.

675
00: 32: 25,995 -> 00: 32: 27.870
Você verá ao longo deste guia de estilo que é

676
00: 32: 27,870 -> 00: 32: 31.590
online muitos exemplos de que código bom, código bonito,

677
00: 32: 31,590 -> 00: 32: 33.600
código legível deve ser.

678
00: 32: 33,600 -> 00: 32: 35.670
E aí, também, pessoas razoáveis ​​irão discordar,

679
00: 32: 35,670 -> 00: 32: 39.930
mas faz parte do processo de programação ter um bom estilo para o seu código,

680
00: 32: 39,930 -> 00: 32: 44.610
também no style50 permite que você desenvolva essa memória muscular também.

681
00: 32: 44,610 -> 00: 32: 48.840
E um à parte, enquanto a ferramenta sandbox usada para salvar automaticamente seu arquivo,

682
00: 32: 48,840 -> 00: 32: 50.350
o IDE não faz isso.

683
00: 32: 50,350 -> 00: 32: 53.160
Perceba que só apertei Enter algumas vezes neste arquivo,

684
00: 32: 53,160 -> 00: 32: 57.390
ou suponha que eu disse algo como Goodbye World mais explicitamente, e suponha que eu

685
00: 32: 57,390 -> 00: 32: 59.740
agora movo meu cursor para a janela do terminal,

686
00: 32: 59,740 -> 00: 33: 02.840
você verá um grande alerta vermelho dizendo, ei, não salvou seu arquivo.

687
00: 33: 02,840 -> 00: 33: 06.090
Isso porque o IDE deve ser um pouco mais poderoso e um pouco mais

688
00: 33: 06,090 -> 00: 33: 10.020
a responsabilidade agora é de você saber realmente OK, ponto vermelho lá em cima

689
00: 33: 10,020 -> 00: 33: 11.280
significa que devo salvar.

690
00: 33: 11,280 -> 00: 33: 14.760
Então, arquivo, Salvar, ou você pode clicar em Control s ou Command s.

691
00: 33: 14,760 -> 00: 33: 18.900
Então, apenas perceba que agora é com você.

692
00: 33: 18,900 -> 00: 33: 23.790
E, por último, um resumo do que todas essas ferramentas realmente representam.

693
00: 33: 23,790 -> 00: 33: 25.620
Basicamente, as primeiras quatro dessas ferramentas

694
00: 33: 25,620 -> 00: 33: 28.710
todos se relacionam com a escrita de código correto, código

695
00: 33: 28,710 -> 00: 33: 32.280
que funciona da maneira que você quer, codifique da maneira que queremos,

696
00: 33: 32,280 -> 00: 33: 36.120
codifique da maneira que algum problema a ser resolvido deseja que você o implemente.

697
00: 33: 36,120 -> 00: 33: 40.080
Estilo é o último deles, e essa é realmente a melhor categorização disso.

698
00: 33: 40,080 -> 00: 33: 43.027
Claro, nem sempre essas ferramentas resolvem todos os seus problemas.

699
00: 33: 43,027 -> 00: 33: 44.985
E, sem dúvida, se você não experimentou isso,

700
00: 33: 44,985 -> 00: 33: 47.520
já na semana passada, você ficará frustrado.

701
00: 33: 47,520 -> 00: 33: 51.450
Você ficará incrivelmente frustrado às vezes por algum bug em seu código

702
00: 33: 51,450 -> 00: 33: 52.950
e você pode estar olhando para ele.

703
00: 33: 52,950 -> 00: 33: 53.940
Você pode estar pensando nisso.

704
00: 33: 53,940 -> 00: 33: 56.790
Você pode tentar todas essas ferramentas danadas, vai para os tutoriais feitos em sala,

705
00: 33: 56,790 -> 00: 33: 59.400
e ainda não está funcionando para você.

706
00: 33: 59,400 -> 00: 34: 01.920
Francamente, a solução é dar um passo para trás.

707
00: 34: 01,920 -> 00: 34: 06.580
E eu não consigo enfatizar o suficiente o valor de correr, fazer uma pausa,

708
00: 34: 06,580 -> 00: 34: 08.580
fazendo outra coisa, mudando seu modelo mental

709
00: 34: 08,580 -> 00: 34: 10.020
e voltar a ele mais tarde.

710
00: 34: 10,020 -> 00: 34: 14.580
Eu literalmente, e tenho certeza que muitos dos TFs e TAs resolveram código

711
00: 34: 14,580 -> 00: 34: 17.670
enquanto adormece, porque lá, você está meio pensativo

712
00: 34: 17,670 -> 00: 34: 20.639
pensando no que você fez, no que está tentando fazer.

713
00: 34: 20,639 -> 00: 34: 23.738
Mas, sem dúvida, ajuda conversar algum tempo sobre seus problemas.

714
00: 34: 23,738 -> 00: 34: 26.280
E há este outro termo da arte na ciência da computação chamado

715
00: 34: 26,280 -> 00: 34: 27.570
depuração de pato de borracha.

716
00: 34: 27,570 -> 00: 34: 30.690
A ideia é que, se você não tiver um TF ao seu lado

717
00: 34: 30,690 -> 00: 34: 34.080
ou CA ao seu lado ou colega de quarto que tem alguma ideia do que você está falando quando

718
00: 34: 34,080 -> 00: 34: 37.472
se trata de programação, você pode ter uma dessas pequenas coisas em sua mesa

719
00: 34: 37,472 -> 00: 34: 39.389
que você pode literalmente, provavelmente com a porta

720
00: 34: 39,389 -> 00: 34: 43.320
fechado, comece a conversar, a explicar para o pato, assim como faria

721
00: 34: 43,320 -> 00: 34: 47.580
um professor, o que você acha que seu código está fazendo, percorrendo

722
00: 34: 47,580 -> 00: 34: 49.710
verbalmente, linha por linha, até que, com sorte, você

723
00: 34: 49,710 -> 00: 34: 52.710
ter aquele momento de aha auto-induzido, como oh, espere um minuto,

724
00: 34: 52,710 -> 00: 34: 55.718
deveria ser 10, não 11, ponto em que,

725
00: 34: 55,718 -> 00: 34: 58.260
você discretamente põe o pato de volta no chão e continua seu trabalho.

726
00: 34: 58,260 -> 00: 35: 01.320
Mas destina-se a ser este proxy para apenas

727
00: 35: 01,320 -> 00: 35: 04.595
um processo pensativo muito deliberado ao qual todos são bem-vindos.

728
00: 35: 04,595 -> 00: 35: 06.720
Você é bem-vindo para pegar um pato hoje ao sair

729
00: 35: 06,720 -> 00: 35: 08.490
e temos muitos mais tutoriais e horas de trabalho,

730
00: 35: 08,490 -> 00: 35: 10.260
porque isso não é suficiente aqui hoje.

731
00: 35: 10,260 -> 00: 35: 12.900
Isso é porque isso existe.

732
00: 35: 12,900 -> 00: 35: 18.390
Mas o objetivo com a depuração de pato de borracha é apenas aquele mecanismo humano adicional

733
00: 35: 18,390 -> 00: 35: 22.260
para resolver problemas tirando a ênfase das ferramentas

734
00: 35: 22,260 -> 00: 35: 24.150
e colocá-lo realmente de volta no humano.

735
00: 35: 24,150 -> 00: 35: 27.000
Então, se um pouco desajeitado socialmente, considere

736
00: 35: 27.000 -> 00: 35: 30.870
implantando essa ferramenta conforme necessário também.

737
00: 35: 30,870 -> 00: 35: 34.110
Então, tudo se concentra na correção e no estilo,

738
00: 35: 34,110 -> 00: 35: 36.323
e isso é realmente o que todos os problemas definidos lá fora

739
00: 35: 36,323 -> 00: 35: 37.740
vai ter como um componente.

740
00: 35: 37,740 -> 00: 35: 40.020
Funciona corretamente e tem um estilo bom?

741
00: 35: 40,020 -> 00: 35: 42.090
Mas o terceiro eixo de qualidade, quando se trata de

742
00: 35: 42,090 -> 00: 35: 45.360
escrever software, não apenas para CS50, mas realmente em geral

743
00: 35: 45,360 -> 00: 35: 49.050
com a programação no mundo real, é essa noção de design.

744
00: 35: 49,050 -> 00: 35: 53.070
E o design ainda não é algo que possamos avaliar com software,

745
00: 35: 53,070 -> 00: 35: 55.020
e diga que você projetou bem ou não

746
00: 35: 55.020 -> 00: 35: 57.450
projetar bem, é mais uma medida subjetiva.

747
00: 35: 57,450 -> 00: 35: 59.610
E aqui, também, pessoas razoáveis ​​podem discordar.

748
00: 35: 59,610 -> 00: 36: 02.760
Então, vamos nos concentrar, não apenas hoje, mas nas próximas semanas,

749
00: 36: 02,760 -> 00: 36: 06.540
é também o processo de escrever um software bem projetado

750
00: 36: 06,540 -> 00: 36: 10.230
e tomar decisões mais inteligentes para não apenas resolver o problema,

751
00: 36: 10,230 -> 00: 36: 11.640
mas para resolvê-lo bem.

752
00: 36: 11,640 -> 00: 36: 14.732
E isso é o que engenheiros de software em tempo integral nos Facebooks e Googles

753
00: 36: 14,732 -> 00: 36: 16.440
e a Microsofts e outros do mundo fazem

754
00: 36: 16,440 -> 00: 36: 19.380
todos os dias, especialmente quando eles têm grandes quantidades de dados

755
00: 36: 19,380 -> 00: 36: 20.730
e muitos, muitos usuários.

756
00: 36: 20,730 -> 00: 36: 25.560
Cada decisão de design que eles tomam importa e pode custar dinheiro ou ciclos de CPU

757
00: 36: 25,560 -> 00: 36: 26.710
ou memória.

758
00: 36: 26,710 -> 00: 36: 28.620
E, de fato, pense na semana zero, encontrando

759
00: 36: 28,620 -> 00: 36: 31.200
Mike Smith era possível de três maneiras diferentes,

760
00: 36: 31,200 -> 00: 36: 33.270
mas a terceira via, a divisão e conquista,

761
00: 36: 33,270 -> 00: 36: 35.400
foi sem dúvida o mais eficiente.

762
00: 36: 35,400 -> 00: 36: 37.830
Isso foi melhor projetado do que o primeiro casal.

763
00: 36: 37,830 -> 00: 36: 41.220
Então, vamos agora considerar isso no contexto da programação

764
00: 36: 41,220 -> 00: 36: 45.900
e como podemos usar alguns novos recursos hoje em C para resolver problemas melhor

765
00: 36: 45,900 -> 00: 36: 48.540
e escrever um código melhor projetado.

766
00: 36: 48,540 -> 00: 36: 52.080
E faremos isso primeiro por meio de algo que é chamado de array.

767
00: 36: 52,080 -> 00: 36: 56.520
Portanto, um array é algo que nos permite resolver um problema,

768
00: 36: 56,520 -> 00: 36: 59.890
talvez da seguinte maneira.

769
00: 36: 59,890 -> 00: 37: 02.640
Então, em nossos computadores -

770
00: 37: 02,640 -> 00: 37: 06.390
em nossos programas em C, temos opções de vários tipos de dados.

771
00: 37: 06,390 -> 00: 37: 09.630
Vimos que há chars, há ints, há floats, há longs,

772
00: 37: 09,630 -> 00: 37: 12.510
há duplas, há bool, agora há string,

773
00: 37: 12,510 -> 00: 37: 14.550
e há alguns outros também.

774
00: 37: 14,550 -> 00: 37: 18.180
E cada um deles, dependendo do sistema de computador que você está usando,

775
00: 37: 18,180 -> 00: 37: 22.050
ocupa uma quantidade específica de espaço, no CS50, IDE, na sandbox,

776
00: 37: 22,050 -> 00: 37: 24.750
e provavelmente em seus próprios Macs e PCs pessoais.

777
00: 37: 24,750 -> 00: 37: 27.120
Hoje em dia, cada um desses tipos de dados,

778
00: 37: 27,120 -> 00: 37: 30.180
se você está escrevendo um programa em C, ocupa muito espaço,

779
00: 37: 30,180 -> 00: 37: 33.630
onde um byte é de 8 bits, 4 bytes é de 32 bits,

780
00: 37: 33,630 -> 00: 37: 37.450
8 bytes são 64 bits, para lincar de volta à semana zero.

781
00: 37: 37,450 -> 00: 37: 39.930
Então, esses são tipos de dados que temos à nossa disposição

782
00: 37: 39,930 -> 00: 37: 42.660
para quaisquer variáveis ​​na memória do nosso computador.

783
00: 37: 42,660 -> 00: 37: 44.400
Então, por que isso é pertinente aqui?

784
00: 37: 44,400 -> 00: 37: 46.530
Bem, isso é o que eu mostrei algumas semanas

785
00: 37: 46,530 -> 00: 37: 49.440
atrás também, que é representativo de RAM, memória de acesso aleatório.

786
00: 37: 49,440 -> 00: 37: 52.880
Hoje em dia, é uma das peças do disco rígido do seu macro PC ou mesmo do telefone.

787
00: 37: 52,880 -> 00: 37: 56.730
E cada uma dessas fichas pretas representa algum número de bytes.

788
00: 37: 56,730 -> 00: 37: 58.680
As probabilidades são pequenas, embora na realidade,

789
00: 37: 58,680 -> 00: 38: 02.730
possa representar um bilhão de bytes se você tiver um gigabyte de memória,

790
00: 38: 02,730 -> 00: 38: 04.560
ou talvez até mais do que isso nos dias de hoje.

791
00: 38: 04,560 -> 00: 38: 07.860
Mas este pequeno chip preto, dentro do seu Mac, PC ou telefone,

792
00: 38: 07,860 -> 00: 38: 11.190
é onde as informações são armazenadas quando você está executando o software,

793
00: 38: 11,190 -> 00: 38: 13.860
seja em um desktop, laptop ou dispositivo móvel.

794
00: 38: 13,860 -> 00: 38: 16.440
E podemos realmente pensar neste chip apenas como

795
00: 38: 16,440 -> 00: 38: 19.770
sendo dividido em um monte de bytes individuais diferentes.

796
00: 38: 19,770 -> 00: 38: 21.900
Na verdade, vamos aumentar o zoom arbitrariamente

797
00: 38: 21,900 -> 00: 38: 24.030
e meio que dividi-lo em linhas e colunas,

798
00: 38: 24,030 -> 00: 38: 27.870
e apenas afirmar que o canto superior esquerdo aqui será o primeiro byte.

799
00: 38: 27,870 -> 00: 38: 30.240
Este é o segundo byte, o terceiro byte, e bem abaixo

800
00: 38: 30,240 -> 00: 38: 32.880
aqui é como o bilionésimo byte de memória no meu computador,

801
00: 38: 32,880 -> 00: 38: 36.420
obviamente não desenhado em escala, o que significa que podemos simplesmente numerar esses bytes.

802
00: 38: 36,420 -> 00: 38: 38.830
Então, um, dois, três, quatro, cinco, seis, sete, oito,

803
00: 38: 38,830 -> 00: 38: 43.030
ou ser realmente ciência da computação como zero, um, dois, três, quatro, cinco, seis,

804
00: 38: 43,030 -> 00: 38: 45.010
sete e assim por diante.

805
00: 38: 45,010 -> 00: 38: 46.860
Portanto, não precisamos saber nada sobre como

806
00: 38: 46,860 -> 00: 38: 50.172
RAM funciona, eletricamente ou fisicamente, mas vamos

807
00: 38: 50,172 -> 00: 38: 52.380
apenas estipule que se você tiver alguma quantidade de RAM,

808
00: 38: 52,380 -> 00: 38: 56.220
podemos certamente pensar em cada byte como tendo um número.

809
00: 38: 56,220 -> 00: 38: 57.510
Então, o que isso faz por nós?

810
00: 38: 57.510 -> 00: 39: 01.560
Bem, se você escrever um programa que tem um char nele, um caractere,

811
00: 39: 01,560 -> 00: 39: 05.310
quão grande era um char de acordo com o gráfico um momento atrás?

812
00: 39: 05,310 -> 00: 39: 06.210
Então, apenas um byte.

813
00: 39: 06,210 -> 00: 39: 11.380
Então, se você alocar um char, chamado c, ou chamar qualquer coisa em seu programa,

814
00: 39: 11,380 -> 00: 39: 14.977
você vai pedir ao computador para usar apenas um desses pequenos quadrados

815
00: 39: 14,977 -> 00: 39: 16.810
fisicamente dentro da memória do seu computador.

816
00: 39: 16,810 -> 00: 39: 19.990
Por outro lado, que tal um int - quão grande era um int?

817
00: 39: 19,990 -> 00: 39: 20.590
Quatro bytes.

818
00: 39: 20,590 -> 00: 39: 23.130
Então, se você quiser armazenar um número como um inteiro,

819
00: 39: 23,130 -> 00: 39: 26.380
você vai consumir quatro desses bytes na memória do seu computador

820
00: 39: 26,380 -> 00: 39: 26.880
em vez de.

821
00: 39: 26,880 -> 00: 39: 30.970
E se você estiver usando um double ou long, você pode usar até oito deles.

822
00: 39: 30,970 -> 00: 39: 32.903
Então, o que há dentro de cada uma dessas caixas?

823
00: 39: 32,903 -> 00: 39: 35.320
Há oito bits aqui, oito bits aqui, oito bits aqui,

824
00: 39: 35,320 -> 00: 39: 37.960
ou talvez sejam oito pequenos transistores, ou mesmo oito pequenas lâmpadas.

825
00: 39: 37,960 -> 00: 39: 41.050
O que quer que sejam, são uma forma de representar zeros e uns.

826
00: 39: 41,050 -> 00: 39: 43.480
E é isso que cada uma dessas caixas representa.

827
00: 39: 43,480 -> 00: 39: 45.410
Então, o que podemos fazer com essas informações?

828
00: 39: 45,410 -> 00: 39: 47.410
Bem, vamos em frente e nos livrar do hardware

829
00: 39: 47,410 -> 00: 39: 49.660
e abstrair, por assim dizer, à medida que continuamos fazendo,

830
00: 39: 49,660 -> 00: 39: 54.690
e considere se ampliarmos aqui, como o computador, semana passada e esta semana

831
00: 39: 54,690 -> 00: 39: 58.990
acabar para sempre aqui fora, é armazenar as informações nos programas

832
00: 39: 58,990 -> 00: 40: 00.280
que você escreve.

833
00: 40: 00,280 -> 00: 40: 04.330
Suponha, por exemplo, que temos um programa como este,

834
00: 40: 04,330 -> 00: 40: 05.770
com apenas três caracteres nele.

835
00: 40: 05,770 -> 00: 40: 11.860
Vou prosseguir e reunir isso em um arquivo chamado, digamos, hi.c

836
00: 40: 11,860 -> 00: 40: 15.880
E vou prosseguir e incluir stdio.h, int main void -

837
00: 40: 15,880 -> 00: 40: 18.550


838
00: 40: 18,550 -> 00: 40: 19.533
Aprendendo.

839
00: 40: 19,533 -> 00: 40: 22.450
Agora aqui, vou prosseguir e ter essas três linhas de código.

840
00: 40: 22,450 -> 00: 40: 25.090
Então me dê um char chamado c1 arbitrariamente

841
00: 40: 25,090 -> 00: 40: 27.820
e defina-o igual a H maiúsculo. Dê-me outro chamado
s
842
00: 40: 27,820 -> 00: 40: 31.870
c2, defina-o igual a I maiúsculo. Dê-me um terceiro chamado c3,

843
00: 40: 31,870 -> 00: 40: 34.630
e defina isso igual ao ponto de exclamação.

844
00: 40: 34,630 -> 00: 40: 40.180
Agora você notará um detalhe que não enfatizei antes, acho que não.

845
00: 40: 40,180 -> 00: 40: 44.350
Que tipo de pontuação estou claramente usando aqui?

846
00: 40: 44,350 -> 00: 40: 46.510
Portanto, aspas simples ou apóstrofos aqui.

847
00: 40: 46,510 -> 00: 40: 49.840
As aspas simples em C são necessárias para caracteres.

848
00: 40: 49,840 -> 00: 40: 52.110
Chars ou caracteres únicos, apenas um byte.

849
00: 40: 52,110 -> 00: 40: 54.610
Sempre que você quiser codificá-los em um programa como este,

850
00: 40: 54,610 -> 00: 40: 56.450
como fiz aqui, use aspas simples.

851
00: 40: 56,450 -> 00: 40: 59.540
É claro que para strings usamos aspas duplas.

852
00: 40: 59,540 -> 00: 41: 00.040
Por quê?

853
00: 41: 00,040 -> 00: 41: 00.820
Só porque.

854
00: 41: 00,820 -> 00: 41: 03.160
Como C exige que distingamos os dois.

855
00: 41: 03,160 -> 00: 41: 05.518
Então deixe-me fazer algo um pouco bobo aqui.

856
00: 41: 05,518 -> 00: 41: 07.810
Agora que tenho três variáveis, deixe-me ir em frente

857
00: 41: 07,810 -> 00: 41: 08.770
e imprimi-los todos.

858
00: 41: 08,770 -> 00: 41: 10.480
Qual é o código de formato que posso imprimir -

859
00: 41: 10,480 -> 00: 41: 12.480
Posso usar para imprimir um char?

860
00: 41: 12,480 -> 00: 41: 13.960
Sim, um por cento -

861
00: 41: 13,960 -> 00: 41: 15.340
PÚBLICO: [INAUDÍVEL]

862
00: 41: 15,340 -> 00: 41: 18.475
DAVID MALAN: %c para char, então %c, e eu quero três deles.

863
00: 41: 18,475 -> 00: 41: 21.380
Vou imprimir os três de uma vez, seguidos por uma nova linha.

864
00: 41: 21,380 -> 00: 41: 23.560
E então, se eu quiser imprimir c1 primeiro, c2,

865
00: 41: 23,560 -> 00: 41: 28.270
c3, essa é a sintaxe com printf para apenas conectar em três 

866
00: 41: 28,270 -> 00: 41: 31.390
posições seguidas por três valores, respectivamente da esquerda para a direita,

867
00: 41: 31,390 -> 00: 41: 34.600
e esperançosamente vai imprimir, presumivelmente oi

868
00: 41: 34,600 -> 00: 41: 36.500
na tela seguido por uma nova linha.

869
00: 41: 36,500 -> 00: 41: 37.970
Deixe-me salvar o arquivo.

870
00: 41: 37,970 -> 00: 41: 39.860
Deixe-me make hi

871
00: 41: 39,860 -> 00: 41: 41.200
OK, sem erros, o que é bom.

872
00: 41: 41,200 -> 00: 41: 46.330
Deixe-me fazer ./hi, e de fato vejo um ponto de exclamação

873
00: 41: 46,330 -> 00: 41: 49.330
com um espaço entre cada caracter.

874
00: 41: 49,330 -> 00: 41: 50.350
Mas você sabe o que?

875
00: 41: 50,350 -> 00: 41: 56.200
"hi!" são de fato chars, mas o que é um char ou um caractere?

876
00: 41: 56,200 -> 00: 41: 58.740
O que é um charactere Ascii por baixo do capô?

877
00: 41: 58,740 -> 00: 41: 59.680
PÚBLICO: [INAUDÍVEL]

878
00: 41: 59,680 -> 00: 42: 00.700
DAVID MALAN: Em última análise, é binário.

879
00: 42: 00,700 -> 00: 42: 01.630
Tudo é binário.

880
00: 42: 01,630 -> 00: 42: 04.025
E qual é o passo intermediário, em certo sentido?

881
00: 42: 04,025 -> 00: 42: 04.900
PÚBLICO: [INAUDÍVEL]

882
00: 42: 04,900 -> 00: 42: 06.733
DAVID MALAN: É apenas um número, um inteiro.

883
00: 42: 06,733 -> 00: 42: 09.220
Graças a Ascii e Unicode na semana zero,

884
00: 42: 09,220 -> 00: 42: 12.007
há apenas um mapeamento de caracteres para números.

885
00: 42: 12,007 -> 00: 42: 13.090
Então, como faço para imprimir números?

886
00: 42: 13,090 -> 00: 42: 15.154
Que código de formato devo usar para printf?

887
00: 42: 15,154 -> 00: 42: 16.810
PÚBLICO: [INAUDÍVEL]

888
00: 42: 16,810 -> 00: 42: 19.390
DAVID MALAN: Porcentagem i, para inteiro.

889
00: 42: 19,390 -> 00: 42: 22.360
Então, suponha que eu queira realmente ver esses valores?

890
00: 42: 22,360 -> 00: 42: 23.710
Observe o que posso fazer.

891
00: 42: 23,710 -> 00: 42: 26.020
Eu posso dizer ao computador, sabe de uma coisa?

892
00: 42: 26,020 -> 00: 42: 30.190
Mesmo que c1 seja um caractere, vá em frente e trate-o como um inteiro.

893
00: 42: 30,190 -> 00: 42: 33.740
E posso literalmente escrever int entre parênteses antes da variável,

894
00: 42: 33,740 -> 00: 42: 36.790
que é conhecido como casting, C-A-S-T,

895
00: 42: 36,790 -> 00: 42: 41.410
que é apenas um verbo que descreve o ato de converter um tipo de dados em outro

896
00: 42: 41,410 -> 00: 42: 43.240
para que eu possa realmente ver esses números.

897
00: 42: 43,240 -> 00: 42: 45.240
Deixe-me prosseguir e salvar o arquivo.

898
00: 42: 45,240 -> 00: 42: 50.530
Deixe-me ir em frente e make hi novamente.

899
00: 42: 50,530 -> 00: 42: 51.790
Isso parece funcionar bem.

900
00: 42: 51,790 -> 00: 42: 57.880
./hi, e agora este velho familiar 72, 73, 33.

901
00: 42: 57,880 -> 00: 43: 00.040
E, francamente, não preciso ser tão pedante aqui.

902
00: 43: 00,040 -> 00: 43: 04.300
Francamente, o clang é inteligente o suficiente para saber que se eu passar um char,

903
00: 43: 04,300 -> 00: 43: 06.340
mas peço que formate é um int, 

904
00: 43: 06,340 -> 00: 43: 09.980
irá implicitamente, não explicitamente, lançá-lo para mim.

905
00: 43: 09,980 -> 00: 43: 13.720
Então, se eu for em frente e executo make hi de novo, e faço ./hi,

906
00: 43: 13,720 -> 00: 43: 15.390
Vou ver exatamente a mesma coisa.

907
00: 43: 15,390 -> 00: 43: 17.890
Então, essa compreensão do que está acontecendo por baixo do capô

908
00: 43: 17,890 -> 00: 43: 20.260
pode me permitir meio que mexer agora e brincar

909
00: 43: 20,260 -> 00: 43: 22.990
com o que está acontecendo dentro da memória do meu computador.

910
00: 43: 22,990 -> 00: 43: 25.120
Mas agora vamos ver isso mais visualmente.

911
00: 43: 25,120 -> 00: 43: 27.700
Se esta é a memória do meu computador realmente ampliada,

912
00: 43: 27,700 -> 00: 43: 31.270
de modo que há cerca de um bilhão de quadrados em algum lugar disponível para mim

913
00: 43: 31,270 -> 00: 43: 33.490
e este é zero, este é um, este é dois.

914
00: 43: 33,490 -> 00: 43: 37.300
Suponha que eu tenha um programa com três variáveis ​​- c1, c2 e c3 -

915
00: 43: 37,300 -> 00: 43: 39.100
o que o computador vai fazer vai

916
00: 43: 39,100 -> 00: 43: 41.180
para colocar h em uma dessas caixas.

917
00: 43: 41,180 -> 00: 43: 43.180
Vai colocar o i em outra caixa, e 

918
00: 43: 43,180 -> 00: 43: 45.190
vai colocar o ponto de exclamação em uma terceira caixa,

919
00: 43: 45,190 -> 00: 43: 48.490
e de uma forma ou de outra vai rotulá-los com os nomes das variáveis.

920
00: 43: 48,490 -> 00: 43: 52.420
Vai ser uma espécie de anotação como com um lápis virtual, este é c1, este é c2,

921
00: 43: 52,420 -> 00: 43: 53.500
este é c3.

922
00: 43: 53,500 -> 00: 43: 56.170
Mas é o ponto de exclamação H-I que é

923
00: 43: 56,170 -> 00: 43: 58.660
realmente armazenados naquele local.

924
00: 43: 58,660 -> 00: 44: 00.190
Mas é claro, não é apenas um char.

925
00: 44: 00,190 -> 00: 44: 01.697
É realmente tecnicamente um número.

926
00: 44: 01,697 -> 00: 44: 04.030
O que realmente está acontecendo na memória do meu computador

927
00: 44: 04,030 -> 00: 44: 06.740
é que 72, 73 e 33 estão armazenados.

928
00: 44: 06,740 -> 00: 44: 09.430
Mas alguém disse antes que é binário.

929
00: 44: 09,430 -> 00: 44: 13.030
Então o que está realmente por baixo do capô é isso.

930
00: 44: 13,030 -> 00: 44: 15.280
Esses zeros e uns são implementados de alguma forma

931
00: 44: 15,280 -> 00: 44: 18.190
com transistores ou lâmpadas ou qualquer que seja a tecnologia,

932
00: 44: 18,190 -> 00: 44: 20.830
mas está apenas armazenando um padrão de zeros e uns.

933
00: 44: 20,830 -> 00: 44: 22.360
E eu fiz a matemática antes da aula.

934
00: 44: 22,360 -> 00: 44: 26.650
Na verdade, isso representa 72 no decimal, 73 e 33.

935
00: 44: 26,650 -> 00: 44: 30.310
Mas aqui também estamos chegando a um detalhe de implementação de baixo nível

936
00: 44: 30,310 -> 00: 44: 32.380
que geralmente não precisamos nos preocupar.

937
00: 44: 32,380 -> 00: 44: 35.260
Abstração, por semana zero, é essa coisa linda

938
00: 44: 35,260 -> 00: 44: 38.170
porque poderíamos apenas, hum, desligar tudo isso e apenas pensar

939
00: 44: 38,170 -> 00: 44: 41.650
dele em qualquer nível superior que quisermos, seja decimal

940
00: 44: 41,650 -> 00: 44: 44.230
ou se são personagens Ascii reais.

941
00: 44: 44,230 -> 00: 44: 46.640
Mas isso é tudo o que está acontecendo por baixo do capô.

942
00: 44: 46,640 -> 00: 44: 47.140
Sim?

943
00: 44: 47,140 -> 00: 44: 51.028
PÚBLICO: [INAUDÍVEL]

944
00: 44: 51,028 -> 00: 44: 55.383


945
00: 44: 55,383 -> 00: 44: 56.800
DAVID MALAN: Boa pergunta.

946
00: 44: 56,800 -> 00: 45: 02.200
Se você declarou três variáveis ​​como inteiros e armazenou 72, 73, 33 nelas

947
00: 45: 02,200 -> 00: 45: 04.840
e tentar imprimi-los então com %c,

948
00: 45: 04,840 -> 00: 45: 08.260
sim, você também poderia coagir esse comportamento e, literalmente, fazer o oposto.

949
00: 45: 08,260 -> 00: 45: 11.410
Nesse ponto, você precisa saber quais são os códigos ASCII -

950
00: 45: 11,410 -> 00: 45: 12.850
72, 73, 33.

951
00: 45: 12,850 -> 00: 45: 15.460
E principalmente, os programadores não se importam com isso.

952
00: 45: 15,460 -> 00: 45: 18.340
Tudo o que eles fazem é saber que há algum mapeamento por baixo do capô,

953
00: 45: 18,340 -> 00: 45: 19.510
mas absolutamente.

954
00: 45: 19,510 -> 00: 45: 22.090
Bem, vamos considerar outro exemplo agora, desta vez envolvendo

955
00: 45: 22,090 -> 00: 45: 26.290
três pontos, então três inteiros, em vez de algo como três caracteres.

956
00: 45: 26,290 -> 00: 45: 29.000
O que posso realmente fazer com valores como esse?

957
00: 45: 29.000 -> 00: 45: 32.110
Bem, deixe-me prosseguir e escrever algum código, desta vez em um arquivo

958
00: 45: 32,110 -> 00: 45: 35.977
chamado pontos.c.

959
00: 45: 35,977 -> 00: 45: 38.560
Vou limpar meu terminal aqui e criar

960
00: 45: 38,560 -> 00: 45: 42.220
um novo arquivo chamado pontos.c.

961
00: 45: 42,220 -> 00: 45: 45.550
E vamos prosseguir e fazer algumas linhas semelhantes aqui.

962
00: 45: 45,550 -> 00: 45: 50.830
Deixe-me ir em frente e incluir, digamos, CS50.h, incluir stdio.h,

963
00: 45: 50,830 -> 00: 45: 55.360
int main void, e agora vou em frente e começar a declarar algumas variáveis.

964
00: 45: 55,360 -> 00: 45: 56.790
Dê-me a pontuação inicial um.

965
00: 45: 56,790 -> 00: 45: 59.560
E vou declarar minha pontuação em alguma tarefa

966
00: 45: 59,560 -> 00: 46: 03.900
ser 72, outra pontuação em uma tarefa ser aproximadamente o mesmo, 73,

967
00: 46: 03,900 -> 00: 46: 06.970
e outra atribuição lamentável ser, digamos, 33.

968
00: 46: 06,970 -> 00: 46: 09.910
Agora tenho três variáveis ​​chamadas inteiros e suponha que eu só queira

969
00: 46: 09,910 -> 00: 46: 11.770
para fazer algo como imprimir a média.

970
00: 46: 11,770 -> 00: 46: 14.170
Certamente posso fazer isso com printf e alguma matemática.

971
00: 46: 14,170 -> 00: 46: 18.537
Posso ir em frente e dizer que a média é% i,

972
00: 46: 18,537 -> 00: 46: 20.870
onde isso será um espaço reservado, em seguida, uma nova linha.

973
00: 46: 20,870 -> 00: 46: 23.912
E então a média, é claro, será algo como pontuação um,

974
00: 46: 23,912 -> 00: 46: 28.990
mais pontuação dois, mais pontuação três, dividido por três no total, e então

975
00: 46: 28,990 -> 00: 46: 29.810
ponto e vírgula.

976
00: 46: 29,810 -> 00: 46: 30.760
Então, novamente, essa é apenas a média.

977
00: 46: 30,760 -> 00: 46: 33.510
Some três números, divida pelo número total e voila,

978
00: 46: 33,510 -> 00: 46: 35.020
devemos obter uma média.

979
00: 46: 35,020 -> 00: 46: 40.120
Deixe-me prosseguir e salvar o arquivo, compilar com make scores, Enter.

980
00: 46: 40,120 -> 00: 46: 42.370
Parece compilar OK - ./scores

981
00: 46: 42,370 -> 00: 46: 46.420
E devo obter uma média de 59 para essas três pontuações do questionário, ou tarefa

982
00: 46: 46,420 -> 00: 46: 48.260
pontuações, neste contexto.

983
00: 46: 48,260 -> 00: 46: 50.350
Mas este não é o melhor design agora.

984
00: 46: 50,350 -> 00: 46: 52.600
Agora que estamos lidando com números e pontuações,

985
00: 46: 52,600 -> 00: 46: 55.100
especialmente no contexto de uma aula onde talvez você esteja

986
00: 46: 55,100 -> 00: 46: 58.300
vai ter quatro pontuações ou cinco pontuações ou mais pontuações, em última análise,

987
00: 46: 58,300 -> 00: 46: 59.320
semana a semana.

988
00: 46: 59,320 -> 00: 47: 03.132
O que talvez o incomode neste design até agora?

989
00: 47: 03,132 -> 00: 47: 04.392
PÚBLICO: [INAUDÍVEL]

990
00: 47: 04,392 -> 00: 47: 05.350
DAVID MALAN: Diga novamente.

991
00: 47: 05,350 -> 00: 47: 06.752
PÚBLICO: I

992
00: 47: 06,752 -> 00: 47: 08.210
DAVID MALAN: Sim, está muito fixo.

993
00: 47: 08,210 -> 00: 47: 10.310
É como escrever um programa no início do semestre

994
00: 47: 10,310 -> 00: 47: 13.102
e decidir com antecedência que haverá apenas três atribuições,

995
00: 47: 13,102 -> 00: 47: 15.140
e se você quiser um quarto, que pena.

996
00: 47: 15,140 -> 00: 47: 17.010
O software não oferece suporte para isso.

997
00: 47: 17,010 -> 00: 47: 18.260
Portanto, esse não é o melhor design.

998
00: 47: 18,260 -> 00: 47: 21.650
E o que mais você pode criticar sobre este código, por mais simples que seja.

999
00: 47: 21,650 -> 00: 47: 22.396
Sim?

1000
00: 47: 22,396 -> 00: 47: 26.204
PÚBLICO: [INAUDÍVEL]

1001
00: 47: 26,204 -> 00: 47: 28.110


1002
00: 47: 28,110 -> 00: 47: 30.600
DAVID MALAN: Sim, estou potencialmente enganando os alunos

1003
00: 47: 30,600 -> 00: 47: 34.320
de uma pontuação parcial, especialmente se sua média fosse 59,5.

1004
00: 47: 34,320 -> 00: 47: 36.470
Eu gostaria de ser arredondado para 60, por exemplo.

1005
00: 47: 36,470 -> 00: 47: 38.520
Portanto, também estamos tendo alguns problemas de imprecisão.

1006
00: 47: 38,520 -> 00: 47: 40.020
E voltaremos a isso também.

1007
00: 47: 40,020 -> 00: 47: 40.740
Alguma outra crítica?

1008
00: 47: 40,740 -> 00: 47: 41.240
Sim?

1009
00: 47: 41,240 -> 00: 47: 44.720
PÚBLICO: [INAUDÍVEL]

1010
00: 47: 44,720 -> 00: 47: 47.930
DAVID MALAN: Sim, embora eu tenha digitado manualmente,

1011
00: 47: 47,930 -> 00: 47: 51.137
isso está perigosamente perto de apenas copiar e colar o mesmo código novamente

1012
00: 47: 51,137 -> 00: 47: 51.970
e novamente e novamente.

1013
00: 47: 51,970 -> 00: 47: 55.570
Assim, apenas com o exemplo "hi", como com este, como com nosso exemplo de tosse

1014
00: 47: 55,570 -> 00: 47: 59.470
semana passada e na semana anterior, apenas fazendo essa coisa de novo e de novo

1015
00: 47: 59,470 -> 00: 48: 02.260
e novamente é realmente uma oportunidade para um design melhor.

1016
00: 48: 02,260 -> 00: 48: 05.020
Acontece que existe essa oportunidade.

1017
00: 48: 05,020 -> 00: 48: 10.490
E em C, se você sabe que deseja ter mais do que apenas um valor,

1018
00: 48: 10,490 -> 00: 48: 12.610
mas estão todos relacionados, o que pode

1019
00: 48: 12,610 -> 00: 48: 16.720
ser um bom nome para uma variável contendo múltiplas pontuações?

1020
00: 48: 16,720 -> 00: 48: 17.620
PÚBLICO: [INAUDÍVEL]

1021
00: 48: 17,620 -> 00: 48: 19.420
DAVID MALAN: Pontuações no plural em inglês.

1022
00: 48: 19,420 -> 00: 48: 20.990
Então, como podemos fazer isso?

1023
00: 48: 20,990 -> 00: 48: 23.650
Bem, infelizmente, se eu disser apenas pontuações,

1024
00: 48: 23,650 -> 00: 48: 25.650
Preciso decidir qual pontuação recebe como valor.

10: 25h
00: 48: 25,650 -> 00: 48: 27.942
Agora, aqueles de vocês que têm experiência anterior em programação,

1026
00: 48: 27,942 -> 00: 48: 31.030
pode saber para onde estamos indo com isso, e estamos prestes a chegar lá.

1027
00: 48: 31,030 -> 00: 48: 34.990
Acontece em C, se você quiser ter uma variável que

1028
00: 48: 34,990 -> 00: 48: 39.430
pode armazenar vários valores, você usa o que é chamado de array.

1029
00: 48: 39,430 -> 00: 48: 44.680
Uma matriz é uma lista de valores que podem ser todos do mesmo tipo

1030
00: 48: 44,680 -> 00: 48: 46.790
em uma variável de mesmo nome.

1031
00: 48: 46,790 -> 00: 48: 50.140
Então, se você quiser três pontuações, cada uma sendo um int em C,

1032
00: 48: 50,140 -> 00: 48: 53.620
você literalmente usa colchetes, o número de pontuações que deseja,

1033
00: 48: 53,620 -> 00: 48: 54.640
e, em seguida, um ponto e vírgula.

1034
00: 48: 54,640 -> 00: 48: 58.750
Isso dirá ao computador, me dê memória suficiente para três inteiros.

1035
00: 48: 58,750 -> 00: 49: 01.340
Aqui embaixo agora, posso mudar minha sintaxe.

1036
00: 49: 01,340 -> 00: 49: 03.640
Não quero marcar um, marcar dois, marcar três.

1037
00: 49: 03,640 -> 00: 49: 10.240
Quero colocar essas pontuações dentro da matriz simplesmente dizendo seu nome,

1038
00: 49: 10,240 -> 00: 49: 14.530
usando colchetes, embora um pouco diferente desta vez,

1039
00: 49: 14,530 -> 00: 49: 17.420
e colocá-los nos locais um, dois, três,

1040
00: 49: 17,420 -> 00: 49: 19.150
mas esse é realmente meu primeiro erro.

1041
00: 49: 19,150 -> 00: 49: 22.320
Os cientistas da computação normalmente começam a contar em um -

1042
00: 49: 22,320 -> 00: 49: 26.170
não - os cientistas da computação geralmente começam a contar do zero,

1043
00: 49: 26,170 -> 00: 49: 29.590
então eu preciso zerar meu array.

1044
00: 49: 29,590 -> 00: 49: 34.360
As matrizes são indexadas por zero, o que significa apenas que o primeiro local é zero,

1045
00: 49: 34,360 -> 00: 49: 36.730
o segundo é um, o terceiro é dois.

1046
00: 49: 36,730 -> 00: 49: 39.960
Então, isso agora é um código equivalente a me dar três variáveis,

1047
00: 49: 39,960 -> 00: 49: 42.460
mas agora eu me livrei da confusão que você identificou

1048
00: 49: 42,460 -> 00: 49: 44.560
copiando e colando o nome repetidamente,

1049
00: 49: 44,560 -> 00: 49: 46.374
e posso armazená-los todos juntos.

1050
00: 49: 46,374 -> 00: 49: 50.573
PÚBLICO: Nas pontuações, o número três representa três variáveis,

1051
00: 49: 50,573 -> 00: 49: 51.073
certo?

1052
00: 49: 51,073 -> 00: 49: 53.440
Não significa quatro?

1053
00: 49: 53,440 -> 00: 49: 56.350
DAVID MALAN: Os três representam três variáveis?

1054
00: 49: 56,350 -> 00: 50: 02.110
Representa espaço suficiente para três valores em uma variável.

1055
00: 50: 02,110 -> 00: 50: 03.140
Boa pergunta.

1056
00: 50: 03,140 -> 00: 50: 05.035
Outros, perguntas?

1057
00: 50: 05,035 -> 00: 50: 05.535
Sim?

1058
00: 50: 05,535 -> 00: 50: 10.063
PÚBLICO: [INAUDÍVEL] trazendo iguais e depois [INAUDÍVEL]

1059
00: 50: 10,063 -> 00: 50: 11.480
DAVID MALAN: Boa pergunta.

1060
00: 50: 11,480 -> 00: 50: 13.070
Você pode fazer tudo isso em uma linha?

1061
00: 50: 13,070 -> 00: 50: 15.710
Sim, mas deixe-me provocá-lo dizendo algo

1062
00: 50: 15,710 -> 00: 50: 18.530
como este envolvendo chaves, mas não vamos falar disso hoje.

1063
00: 50: 18,530 -> 00: 50: 20.750
Mas sim, existem maneiras de contornar isso.

1064
00: 50: 20,750 -> 00: 50: 22.337
Deixe-me ir em frente e consertar isso agora.

1065
00: 50: 22,337 -> 00: 50: 24.170
Se eu quiser calcular a média agora, preciso

1066
00: 50: 24,170 -> 00: 50: 30.470
para adicionar esses três valores nesta matriz, marque zero, marque um e marque dois.

1067
00: 50: 30,470 -> 00: 50: 32.510
Mas aritmeticamente, a resposta -

1068
00: 50: 32,510 -> 00: 50: 37.280
o código ainda é o mesmo, então, se eu agora make scores e fizer ./scores,

1069
00: 50: 37,280 -> 00: 50: 38.680
minha média ainda é 59.

1070
00: 50: 38,680 -> 00: 50: 41.180
E eu não nego, provavelmente ainda há um bug matemático

1071
00: 50: 41,180 -> 00: 50: 43.580
porque se estivermos usando números inteiros, como foi observado,

1072
00: 50: 43,580 -> 00: 50: 46.110
mas voltaremos a isso daqui a pouco.

1073
00: 50: 46,110 -> 00: 50: 47.360
Então, vamos forçar um pouco mais forte.

1074
00: 50: 47,360 -> 00: 50: 50.720
Mesmo que você nunca tenha programado antes, o que ainda pode

1075
00: 50: 50,720 -> 00: 50: 52.970
ser um pouco ruim sobre o design.

1076
00: 50: 52,970 -> 00: 50: 55.250
O programa funciona, mas podemos fazer melhor.

1077
00: 50: 55,250 -> 00: 50: 57.170
PÚBLICO: Ainda armazena apenas três.

1078
00: 50: 57,170 -> 00: 50: 58.190
DAVID MALAN: Ainda armazena apenas três.

1079
00: 50: 58,190 -> 00: 51: 00.232
Então, nem resolvemos o primeiro problema.

1080
00: 51: 00,232 -> 00: 51: 01.010
Outras críticas?

1081
00: 51: 01,010 -> 00: 51: 02.845
PÚBLICO: [INAUDÍVEL]

1082
00: 51: 02,845 -> 00: 51: 04.970
DAVID MALAN: Tenho código demais na última linha.

1083
00: 51: 04,970 -> 00: 51: 06.710
Sim, está ficando um pouco prolixo, então é

1084
00: 51: 06,710 -> 00: 51: 08.752
um pouco mais difícil de ler - bastante justo.

1085
00: 51: 08,752 -> 00: 51: 09.570
Sim?

1086
00: 51: 09,570 -> 00: 51: 10.154
PÚBLICO: I

1087
00: 51: 10,154 -> 00: 51: 11.946
DAVID MALAN: Desculpe, diga um pouco mais alto.

1088
00: 51: 11.946 -> 00: 51: 14.080
PÚBLICO: As pontuações são codificadas no programa.

1089
00: 51: 14,080 -> 00: 51: 16.320
DAVID MALAN: Sim, as pontuações são codificadas no programa,

1090
00: 51: 16,320 -> 00: 51: 18.110
o que significa que não importa o que você recebe em suas atribuições,

1091
00: 51: 18,110 -> 00: 51: 19.670
estamos todos recebendo 59's.

1092
00: 51: 19,670 -> 00: 51: 21.400
Portanto, esse também é outro problema.

1093
00: 51: 21,400 -> 00: 51: 22.400
E alguma outra crítica?

1094
00: 51: 22,400 -> 00: 51: 23.060
Sim?

1095
00: 51: 23,060 -> 00: 51: 25.770
PÚBLICO: Se pudesse ler os dados de entrada, talvez fosse melhor.

1096
00: 51: 25,770 -> 00: 51: 27.770
DAVID MALAN: Se pudesse ler os dados de entrada - sim,

1097
00: 51: 27,770 -> 00: 51: 29.270
então deixe-me combinar essas sugestões.

1098
00: 51: 29,270 -> 00: 51: 31.930
Seria ótimo se, eventualmente, esse programa fosse dinâmico.

1099
00: 51: 31,930 -> 00: 51: 32.850
E mais alguma coisa?

1100
00: 51: 32,850 -> 00: 51: 33.513
Sim?

1101
00: 51: 33,513 -> 00: 51: 35.260
PÚBLICO: [INAUDÍVEL]

1102
00: 51: 35,260 -> 00: 51: 36.260
DAVID MALAN: Com certeza.

1103
00: 51: 36,260 -> 00: 51: 38.360
Podemos puxar o laço para a situação e realmente

1104
00: 51: 38,360 -> 00: 51: 40.595
obter vários valores do usuário.

1105
00: 51: 40,595 -> 00: 51: 44.470
PÚBLICO: Sempre dividindo por três, então [INAUDÍVEL]

1106
00: 51: 44,470 -> 00: 51: 46.720
DAVID MALAN: Sim, também é sempre dividido por três.

1107
00: 51: 46,720 -> 00: 51: 49.780
E isso é sutil, e ainda não é um grande problema,

1108
00: 51: 49,780 -> 00: 51: 53.290
mas há um princípio que estou violando aqui, conhecido

1109
00: 51: 53,290 -> 00: 51: 54.940
como não se repita.

1110
00: 51: 54,940 -> 00: 51: 58.090
E eu me repeti em pelo menos em dois locais.

1111
00: 51: 58,090 -> 00: 52: 01.310
Quais valores aparecem em dois locais?

1112
00: 52: 01,310 -> 00: 52: 04.750
Então, três aqui em cima, e também três aqui.

1113
00: 52: 04,750 -> 00: 52: 10.240
E por menor que pareça este detalhe, esta é a fonte de tantos bugs comuns

1114
00: 52: 10,240 -> 00: 52: 12.360
porque se você decidir por si mesmo,

1115
00: 52: 12,360 -> 00: 52: 13.630
bem, vou definir o código três aqui,

1116
00: 52: 13,630 -> 00: 52: 15.970
Vou fixar três no código aqui, as chances são,

1117
00: 52: 15,970 -> 00: 52: 18.650
de que amanhã de manhã, na próxima semana, no próximo mês, no próximo ano,

1118
00: 52: 18,650 -> 00: 52: 20.920
muito menos um colega seu, nunca vai

1119
00: 52: 20,920 -> 00: 52: 24.580
perceber a sutileza que este três apenas por contrato social

1120
00: 52: 24,580 -> 00: 52: 26.690
tem que ser igual a este três.

1121
00: 52: 26,690 -> 00: 52: 27.940
Isso não é uma restrição de código.

1122
00: 52: 27,940 -> 00: 52: 31.390
Isso é algo que você sabia e decidiu na época.

1123
00: 52: 31,390 -> 00: 52: 33.350
Então, deixe-me corrigir isso da seguinte maneira.

1124
00: 52: 33,350 -> 00: 52: 38.260
Acontece que em C podemos ter variáveis ​​que só têm números

11: 25h
00: 52: 38,260 -> 00: 52: 41.560
assim, talvez int n obtenha três.

1126
00: 52: 41,560 -> 00: 52: 45.670
Agora posso apenas usar minha variável aqui e aqui.

1127
00: 52: 45,670 -> 00: 52: 46.725
Isso é um pouco melhor.

1128
00: 52: 46,725 -> 00: 52: 47.600
É um pouco melhor.

1129
00: 52: 47,600 -> 00: 52: 50.475
Mas há esse outro recurso em C, assim como em outras linguagens,

1130
00: 52: 50,475 -> 00: 52: 52.600
onde se você sabe que deseja codificar algum valor,

1131
00: 52: 52,600 -> 00: 52: 56.140
pelo menos por agora, mas você não quer que isso mude, você não vai mudar

1132
00: 52: 56,140 -> 00: 52: 58.780
e você quer ter certeza de não alterá-lo acidentalmente,

1133
00: 52: 58,780 -> 00: 53: 02.410
você pode realmente fazer algo assim e até torná-lo global se quisermos,

1134
00: 53: 02,410 -> 00: 53: 09.192
no início do arquivo, posso dizer não apenas int n, mas const int n,

1135
00: 53: 09,192 -> 00: 53: 10.900
e apenas por causa da convenção humana, eu

1136
00: 53: 10.900 -> 00: 53: 13.940
também vou agora capitalizar a variável, só porque.

1137
00: 53: 13,940 -> 00: 53: 17.290
E agora vou mudar este n para maiúsculo, este n para maiúsculo.

1138
00: 53: 17,290 -> 00: 53: 20.702
A razão é que acabei de criar para mim o que é chamado de constante.

1139
00: 53: 20,702 -> 00: 53: 23.410
Uma constante é exatamente o que a palavra implica, mesmo que você apenas

1140
00: 53: 23,410 -> 00: 53: 26.680
diga const, e então o tipo da variável, o compilador, clang,

1141
00: 53: 26,680 -> 00: 53: 29.560
vai garantir que nem você, nem algum amigo ou colega

1142
00: 53: 29,560 -> 00: 53: 31.960
alterar acidentalmente o valor de n.

1143
00: 53: 31,960 -> 00: 53: 35.690
Portanto, agora você pode usar n aqui, aqui e em qualquer outro lugar.

1144
00: 53: 35,690 -> 00: 53: 37.697
Sempre será o mesmo.

1145
00: 53: 37,697 -> 00: 53: 40.780
E o que estou usando no momento é o que é chamado de variável global, que

1146
00: 53: 40,780 -> 00: 53: 43.570
são frequentemente desaprovados, mesmo que você possa colocar variáveis ​​fora

1147
00: 53: 43,570 -> 00: 53: 45.760
de suas funções, como podemos ver,

1148
00: 53: 45,760 -> 00: 53: 49.030
tende a ser desleixado, exceto com constantes.

1149
00: 53: 49,030 -> 00: 53: 53.765
Quando uma constante é um valor que você deseja definir e esquecer,

1150
00: 53: 53.765 -> 00: 53: 56.890
se você voltar a este programa semanas ou meses depois, e você tipo, oh,

1151
00: 53: 56,890 -> 00: 53: 59.200
neste semestre, temos quatro tarefas, ou cinco,

1152
00: 53: 59,200 -> 00: 54: 02.080
é útil colocar os valores que você pode

1153
00: 54: 02,080 -> 00: 54: 05.680
deseja mudar antes de recompilar seu código no topo

1154
00: 54: 05,680 -> 00: 54: 09.185
então você tem que ir pescar visualmente mais baixo em seu código.

1155
00: 54: 09,185 -> 00: 54: 10.060
Então, apenas uma convenção.

1156
00: 54: 10,060 -> 00: 54: 13.210
Ele vai no início do arquivo, com bastante frequência, e você o declara como const,

1157
00: 54: 13,210 -> 00: 54: 19.280
e você o coloca em maiúscula, e então você pode usar esse valor, n, em todo o código.

1158
00: 54: 19,280 -> 00: 54: 22.480
Mas agora vamos juntar essas outras sugestões e fazer este programa

1159
00: 54: 22,480 -> 00: 54: 24.430
ainda melhor, de forma que não seja apenas fixando

1160
00: 54: 24,430 -> 00: 54: 27.940
no código este único valor, n, em todos os lugares.

1161
00: 54: 27,940 -> 00: 54: 30.170
Deixe-me ir em frente e me livrar disso.

1162
00: 54: 30,170 -> 00: 54: 33.460
Deixe-me ir em frente e aceitar sua sugestão de que façamos isso dinamicamente,

1163
00: 54: 33,460 -> 00: 54: 35.590
e podemos usar arrays para isso também.

1164
00: 54: 35,590 -> 00: 54: 39.700
Se eu souber com antecedência que quero perguntar ao usuário quantas atribuições existem

1165
00: 54: 39,700 -> 00: 54: 42.280
é neste semestre, bem, eu posso fazer algo assim.

1166
00: 54: 42,280 -> 00: 54: 48.800
Int n obtém get_int, e direi o número de pontuações,

1167
00: 54: 48,800 -> 00: 54: 50.950
e, em seguida, solicite sua entrada.

1168
00: 54: 50,950 -> 00: 54: 54.550
E então o que vou fazer depois disso é me dar um array

1169
00: 54: 54,550 -> 00: 54: 57.910
chamado de scores de tamanho n como etapa dois.

1170
00: 54: 57,910 -> 00: 55: 00.130
E então o que posso fazer é algo assim.

1171
00: 55: 00,130 -> 00: 55: 05.140
For int eu obtenho zero, i menor que n, i mais mais,

1172
00: 55: 05,140 -> 00: 55: 08.140
que, embora eu esteja digitando rápido, é exatamente o mesmo paradigma que

1173
00: 55: 08,140 -> 00: 55: 10.360
usado antes, para, laços For.

1174
00: 55: 10,360 -> 00: 55: 12.610
E aqui, eu poderia fazer algo como scores

1175
00: 55: 12,610 -> 00: 55: 21.490
colchete i obtém get_int score ponto-e-vírgula, solicitando ao usuário repetidamente

1176
00: 55: 21,490 -> 00: 55: 24.730
e novamente para um loop For a pontuação IFE, por assim dizer.

1177
00: 55: 24,730 -> 00: 55: 29.230
E porque eu começo a contar do zero, e continuo até, mas não até n,

1178
00: 55: 29,230 -> 00: 55: 34.030
Vou acabar preenchendo isso com exatamente quantas pontuações o humano solicitou.

1179
00: 55: 34,030 -> 00: 55: 37.568
Vamos prosseguir agora e deixar isso para fazer por um momento.

1180
00: 55: 37,568 -> 00: 55: 39.610
Deixe-me só porque a matemática é sobre a mudança -

1181
00: 55: 39,610 -> 00: 55: 42.485
deixe-me ir em frente e deletar isso e não faremos a média ainda

1182
00: 55: 42,485 -> 00: 55: 44.380
apenas para que eu possa compilar isso primeiro.

1183
00: 55: 44,380 -> 00: 55: 46.540
Vou prosseguir e fazer pontuações novamente -

1184
00: 55: 46,540 -> 00: 55: 47.610
parece compilar.

1185
00: 55: 47,610 -> 00: 55: 55.460
Pontuações de barra, número de pontuações - vamos fazer três, então 72, 73, 33, Enter,

1186
00: 55: 55,460 -> 00: 55: 56.710
e minha média ainda está por fazer.

1187
00: 55: 56,710 -> 00: 55: 58.030
Então, vamos voltar a isso.

1188
00: 55: 58,030 -> 00: 55: 58.400
Mas você sabe o que?

1189
00: 55: 58,400 -> 00: 56: 00.430
Seria bom deixar isso um pouco mais bonito.

1190
00: 56: 00,430 -> 00: 56: 03.850
Por que não digo ao humano qual pontuação eu quero deles, para que eu possa dizer, me dê

1191
00: 56: 03,850 -> 00: 56: 05.910
pontuação número tal e tal, i.

1192
00: 56: 05,910 -> 00: 56: 09.730
Deixe-me usar get int, assim.

1193
00: 56: 09,730 -> 00: 56: 13.810
Agora deixe-me ir em frente e make scores, ./scores

1194
00: 56: 13,810 -> 00: 56: 15.110
Dê-me três pontos novamente.

1195
00: 56: 15,110 -> 00: 56: 18.633
Pontuação zero, 72, 73, 33.

1196
00: 56: 18,633 -> 00: 56: 20.050
Agora, isso é meio estúpido, certo?

1197
00: 56: 20,050 -> 00: 56: 23.230
Pelo menos para pessoas normais que podem usar meu programa, qual é a pontuação zero?

1198
00: 56: 23,230 -> 00: 56: 24.190
O que é pontuação um?

1199
00: 56: 24,190 -> 00: 56: 27.998
Podemos consertar isso para pessoas normais e simplesmente fazer isso.

1200
00: 56: 27,998 -> 00: 56: 30.040
Não estamos mudando onde estamos colocando o valor,

1201
00: 56: 30,040 -> 00: 56: 32.665
mas certamente podemos mudar a estética do que estamos fazendo.

1202
00: 56: 32,665 -> 00: 56: 34.230
Então, vamos refazer o scores.

1203
00: 56: 34,230 -> 00: 56: 37.050
./scores, e agora é mais amigável -

1204
00: 56: 37,050 -> 00: 56: 40.300
72, 73, 33.

1205
00: 56: 40,300 -> 00: 56: 41.620
Então, uma peça permanece.

1206
00: 56: 41,620 -> 00: 56: 43.870
Como faço para calcular a média de uma forma

1207
00: 56: 43,870 -> 00: 56: 46.620
que seja dinamica e não seja fixando código como pontuação 1, 2 e

1208
00: 56: 46,620 -> 00: 56: 48.660
três de novo, ou mesmo a versão do array?

1209
00: 56: 48,660 -> 00: 56: 49.410
E sabe de uma coisa?

1210
00: 56: 49,410 -> 00: 56: 51.202
Esta é uma boa oportunidade para talvez surgir

1211
00: 56: 51,202 -> 00: 56: 55.160
com uma função auxiliar que também resolve o problema interno anterior.

1212
00: 56: 55,160 -> 00: 56: 56.910
Então deixe-me ir em frente e dizer, quer saber?

1213
00: 56: 56,910 -> 00: 56: 59.280
A média talvez possa ter uma fração.

1214
00: 56: 59,280 -> 00: 57: 02.940
Então, que tipo de dados eu quero usar se minha média puder ter uma fração?

1215
00: 57: 02,940 -> 00: 57: 03.860
Portanto, um double ou float.

1216
00: 57: 03,860 -> 00: 57: 04.860
Então nós iremos com qualquer um.

1217
00: 57: 04,860 -> 00: 57: 08.190
Vou mantê-lo simples porque as pontuações serão muito grandes ou precisas.

1218
00: 57: 08,190 -> 00: 57: 10.540
Vou criar uma função chamada média.

1219
00: 57: 10,540 -> 00: 57: 14.820
E se eu quiser calcular a média de todos os números que o humano digitou,

1220
00: 57: 14,820 -> 00: 57: 16.710
Acontece que preciso saber duas coisas.

1221
00: 57: 16,710 -> 00: 57: 20.790
Eu preciso saber o comprimento da matriz que eles vêm acumulando

1222
00: 57: 20,790 -> 00: 57: 23.825
e eu preciso ter o próprio array, então 

1223
00: 57: 23,825 -> 00: 57: 25.950
vou denotá-lo com esses colchetes aqui.

1224
00: 57: 25,950 -> 00: 57: 28.830
Não preciso saber, neste momento, quão grande é.

12: 25h
00: 57: 28,830 -> 00: 57: 30.990
O compilador descobrirá isso para mim.

1226
00:57:30,990 --> 00:57:34,720
But I can now declare a function like this.

1227
00:57:34,720 --> 00:57:38,318
Well how do you go about averaging some number of values,

1228
00:57:38,318 --> 00:57:40,860
if you're handed them in a list, otherwise known as an array,

1229
00:57:40,860 --> 00:57:45,390
but I'm telling you the length of that list, what's this sort of intuition

1230
00:57:45,390 --> 00:57:48,390
for taking an average here?

1231
00:57:48,390 --> 00:57:49,068
Yeah?

1232
00:57:49,068 --> 00:57:53,280
AUDIENCE: You could take the sum and then divide it by [INAUDIBLE] number.

1233
00:57:53,280 --> 00:57:54,470
DAVID MALAN: Yeah.

1234
00:57:54,470 --> 00:57:56,220
Yeah, the average of a bunch of numbers is

1235
00:57:56,220 --> 00:57:58,262
just add all the numbers together and then divide

1236
00:57:58,262 --> 00:57:59,640
by the total number of numbers.

1237
00:57:59,640 --> 00:58:01,140
And I have all of those ingredients.

1238
00:58:01,140 --> 00:58:03,030
I have the length of the array, apparently,

1239
00:58:03,030 --> 00:58:05,505
and I have the array of numbers itself, as follows.

1240
00:58:05,505 --> 00:58:07,380
So let me go ahead and say something like sum

1241
00:58:07,380 --> 00:58:09,880
is zero, because I'm just going to start counting from zero,

1242
00:58:09,880 --> 00:58:14,580
and then I'm going to do for int i get zero, i less than length, i plus plus.

1243
00:58:14,580 --> 00:58:17,850
So again, I typed it fast, but it's identical to my for loop from before.

1244
00:58:17,850 --> 00:58:20,310
I'm just using the length as the condition.

1245
00:58:20,310 --> 00:58:21,840
And now what do I want to do here?

1246
00:58:21,840 --> 00:58:26,800
On each iteration, what do I want to add to the sum?

1247
00:58:26,800 --> 00:58:28,460
Sum equals sum plus what?

1248
00:58:28,460 --> 00:58:29,883
AUDIENCE: [INAUDIBLE]

1249
00:58:29,883 --> 00:58:31,550
DAVID MALAN: The next item in the array.

1250
00:58:31,550 --> 00:58:33,380
And I can express that, it turns out, just

1251
00:58:33,380 --> 00:58:37,070
like before the name of the array, which happens to be literally array, just

1252
00:58:37,070 --> 00:58:38,160
for convenience.

1253
00:58:38,160 --> 00:58:41,520
And then how do I get the appropriate value from it?

1254
00:58:41,520 --> 00:58:45,040
Bracket i, because i is going to start in this loop at zero,

1255
00:58:45,040 --> 00:58:47,630
going to go up to, but not through its length.

1256
00:58:47,630 --> 00:58:50,630
So this is just a way of getting bracket zero, bracket one, bracket two,

1257
00:58:50,630 --> 00:58:53,510
and just adding it to sum on each iteration.

1258
00:58:53,510 --> 00:58:55,820
Now this is unnecessarily wordy.

1259
00:58:55,820 --> 00:58:59,210
Recall, that this is shorthand notation for that.

1260
00:58:59,210 --> 00:59:01,940
I can't just use plus, plus here though, because I want

1261
00:59:01,940 --> 00:59:04,070
to add the actual scores not just one.

1262
00:59:04,070 --> 00:59:07,280
So I can use either this syntax or the more verbose syntax,

1263
00:59:07,280 --> 00:59:08,540
but I'll go with this one.

1264
00:59:08,540 --> 00:59:11,480
And now at the end of this function, notice I have to make a decision.

1265
00:59:11,480 --> 00:59:14,120
And we haven't seen terribly many functions of our own,

1266
00:59:14,120 --> 00:59:17,420
but if this is what my function looks like, its name is average,

1267
00:59:17,420 --> 00:59:22,100
it takes two inputs, one of which is an int called length, the other of which

1268
00:59:22,100 --> 00:59:26,150
is an array of integers, and I know it's an array not by its name, which

1269
00:59:26,150 --> 00:59:30,290
I could have called anything, but I know it because of these new square brackets

1270
00:59:30,290 --> 00:59:31,790
today.

1271
00:59:31,790 --> 00:59:36,405
However, what does this mention of float mean on the left-hand side of line 18?

1272
00:59:36,405 --> 00:59:37,280
AUDIENCE: [INAUDIBLE]

1273
00:59:37,280 --> 00:59:38,780
DAVID MALAN: That's what it returns.

1274
00:59:38,780 --> 00:59:42,740
The return value of a function is what it hands back to whoever is using it.

1275
00:59:42,740 --> 00:59:44,690
So get string, returns a string.

1276
00:59:44,690 --> 00:59:46,160
Get int, returns an int.

1277
00:59:46,160 --> 00:59:48,860
Average I want to return a float.

1278
00:59:48,860 --> 00:59:51,000
And so how do I return this value?

1279
00:59:51,000 --> 00:59:55,120
Well, let me go ahead and return the sum divided by the length,

1280
00:59:55,120 --> 00:59:56,990
as I think you proposed?

1281
00:59:56,990 --> 01:00:00,748
Now there's actually one bug here, but we'll come back to that in a moment.

1282
01:00:00,748 --> 01:00:02,790
Now let me just go ahead and plug in the average.

1283
01:00:02,790 --> 01:00:06,240
What's the format code for a floating point value?

1284
01:00:06,240 --> 01:00:07,400
Percent f, yeah.

1285
01:00:07,400 --> 01:00:09,710
And then if I want to plug in the average,

1286
01:00:09,710 --> 01:00:12,600
I can call my function called average.

1287
01:00:12,600 --> 01:00:15,440
And what two inputs do I need to give it?

1288
01:00:15,440 --> 01:00:20,760
n, which is the length of the array, and scores, which is the name of the array.

1289
01:00:20,760 --> 01:00:22,970
So again, even though arrays are new, this is not.

1290
01:00:22,970 --> 01:00:27,230
We have last week called functions that take one or more arguments

1291
01:00:27,230 --> 01:00:28,830
and it's certainly fine to nest them.

1292
01:00:28,830 --> 01:00:30,913
However, if you don't like that, you can certainly

1293
01:00:30,913 --> 01:00:32,720
do something like this-- float average gets

1294
01:00:32,720 --> 01:00:34,890
that, and then you can plug in average.

1295
01:00:34,890 --> 01:00:36,920
But again, in the spirit of good design, you're

1296
01:00:36,920 --> 01:00:39,260
just doubling the number of lines unnecessarily.

1297
01:00:39,260 --> 01:00:42,710
So I'm going to go ahead and nest it just like this.

1298
01:00:42,710 --> 01:00:44,430
All right, let me save that.

1299
01:00:44,430 --> 01:00:46,527
And I feel really good about this so far.

1300
01:00:46,527 --> 01:00:48,110
I feel like everything's making sense.

1301
01:00:48,110 --> 01:00:49,220
So make scores.

1302
01:00:49,220 --> 01:00:50,690
And oh, my god.

1303
01:00:50,690 --> 01:00:53,450


1304
01:00:53,450 --> 01:00:58,042
Line 15 seems to be at fault. So we can certainly use help 50,

1305
01:00:58,042 --> 01:00:59,750
but let's see if we can't reason through.

1306
01:00:59,750 --> 01:01:00,792
What mistake have I made?

1307
01:01:00,792 --> 01:01:04,130


1308
01:01:04,130 --> 01:01:06,920
It's highlighted here, even though it's very non obvious.

1309
01:01:06,920 --> 01:01:07,862
Yeah?

1310
01:01:07,862 --> 01:01:12,101
AUDIENCE: [INAUDIBLE]

1311
01:01:12,101 --> 01:01:12,685


1312
01:01:12,685 --> 01:01:13,560
DAVID MALAN: Exactly.

1313
01:01:13,560 --> 01:01:16,230
My function is at the bottom of my file and C is kind of dumb.

1314
01:01:16,230 --> 01:01:18,730
It only does what it's told, top to bottom, left to right.

1315
01:01:18,730 --> 01:01:20,670
And if your function averages at the bottom,

1316
01:01:20,670 --> 01:01:23,400
but you're trying to use it in main, that's too late.

1317
01:01:23,400 --> 01:01:26,380
So we can fix this in a couple of ways, just as we did last week.

1318
01:01:26,380 --> 01:01:28,380
I can kind of sloppily just say, all right, well

1319
01:01:28,380 --> 01:01:29,630
let's just move it to the top.

1320
01:01:29,630 --> 01:01:31,350
That will solve that problem.

1321
01:01:31,350 --> 01:01:33,727
But frankly, that moves main farther down

1322
01:01:33,727 --> 01:01:36,060
and it's a good human convention to keep main at the top

1323
01:01:36,060 --> 01:01:38,200
so you can see the main part of your program.

1324
01:01:38,200 --> 01:01:41,700
This is why, last week, we introduced the notion of a prototype,

1325
01:01:41,700 --> 01:01:44,940
where you literally-- and this is the only time where the copy-paste is OK--

1326
01:01:44,940 --> 01:01:48,810
you copy-paste the first line of your function and end it with a semicolon

1327
01:01:48,810 --> 01:01:50,430
without any more currently braces.

1328
01:01:50,430 --> 01:01:52,200
That's now a clue to solve that problem.

1329
01:01:52,200 --> 01:01:53,770
Hey clang, here's a function.

1330
01:01:53,770 --> 01:01:55,895
I'm not going to get around to implementing it yet,

1331
01:01:55,895 --> 01:01:57,570
but you at least know what it's called.

1332
01:01:57,570 --> 01:02:00,090
Now there's still a slight logical bug in here.

1333
01:02:00,090 --> 01:02:04,270
Let me try re-saving and recompiling scores.

1334
01:02:04,270 --> 01:02:05,880
It compiled this time-- nice.

1335
01:02:05,880 --> 01:02:07,410
Let me go ahead and run scores.

1336
01:02:07,410 --> 01:02:13,320
Number of scores will be three, 72, 73, 33.

1337
01:02:13,320 --> 01:02:14,560
OK, that's pretty good.

1338
01:02:14,560 --> 01:02:15,730
Let me try another one.

1339
01:02:15,730 --> 01:02:17,190
How about two scores.

1340
01:02:17,190 --> 01:02:21,570
100 and suppose you get a 99 on the other,

1341
01:02:21,570 --> 01:02:24,620
you probably want your grade to be what?

1342
01:02:24,620 --> 01:02:25,380
100, right.

1343
01:02:25,380 --> 01:02:28,240
If it's 99.5, you'd prefer we round up.

1344
01:02:28,240 --> 01:02:30,360
So where is that bug?

1345
01:02:30,360 --> 01:02:32,490
Well let me scroll down here, and this is

1346
01:02:32,490 --> 01:02:35,370
what you were alluding to earlier when you identified this early on.

1347
01:02:35,370 --> 01:02:37,650
So I'm doing a couple of things incorrectly here.

1348
01:02:37,650 --> 01:02:40,950
One, I'm adding the sum here.

1349
01:02:40,950 --> 01:02:44,280
I'm using an int and initializing sum to zero,

1350
01:02:44,280 --> 01:02:46,600
and then I'm dividing an integer by an integer.

1351
01:02:46,600 --> 01:02:50,190
And this is subtle, but in C, if you divide an integer by an integer,

1352
01:02:50,190 --> 01:02:52,920
just take a guess-- what do you get as the answer?

1353
01:02:52,920 --> 01:02:53,800
AUDIENCE: An integer.

1354
01:02:53,800 --> 01:02:54,420
DAVID MALAN: An integer.

1355
01:02:54,420 --> 01:02:56,170
Integers can't store decimal points.

1356
01:02:56,170 --> 01:03:01,398
So even if your score is 99.900000 ad nauseum,

1357
01:03:01,398 --> 01:03:04,440
what's going to get thrown away is literally everything after the decimal

1358
01:03:04,440 --> 01:03:05,140
point.

1359
01:03:05,140 --> 01:03:07,290
So your grade is actually a 99.

1360
01:03:07,290 --> 01:03:11,550
So there's a couple of ways we can fix this, but perhaps the simplest is this.

1361
01:03:11,550 --> 01:03:14,220
I can use that casting feature from before.

1362
01:03:14,220 --> 01:03:16,363
I can tell the computer, don't treat length

1363
01:03:16,363 --> 01:03:19,530
as an int, actually treated as a float, and you know, just for good measure,

1364
01:03:19,530 --> 01:03:20,820
also treat sum as a float.

1365
01:03:20,820 --> 01:03:23,670
And there's different ways to do this, but now, I'm

1366
01:03:23,670 --> 01:03:26,670
telling the computer divide a float by a float, which

1367
01:03:26,670 --> 01:03:30,090
will allow me to return a float, and let's see what happens now.

1368
01:03:30,090 --> 01:03:31,590
Let me save that.

1369
01:03:31,590 --> 01:03:33,570
Make scores.

1370
01:03:33,570 --> 01:03:34,350
It compiled.

1371
01:03:34,350 --> 01:03:35,840
Dot slash scores.

1372
01:03:35,840 --> 01:03:36,850
Number of scores is two.

1373
01:03:36,850 --> 01:03:38,040
100 is the first.

1374
01:03:38,040 --> 01:03:39,570
99 is the second.

1375
01:03:39,570 --> 01:03:41,572
Nice, now I've gotten the grade I deserved.

1376
01:03:41,572 --> 01:03:44,030
Heck, we could even bring in the round function if we want,

1377
01:03:44,030 --> 01:03:46,863
which you might have used for p-set one, but we'll leave it as this.

1378
01:03:46,863 --> 01:03:49,917
But I am going to go ahead and just do a 0.1 there.

1379
01:03:49,917 --> 01:03:51,750
Recall that with format codes you can really

1380
01:03:51,750 --> 01:03:54,700
start to get precise and say only show me one digit.

1381
01:03:54,700 --> 01:03:59,430
So if I recompile this now, make scores, and do dot slash scores--

1382
01:03:59,430 --> 01:04:02,100
two scores-- 100, 99.

1383
01:04:02,100 --> 01:04:09,730
There's my 99.5% Any questions then on these arrays and the use there of?

1384
01:04:09,730 --> 01:04:10,327
Yeah?

1385
01:04:10,327 --> 01:04:14,143
AUDIENCE: [INAUDIBLE] the average [INAUDIBLE] income scores by

1386
01:04:14,143 --> 01:04:15,097
[INAUDIBLE]

1387
01:04:15,097 --> 01:04:17,180
DAVID MALAN: Explain the average-- this part here?

1388
01:04:17,180 --> 01:04:17,960
AUDIENCE: Yeah.

1389
01:04:17,960 --> 01:04:19,140
DAVID MALAN: Sure, can I explain this?

1390
01:04:19,140 --> 01:04:20,480
So, let me just show more of the code.

1391
01:04:20,480 --> 01:04:22,438
The last line of this program's purpose in life

1392
01:04:22,438 --> 01:04:25,610
is just to print the average of all of my scores.

1393
01:04:25,610 --> 01:04:28,160
And I decided, partly for design purposes,

1394
01:04:28,160 --> 01:04:32,780
but also today to illustrate a point, to relegate the computation of an average

1395
01:04:32,780 --> 01:04:33,980
to a custom function.

1396
01:04:33,980 --> 01:04:35,330
This is handy, because now if I ever work

1397
01:04:35,330 --> 01:04:37,070
on another problem that needs to average,

1398
01:04:37,070 --> 01:04:39,620
I've got a function I can use in that code too.

1399
01:04:39,620 --> 01:04:43,340
But in this case, average takes two arguments, apparently

1400
01:04:43,340 --> 01:04:45,970
the length of the array and the array itself,

1401
01:04:45,970 --> 01:04:47,720
but I could call these two things anything

1402
01:04:47,720 --> 01:04:51,350
I want-- x and y, length and array, anything else,

1403
01:04:51,350 --> 01:04:53,120
but I chose this for clarity.

1404
01:04:53,120 --> 01:04:54,860
But up here, I want to use that function.

1405
01:04:54,860 --> 01:04:57,200
So just like in Scratch, recall that you can nest blocks

1406
01:04:57,200 --> 01:04:59,430
and you can join something and then say it.

1407
01:04:59,430 --> 01:05:02,120
So can we call the average function, passing

1408
01:05:02,120 --> 01:05:04,610
in the length of the array and the array itself,

1409
01:05:04,610 --> 01:05:08,000
that gives me back my average 99.5, and then I'm

1410
01:05:08,000 --> 01:05:11,480
plugging that in to this format code in printf.

1411
01:05:11,480 --> 01:05:13,888
So just like in math, when you have lots of parentheses,

1412
01:05:13,888 --> 01:05:14,930
work from the inside out.

1413
01:05:14,930 --> 01:05:17,388
Look at the innermost parentheses, figure out what that is,

1414
01:05:17,388 --> 01:05:19,420
then work your way outward.

1415
01:05:19,420 --> 01:05:22,880
And if you've programmed in Java, or Python, or other languages,

1416
01:05:22,880 --> 01:05:25,040
you might be wondering why we need to tell

1417
01:05:25,040 --> 01:05:27,110
the function the length of an array.

1418
01:05:27,110 --> 01:05:30,440
In C, the arrays do not remember their own length.

1419
01:05:30,440 --> 01:05:33,200
So if you have programmed before, this is necessary.

1420
01:05:33,200 --> 01:05:36,920
You do not get that feature for free in C. Yeah?

1421
01:05:36,920 --> 01:05:41,580
AUDIENCE: [INAUDIBLE]

1422
01:05:41,580 --> 01:05:43,420
DAVID MALAN: Correct, if you do percent 0.1

1423
01:05:43,420 --> 01:05:45,520
you get one decimal point, so 99.5%.

1424
01:05:45,520 --> 01:05:49,843
AUDIENCE: Suppose that the answer was 99.49 [INAUDIBLE]

1425
01:05:49,843 --> 01:05:51,260
DAVID MALAN: Really good question.

1426
01:05:51,260 --> 01:05:57,170
If the answer is mathematically 99.49, but you do 0.1 here,

1427
01:05:57,170 --> 01:05:58,940
it will round up for you.

1428
01:05:58,940 --> 01:06:00,950
It will-- good question as well.

1429
01:06:00,950 --> 01:06:01,650
Yeah?

1430
01:06:01,650 --> 01:06:05,003
AUDIENCE: What happens [INAUDIBLE]?

1431
01:06:05,003 --> 01:06:06,420
DAVID MALAN: Really good question.

1432
01:06:06,420 --> 01:06:09,830
What happens if you divide an int by a float or something else?

1433
01:06:09,830 --> 01:06:13,520
You will typically up cast it to whatever the more powerful type is.

1434
01:06:13,520 --> 01:06:16,760
So if you divide an int by a float, you will actually get back a float.

1435
01:06:16,760 --> 01:06:20,060
So strictly speaking, I did not need to cast both the numerator

1436
01:06:20,060 --> 01:06:21,710
and the denominator to a float.

1437
01:06:21,710 --> 01:06:25,160
I just did it for consistency and demonstration's sake.

1438
01:06:25,160 --> 01:06:28,700
So it turns out, while we've been looking at numbers here alone

1439
01:06:28,700 --> 01:06:31,250
and scores, it turns out that there's actually

1440
01:06:31,250 --> 01:06:35,533
an intricate relationship with all of the h's and the i's and the exhalation

1441
01:06:35,533 --> 01:06:37,700
points we've been looking at, and all of the strings

1442
01:06:37,700 --> 01:06:40,670
we've been typing in too, however this was a mouthful,

1443
01:06:40,670 --> 01:06:42,450
and frankly I feel like a brownie as well,

1444
01:06:42,450 --> 01:06:45,283
so why don't we take our five minute break here and we'll come back.

1445
01:06:45,283 --> 01:06:47,570


1446
01:06:47,570 --> 01:06:51,610
We are back.

1447
01:06:51,610 --> 01:06:55,930
So thus far, we've introduced arrays as an opportunity

1448
01:06:55,930 --> 01:06:58,048
to improve the design of our code.

1449
01:06:58,048 --> 01:07:00,340
So we're going to hear a lot of squeaking now, I think.

1450
01:07:00,340 --> 01:07:05,890
So thus far, we've introduced arrays as the--

1451
01:07:05,890 --> 01:07:08,240
we're going to do my best to keep a straight face.

1452
01:07:08,240 --> 01:07:11,500
Thus far, we have introduced arrays as a solution to a design problem

1453
01:07:11,500 --> 01:07:14,260
so that we can actually store multiple values,

1454
01:07:14,260 --> 01:07:18,970
but in the guise of one variable so as to avoid the copy-paste tendency

1455
01:07:18,970 --> 01:07:20,410
that we might otherwise have.

1456
01:07:20,410 --> 01:07:24,250
And those arrays ultimately started from trying to clean this kind of code up.

1457
01:07:24,250 --> 01:07:27,530
But what is it that was ultimately going on inside of the computer's memory

1458
01:07:27,530 --> 01:07:30,520
we can still consider, because it's actually not all that different.

1459
01:07:30,520 --> 01:07:34,960
However, when we have three integers, score one, score two, score three,

1460
01:07:34,960 --> 01:07:38,530
how many bytes is each of those-- it's going to take up?

1461
01:07:38,530 --> 01:07:41,770
So four, if you think back to the chat from before, char is one,

1462
01:07:41,770 --> 01:07:45,160
an int is four, at least on most systems, and so the number

1463
01:07:45,160 --> 01:07:49,180
72 in the variable called score one, we can draw on our computers

1464
01:07:49,180 --> 01:07:50,950
memory is taking up four of these boxes.

1465
01:07:50,950 --> 01:07:54,010
Because again, each box represents one byte, therefore four bytes

1466
01:07:54,010 --> 01:07:55,300
requires four boxes.

1467
01:07:55,300 --> 01:07:57,340
Score two and score three would similarly

1468
01:07:57,340 --> 01:07:58,990
be laid out in my computer's memory.

1469
01:07:58,990 --> 01:08:02,800
If I had three variables, score one, two, and three, as follows, like this.

1470
01:08:02,800 --> 01:08:05,890
Of course what's underneath the hood is actually bits,

1471
01:08:05,890 --> 01:08:09,500
but again, we don't need to worry about that level of abstraction anymore.

1472
01:08:09,500 --> 01:08:11,920
But that's indeed all that's going on there.

1473
01:08:11,920 --> 01:08:13,330
But we can clean this up.

1474
01:08:13,330 --> 01:08:16,270
We can instead get rid of this copy-paste approach to variable names

1475
01:08:16,270 --> 01:08:18,460
and just introduce an array called scores,

1476
01:08:18,460 --> 01:08:22,689
plural, and then initialize those three values, as in the program I wrote here.

1477
01:08:22,689 --> 01:08:27,490
And then, this picture is similar in spirit, but the names of these boxes,

1478
01:08:27,490 --> 01:08:31,840
so to speak, become score zero, scores one, and scores two.

1479
01:08:31,840 --> 01:08:36,640
So the array is now independent of the number of bytes being consumed.

1480
01:08:36,640 --> 01:08:38,979
Just because an int is four bytes, doesn't

1481
01:08:38,979 --> 01:08:43,359
mean you do score zero, scores four, scores eight, and so forth.

1482
01:08:43,359 --> 01:08:44,979
It's still zero, one, two.

1483
01:08:44,979 --> 01:08:49,990
The computer will figure out exactly how much space to give each of those values

1484
01:08:49,990 --> 01:08:52,354
based on its type, which is an int.

1485
01:08:52,354 --> 01:08:54,729
But it turns out that there's actually a relationship now

1486
01:08:54,729 --> 01:08:58,330
to where we began this story when we looked at characters.

1487
01:08:58,330 --> 01:09:01,660
H-I exclamation point was implemented with three lines of code

1488
01:09:01,660 --> 01:09:03,760
using c1, c2, and c3.

1489
01:09:03,760 --> 01:09:06,850
But last week, we already saw the notion of a string,

1490
01:09:06,850 --> 01:09:11,710
and it turns out strings and chars are fundamentally interrelated in ways

1491
01:09:11,710 --> 01:09:13,630
that we can now literally see.

1492
01:09:13,630 --> 01:09:16,779
If we had a string called s, for instance,

1493
01:09:16,779 --> 01:09:20,680
and that string contains three characters, H-I and an exclamation

1494
01:09:20,680 --> 01:09:23,109
point, well it turns out you can actually

1495
01:09:23,109 --> 01:09:25,479
get at the individual letters in a string

1496
01:09:25,479 --> 01:09:29,950
by doing the name of the string, bracket, zero, close bracket,

1497
01:09:29,950 --> 01:09:31,950
or s bracket one, or s bracket two.

1498
01:09:31,950 --> 01:09:35,260
If the name of my variable is s, and s is a string,

1499
01:09:35,260 --> 01:09:38,529
I can actually access the individual characters there in just

1500
01:09:38,529 --> 01:09:41,830
like an array, which is to say then, what

1501
01:09:41,830 --> 01:09:48,029
is a string as of this week versus last?

1502
01:09:48,029 --> 01:09:49,850
It's just an array of chars.

1503
01:09:49,850 --> 01:09:51,340
It's just an array of characters.

1504
01:09:51,340 --> 01:09:54,848
So even though it's a data type, thanks to CS50's library and CS50 dot h,

1505
01:09:54,848 --> 01:09:57,640
and we're going to take this training wheel off within a few weeks,

1506
01:09:57,640 --> 01:09:59,890
we've essentially just created a string to be

1507
01:09:59,890 --> 01:10:02,720
for now, at this point in the story, just an array of characters.

1508
01:10:02,720 --> 01:10:03,220
Why?

1509
01:10:03,220 --> 01:10:05,327
Because being able to have multiple characters

1510
01:10:05,327 --> 01:10:07,660
is certainly way more useful than having to spell things

1511
01:10:07,660 --> 01:10:11,320
out one variable at a time with one char at a time.

1512
01:10:11,320 --> 01:10:14,470
So string is a data type in the CS50 library

1513
01:10:14,470 --> 01:10:17,763
that for today's purposes indeed, just an array of characters.

1514
01:10:17,763 --> 01:10:19,930
And we'll see before long that, that too is actually

1515
01:10:19,930 --> 01:10:24,290
kind of a bit of a white lie, but we'll see why before long as well.

1516
01:10:24,290 --> 01:10:27,040
So if I declare a string in C, I can actually

1517
01:10:27,040 --> 01:10:28,540
literally do something like this.

1518
01:10:28,540 --> 01:10:32,620
String s equals quote unquote hi, this time using double quotes, and not

1519
01:10:32,620 --> 01:10:36,182
single quotes, because it's three characters and not just a single char.

1520
01:10:36,182 --> 01:10:38,890
So in memory, that's actually going to look pretty much the same.

1521
01:10:38,890 --> 01:10:42,910
If the variable's called s, it's going to have h i and an exclamation point.

1522
01:10:42,910 --> 01:10:46,630
And just for simplicity, I'll label the first box as s

1523
01:10:46,630 --> 01:10:49,210
and just assume that we can get everywhere else.

1524
01:10:49,210 --> 01:10:53,170
But it turns out that strings are a little special, because

1525
01:10:53,170 --> 01:10:56,530
unlike a char, which is one byte, unlike an int, which

1526
01:10:56,530 --> 01:10:59,590
is four bytes, unlike a long, which is eight bytes,

1527
01:10:59,590 --> 01:11:01,672
how long should a string be?

1528
01:11:01,672 --> 01:11:03,245
AUDIENCE: [INAUDIBLE]

1529
01:11:03,245 --> 01:11:05,620
DAVID MALAN: Yeah, I mean as many characters as you need,

1530
01:11:05,620 --> 01:11:08,050
because if I want to store H-I I need--

1531
01:11:08,050 --> 01:11:11,170
H-I exclamation point, I need strings to be at least three bytes,

1532
01:11:11,170 --> 01:11:12,020
it would seem--

1533
01:11:12,020 --> 01:11:15,100
for my name David, at least five bytes, for D-A-V-I-D--

1534
01:11:15,100 --> 01:11:18,130
Brian, as well, and much longer names in the room, too.

1535
01:11:18,130 --> 01:11:21,413
So strings can't really have a preordained length associated

1536
01:11:21,413 --> 01:11:23,830
with them, which is why I put a question mark on the board

1537
01:11:23,830 --> 01:11:27,040
before when I first summarized the sizes of these types.

1538
01:11:27,040 --> 01:11:31,810
But the catch is that if a variable only has a name, like s, or name, or any

1539
01:11:31,810 --> 01:11:34,820
of the variables you use for p-set one's problems,

1540
01:11:34,820 --> 01:11:38,380
it turns out we all need to decide as human programmers

1541
01:11:38,380 --> 01:11:41,020
how do we know where the string ends?

1542
01:11:41,020 --> 01:11:43,330
The name of the variable, suffice it to say,

1543
01:11:43,330 --> 01:11:46,330
lets us know where the variable begins, just as I've drawn here.

1544
01:11:46,330 --> 01:11:48,960
If you reference a variable in a program and call it s,

1545
01:11:48,960 --> 01:11:52,390
the computer will just know to go to the first character in that string.

1546
01:11:52,390 --> 01:11:55,210
But there needs to be a little clue to the computer as to where

1547
01:11:55,210 --> 01:11:59,230
the string ends, and that clue is what's called a null character.

1548
01:11:59,230 --> 01:12:01,300
It's a little funky to look at, but it's just

1549
01:12:01,300 --> 01:12:04,347
a backslash zero, which might remind you of backslash n, which

1550
01:12:04,347 --> 01:12:06,430
too is a little funky, and that's a special symbol

1551
01:12:06,430 --> 01:12:09,790
that says move the cursor to the next line, give a new line.

1552
01:12:09,790 --> 01:12:12,550
Backslash zero is the so-called null character

1553
01:12:12,550 --> 01:12:14,890
or the null terminating character.

1554
01:12:14,890 --> 01:12:19,930
And all that is special syntax for eight zero bits.

1555
01:12:19,930 --> 01:12:22,310
So each of these boxes represents h bits.

1556
01:12:22,310 --> 01:12:23,530
This is number 72.

1557
01:12:23,530 --> 01:12:25,030
This is the number 73.

1558
01:12:25,030 --> 01:12:26,470
This is the number 33.

1559
01:12:26,470 --> 01:12:32,530
This backslash zero is just the way of drawing all eight bits as zeros.

1560
01:12:32,530 --> 01:12:36,670
So that's what a computer uses in C to demarcate the end of a string.

1561
01:12:36,670 --> 01:12:40,025
It just wastes one byte as all zero bits.

1562
01:12:40,025 --> 01:12:41,650
And I say waste, because you know what?

1563
01:12:41,650 --> 01:12:47,740
How much space does H-I exclamation point actually take up accordingly?

1564
01:12:47,740 --> 01:12:50,620
How many bytes do you need to store hi?

1565
01:12:50,620 --> 01:12:52,000
AUDIENCE: [INAUDIBLE]

1566
01:12:52,000 --> 01:12:56,380
DAVID MALAN: Three, well, four, because you need to know where the string ends,

1567
01:12:56,380 --> 01:12:58,780
otherwise you won't be able to distinguish

1568
01:12:58,780 --> 01:13:02,450
the beginnings of other variables, potentially, in your computer's memory.

1569
01:13:02,450 --> 01:13:04,130
And we'll see this in just a moment.

1570
01:13:04,130 --> 01:13:06,400
So if my string is called s, it turns out

1571
01:13:06,400 --> 01:13:08,410
that at s bracket zero is the first character.

1572
01:13:08,410 --> 01:13:12,010
S bracket one is the second character. s bracket two is the third.

1573
01:13:12,010 --> 01:13:16,210
And that null character, so to speak, the invisible backslash zero

1574
01:13:16,210 --> 01:13:18,950
or eight zero bits happens to be at the end.

1575
01:13:18,950 --> 01:13:24,250
So a string that's of length three, actually takes up four bytes.

1576
01:13:24,250 --> 01:13:27,940
Any string you have typed into a computer yet, whether it's hi,

1577
01:13:27,940 --> 01:13:30,970
or David, or Brian, or Emma, or Rodrigo, takes up

1578
01:13:30,970 --> 01:13:33,940
as many characters as are in those names,

1579
01:13:33,940 --> 01:13:37,370
plus one byte for this special null terminating character.

1580
01:13:37,370 --> 01:13:38,122
So let's see that.

1581
01:13:38,122 --> 01:13:40,330
If we were to write a program using these four names,

1582
01:13:40,330 --> 01:13:42,860
let me go ahead and with that up really quickly here.

1583
01:13:42,860 --> 01:13:46,450
I'm going to create a file called names dot c,

1584
01:13:46,450 --> 01:13:50,050
and I'm going to go ahead and do include standard Io dot h.

1585
01:13:50,050 --> 01:13:53,260
Then I'm going to go ahead and do int main void.

1586
01:13:53,260 --> 01:13:57,790
Inside of here, I'm going to give myself four strings, using my new array

1587
01:13:57,790 --> 01:13:59,080
syntax, as before.

1588
01:13:59,080 --> 01:14:01,870
So I could call this name one, name two, name three, name four,

1589
01:14:01,870 --> 01:14:03,760
but I'm not going to repeat that bad habit.

1590
01:14:03,760 --> 01:14:05,440
I'm going to give myself a name--

1591
01:14:05,440 --> 01:14:10,150
a variable called names, plural, and store four strings in it, as follows.

1592
01:14:10,150 --> 01:14:12,430
Let's give Emma the first spot there.

1593
01:14:12,430 --> 01:14:16,180
Let's give Rodrigo the second spot there.

1594
01:14:16,180 --> 01:14:19,780
I'm using all caps just because we've seen some of those Ascii codes before,

1595
01:14:19,780 --> 01:14:21,610
but I could use lowercase as well.

1596
01:14:21,610 --> 01:14:22,690
Let's add Brian.

1597
01:14:22,690 --> 01:14:25,120
And then I'll go ahead and add myself lastly.

1598
01:14:25,120 --> 01:14:29,680
So the array is of size four, but I count from zero on up through C.

1599
01:14:29,680 --> 01:14:32,080
And now just for demonstration's sake, let's go ahead

1600
01:14:32,080 --> 01:14:33,790
and print out, say, Emma's name.

1601
01:14:33,790 --> 01:14:37,360
So if I want to print out Emma's name, the type of variable in which she

1602
01:14:37,360 --> 01:14:39,121
is stored, is what?

1603
01:14:39,121 --> 01:14:41,174
What is the type that I want to print?

1604
01:14:41,174 --> 01:14:41,990
String.

1605
01:14:41,990 --> 01:14:43,837
So that's percent s, just like last week.

1606
01:14:43,837 --> 01:14:45,670
And I'm going to head and put a backslash n.

1607
01:14:45,670 --> 01:14:49,720
And if I want to print Emma's name, what do I type here

1608
01:14:49,720 --> 01:14:52,052
to plug into that placeholder?

1609
01:14:52,052 --> 01:14:53,095
AUDIENCE: [INAUDIBLE]

1610
01:14:53,095 --> 01:14:54,470
DAVID MALAN: Names brackets zero.

1611
01:14:54,470 --> 01:14:56,540
It's a little bad that I'm hard coding it here,

1612
01:14:56,540 --> 01:14:59,560
but again, I'm just demonstrating how this all works for now.

1613
01:14:59,560 --> 01:15:01,090
Let me go ahead and save that.

1614
01:15:01,090 --> 01:15:03,400
Let me do make names.

1615
01:15:03,400 --> 01:15:04,570
Bit of an error here.

1616
01:15:04,570 --> 01:15:05,500
What did I do wrong?

1617
01:15:05,500 --> 01:15:08,170
Oh my god, all of this is wrong.

1618
01:15:08,170 --> 01:15:11,274
Does anyone see it yet?

1619
01:15:11,274 --> 01:15:12,150
AUDIENCE: [INAUDIBLE]

1620
01:15:12,150 --> 01:15:14,025
DAVID MALAN: Yeah, I forgot the CS50 library.

1621
01:15:14,025 --> 01:15:16,920
So even though I'm not using get string, I am using string,

1622
01:15:16,920 --> 01:15:19,630
so I do need the CS50 library up here.

1623
01:15:19,630 --> 01:15:21,150
So let me go ahead and clear that.

1624
01:15:21,150 --> 01:15:22,500
Make names.

1625
01:15:22,500 --> 01:15:23,236
OK better.

1626
01:15:23,236 --> 01:15:25,980
Dot slash names, and I should just see Emma's name.

1627
01:15:25,980 --> 01:15:28,080
But watch this, what I can do too.

1628
01:15:28,080 --> 01:15:31,830
I know that Emma's name is a string, and I now

1629
01:15:31,830 --> 01:15:36,550
know that a string is an array of characters, so I can also do this.

1630
01:15:36,550 --> 01:15:41,370
Let me go ahead and print out one, two, three, four characters,

1631
01:15:41,370 --> 01:15:42,700
and then a new line.

1632
01:15:42,700 --> 01:15:44,640
And the characters I'm going to print out

1633
01:15:44,640 --> 01:15:48,660
are going to be Emma's names, first character,

1634
01:15:48,660 --> 01:15:54,600
Emma's names, second character, Emma's names, third character,

1635
01:15:54,600 --> 01:15:58,500
and Emma's names, fourth character.

1636
01:15:58,500 --> 01:16:01,980
So you can have what's essentially a two-dimensional array, where

1637
01:16:01,980 --> 01:16:03,570
you have two sets of square brackets.

1638
01:16:03,570 --> 01:16:06,930
The first one indexes me into the array of names.

1639
01:16:06,930 --> 01:16:10,510
And to index into an array means go to a certain location in an array.

1640
01:16:10,510 --> 01:16:13,530
So names, bracket zero, so to speak.

1641
01:16:13,530 --> 01:16:18,930
This part here means go get Emma's name from the array of four names.

1642
01:16:18,930 --> 01:16:23,260
This square bracket after says within that string,

1643
01:16:23,260 --> 01:16:25,230
treat it as an array of characters and get

1644
01:16:25,230 --> 01:16:28,980
the zeroth character, the first character, which is hopefully e

1645
01:16:28,980 --> 01:16:31,940
and an m and an m and then a.

1646
01:16:31,940 --> 01:16:34,290
So I'm going to go ahead and save this file now.

1647
01:16:34,290 --> 01:16:35,870
Make names again.

1648
01:16:35,870 --> 01:16:41,190
It compiled, dot slash names, and voila, Emma, Emma, I see twice.

1649
01:16:41,190 --> 01:16:44,730
Now, I'm never again going to print any string like this.

1650
01:16:44,730 --> 01:16:48,060
This is just ridiculous, plus I had to know in advance how long her name is.

1651
01:16:48,060 --> 01:16:51,360
However, it is equivalent to printing the string itself.

1652
01:16:51,360 --> 01:16:54,240
It's just C and printf knows when you use

1653
01:16:54,240 --> 01:16:56,550
percent s and you pass on the name of a variable,

1654
01:16:56,550 --> 01:17:00,090
all printf is probably doing under the hood is some kind of loop

1655
01:17:00,090 --> 01:17:03,450
and it's iterating over your string from the first character and it's checking,

1656
01:17:03,450 --> 01:17:04,680
is this the null character?

1657
01:17:04,680 --> 01:17:05,760
If not, print it.

1658
01:17:05,760 --> 01:17:06,930
Is this the null character?

1659
01:17:06,930 --> 01:17:07,672
If not, print it.

1660
01:17:07,672 --> 01:17:10,130
If this is the null character-- is this the null character?

1661
01:17:10,130 --> 01:17:10,980
If not, print it.

1662
01:17:10,980 --> 01:17:18,300
And that's how we get, E-M-M-A stop, because printf, in this line 12,

1663
01:17:18,300 --> 01:17:24,510
presumably noticed, oh, wait a minute, the fifth byte in Emma's names zero

1664
01:17:24,510 --> 01:17:29,143
array is backslash zero, or all eight bits as zero.

1665
01:17:29,143 --> 01:17:29,643
Yeah?

1666
01:17:29,643 --> 01:17:32,160
AUDIENCE: That's just part of [INAUDIBLE]

1667
01:17:32,160 --> 01:17:35,160
DAVID MALAN: That is all part of the underneath the hood stuff of printf

1668
01:17:35,160 --> 01:17:38,740
and it's what humans decided decades ago with C how strings would work.

1669
01:17:38,740 --> 01:17:40,740
They could have come up with a different system,

1670
01:17:40,740 --> 01:17:44,250
but this is the system that they decided to use.

1671
01:17:44,250 --> 01:17:45,210
Other questions?

1672
01:17:45,210 --> 01:17:45,941
Yeah?

1673
01:17:45,941 --> 01:17:49,869
AUDIENCE: [INAUDIBLE]

1674
01:17:49,869 --> 01:17:58,710


1675
01:17:58,710 --> 01:18:00,130
DAVID MALAN: I didn't go further.

1676
01:18:00,130 --> 01:18:05,400
So I deliberately did not touch bracket four, even though it's there.

1677
01:18:05,400 --> 01:18:06,570
But I can try to print this.

1678
01:18:06,570 --> 01:18:07,130
Let's see.

1679
01:18:07,130 --> 01:18:09,700
So let me go ahead and change this program real quick.

1680
01:18:09,700 --> 01:18:12,720
I'm going to go ahead and print out percent C a fifth time.

1681
01:18:12,720 --> 01:18:18,030
And let's go ahead and see if we can see Emma's null terminating character

1682
01:18:18,030 --> 01:18:22,500
at location four, which is her fifth location, so after the E-M-M-A.

1683
01:18:22,500 --> 01:18:23,820
Let me save that.

1684
01:18:23,820 --> 01:18:27,920
Make names, dot slash names, Emma Emma.

1685
01:18:27,920 --> 01:18:28,920
So I don't see it there.

1686
01:18:28,920 --> 01:18:29,670
But you know what?

1687
01:18:29,670 --> 01:18:32,482
Let me try changing this last one just for kicks to percent i.

1688
01:18:32,482 --> 01:18:34,440
And again, this is where printf is your friend.

1689
01:18:34,440 --> 01:18:36,600
You can use it powerfully to see what's going on.

1690
01:18:36,600 --> 01:18:38,490
Or we could whip out debug 50.

1691
01:18:38,490 --> 01:18:42,150
Let me go ahead and make names, dot slash names.

1692
01:18:42,150 --> 01:18:43,835
And voila, there's the zero.

1693
01:18:43,835 --> 01:18:45,960
I'm printing it literally as an int just to see it.

1694
01:18:45,960 --> 01:18:47,627
I would never do this in the real world.

1695
01:18:47,627 --> 01:18:49,260
But it's indeed there.

1696
01:18:49,260 --> 01:18:51,800
And now, this doesn't often work, but just for kicks--

1697
01:18:51,800 --> 01:18:53,040
I'm getting a little crazy--

1698
01:18:53,040 --> 01:18:55,650
suppose that I want to look well past Emma's name

1699
01:18:55,650 --> 01:18:59,310
to like location 400, like let's start poking around in the computer's memory,

1700
01:18:59,310 --> 01:19:00,510
one of those other boxes.

1701
01:19:00,510 --> 01:19:03,360
Make names, dot slash names.

1702
01:19:03,360 --> 01:19:06,420
OK, there's a negative three down there as well, or technically

1703
01:19:06,420 --> 01:19:07,530
a hyphen and then a three.

1704
01:19:07,530 --> 01:19:09,780
So we'll come back to this in a couple of weeks' time.

1705
01:19:09,780 --> 01:19:13,560
We can actually start hacking around and looking around my computer's memory

1706
01:19:13,560 --> 01:19:18,930
at any location, because it's just numbers of boxes on the screen.

1707
01:19:18,930 --> 01:19:19,671
Yeah?

1708
01:19:19,671 --> 01:19:22,500
AUDIENCE: Is there any limit to the length of the string?

1709
01:19:22,500 --> 01:19:25,020
DAVID MALAN: Is there any limit to the length of the string?

1710
01:19:25,020 --> 01:19:30,440
Short answer-- yes, the amount of memory that the computer has.

1711
01:19:30,440 --> 01:19:32,140
So like 2 billion 4 billion--

1712
01:19:32,140 --> 01:19:33,915
it's long.

1713
01:19:33,915 --> 01:19:37,153
AUDIENCE: What happens if try to type in [INAUDIBLE]

1714
01:19:37,153 --> 01:19:38,570
DAVID MALAN: Really good question.

1715
01:19:38,570 --> 01:19:40,240
What happens if you try to type that in hypothetically?

1716
01:19:40,240 --> 01:19:41,500
It depends on the function you use.

1717
01:19:41,500 --> 01:19:43,500
Let me come back to that in like two weeks time.

1718
01:19:43,500 --> 01:19:45,250
Get string will not crash.

1719
01:19:45,250 --> 01:19:48,640
Other C functions will crash, if you give them more input than they expect,

1720
01:19:48,640 --> 01:19:50,950
and we'll come back to the reasons why.

1721
01:19:50,950 --> 01:19:53,642
So what's actually going on underneath this hood, then,

1722
01:19:53,642 --> 01:19:54,850
if we have these four names--

1723
01:19:54,850 --> 01:19:56,370
Emma, Rodrigo, Brian, and David.

1724
01:19:56,370 --> 01:19:59,530
Well, if we consider our memory again, we know that Emma's up at this first

1725
01:19:59,530 --> 01:20:03,340
location, E-M-M-A, followed by this null terminating character.

1726
01:20:03,340 --> 01:20:06,190
But if the second name we stored in a variable was Rodrigo,

1727
01:20:06,190 --> 01:20:09,610
turns out he's going to end up sort of back to back with that memory as well.

1728
01:20:09,610 --> 01:20:12,220
And again, it's wrapping only because this is an artist's rendition of what

1729
01:20:12,220 --> 01:20:12,970
memory looks like.

1730
01:20:12,970 --> 01:20:15,400
There's no notion of left, right, up, or down in RAM.

1731
01:20:15,400 --> 01:20:20,380
But he is R-O-D-R-I-G-O, and his null terminating character there.

1732
01:20:20,380 --> 01:20:21,460
Brian might end up there.

1733
01:20:21,460 --> 01:20:22,750
I might end up after it.

1734
01:20:22,750 --> 01:20:25,780
And this is what's really going on underneath the hood of your computer.

1735
01:20:25,780 --> 01:20:28,030
Each of these values isn't technically a character.

1736
01:20:28,030 --> 01:20:29,290
It's technically a number.

1737
01:20:29,290 --> 01:20:30,790
And frankly, it's not even a number.

1738
01:20:30,790 --> 01:20:32,890
It's eight bits at a time.

1739
01:20:32,890 --> 01:20:35,800
But again, we don't have to worry about that level of detail now

1740
01:20:35,800 --> 01:20:38,660
that we're operating at this level of abstraction.

1741
01:20:38,660 --> 01:20:40,917
And I put up the wrong code a moment ago.

1742
01:20:40,917 --> 01:20:43,750
This is the code that I actually implemented using an array from the

1743
01:20:43,750 --> 01:20:47,470
get go, as opposed to an actual--

1744
01:20:47,470 --> 01:20:49,660
as opposed to four separate variables.

1745
01:20:49,660 --> 01:20:52,540
So just to highlight, then, what's going on, per the example I just

1746
01:20:52,540 --> 01:20:56,590
did with printing out Emma's characters, if this is a variable called names,

1747
01:20:56,590 --> 01:21:01,360
and there's four names in it, zero, one, two, three,

1748
01:21:01,360 --> 01:21:05,800
you can think of every character as being kind of addressable

1749
01:21:05,800 --> 01:21:07,580
using square bracket notation.

1750
01:21:07,580 --> 01:21:10,870
The first set of square brackets picks the name in question.

1751
01:21:10,870 --> 01:21:14,230
The second set of square brackets picks the character within the name.

1752
01:21:14,230 --> 01:21:17,740
So e is the first character, so that's zero. m is the next one, so that's one.

1753
01:21:17,740 --> 01:21:21,850
m is the third, so that's two. a Is the fourth, and so that's three.

1754
01:21:21,850 --> 01:21:26,183
And then with Rodrigo, he's at names one, and his r is in brackets zero.

1755
01:21:26,183 --> 01:21:28,100
So again, we're really getting into the weeds.

1756
01:21:28,100 --> 01:21:31,100
And this is not what programming ultimately is, but this is just to say,

1757
01:21:31,100 --> 01:21:34,630
there's no magic when you use printf and get string and get int, and so forth.

1758
01:21:34,630 --> 01:21:40,390
All that's going on underneath the hood is manipulation of values like these.

1759
01:21:40,390 --> 01:21:44,230
So let's now see what a string really is and we'll ultimately conclude today

1760
01:21:44,230 --> 01:21:46,030
with some domain specific problems.

1761
01:21:46,030 --> 01:21:48,130
Indeed with problem set two will you be exploring

1762
01:21:48,130 --> 01:21:50,830
a number of real-world problems, like assessing just how

1763
01:21:50,830 --> 01:21:54,607
readable some text is, what grade level might a certain book or another be,

1764
01:21:54,607 --> 01:21:56,690
and two, implementing some notion of cryptography,

1765
01:21:56,690 --> 01:21:58,330
the art of scrambling information.

1766
01:21:58,330 --> 01:22:00,610
And suffice it to say, in both of those domains,

1767
01:22:00,610 --> 01:22:03,490
reading texts and also cryptography, strings

1768
01:22:03,490 --> 01:22:05,840
are going to be the ingredient that we need.

1769
01:22:05,840 --> 01:22:09,550
So let's take a look now at a few examples involving

1770
01:22:09,550 --> 01:22:11,330
more and more strings.

1771
01:22:11,330 --> 01:22:16,210
I'm going to go ahead and create a program here called string dot c,

1772
01:22:16,210 --> 01:22:17,710
just so I can play with this notion.

1773
01:22:17,710 --> 01:22:20,470
I'm going to go ahead and include CS50 dot h.

1774
01:22:20,470 --> 01:22:24,550
I'm going to go ahead and include standard Io dot h.

1775
01:22:24,550 --> 01:22:25,990
I'll fix this up here--

1776
01:22:25,990 --> 01:22:26,993
int main void.

1777
01:22:26,993 --> 01:22:30,160
And now let me go ahead and just play around with some strings for a moment.

1778
01:22:30,160 --> 01:22:32,720
Let me go ahead and get myself a string from the user.

1779
01:22:32,720 --> 01:22:36,940
So get string and ask for their input.

1780
01:22:36,940 --> 01:22:38,890
Trying to type too fast now.

1781
01:22:38,890 --> 01:22:41,860
So let me go ahead and ask the user for their input via get string,

1782
01:22:41,860 --> 01:22:44,260
and store the answer in a variable called s.

1783
01:22:44,260 --> 01:22:46,030
Then let me go ahead and preemptively say

1784
01:22:46,030 --> 01:22:48,610
that their output is going to be the following.

1785
01:22:48,610 --> 01:22:51,760
And what I want to do is just print out the individual characters

1786
01:22:51,760 --> 01:22:53,060
in that string.

1787
01:22:53,060 --> 01:22:57,400
So for int i get to zero, I don't know what my condition is yet,

1788
01:22:57,400 --> 01:23:00,180
so I'll come back to that-- i plus plus.

1789
01:23:00,180 --> 01:23:03,730
I'm going to go ahead and print out the individual character

1790
01:23:03,730 --> 01:23:06,680
at the i-th location in that string, and I'm

1791
01:23:06,680 --> 01:23:08,680
going to end this whole program with a new line.

1792
01:23:08,680 --> 01:23:12,490
So I still have a blank to fill in, these question marks, but I ultimately

1793
01:23:12,490 --> 01:23:15,490
just want to take as input a string, and then print it out as output,

1794
01:23:15,490 --> 01:23:18,370
but not using percent s.

1795
01:23:18,370 --> 01:23:21,670
I'm going to use percent c, one character at a time.

1796
01:23:21,670 --> 01:23:26,080
So my question mark here is what question could I ask on every iteration

1797
01:23:26,080 --> 01:23:30,660
before deciding whether or not I've printed every character in the string?

1798
01:23:30,660 --> 01:23:31,160
Yeah?

1799
01:23:31,160 --> 01:23:32,480
AUDIENCE: Length of the string.

1800
01:23:32,480 --> 01:23:33,730
DAVID MALAN: Length of string.

1801
01:23:33,730 --> 01:23:36,105
So I could say while i is less than the length of string.

1802
01:23:36,105 --> 01:23:36,913
What else?

1803
01:23:36,913 --> 01:23:37,720
AUDIENCE: The null character.

1804
01:23:37,720 --> 01:23:39,070
DAVID MALAN: Or if it's equal to the null character.

1805
01:23:39,070 --> 01:23:40,070
Let's try both of these.

1806
01:23:40,070 --> 01:23:42,790
So if I know how strings are represented,

1807
01:23:42,790 --> 01:23:47,718
I can just say while s bracket i does not equal backslash zero.

1808
01:23:47,718 --> 01:23:50,260
Now this is a bit of a funky syntax, because even though it's

1809
01:23:50,260 --> 01:23:53,290
two characters, I still have to use single quotes,

1810
01:23:53,290 --> 01:23:55,990
because those two characters, just like backslash n,

1811
01:23:55,990 --> 01:23:58,960
represent one idea, not two literal characters.

1812
01:23:58,960 --> 01:24:01,780
But this is a literal translation of what we just discussed.

1813
01:24:01,780 --> 01:24:05,050
Initialize i to zero, incremented on every iteration,

1814
01:24:05,050 --> 01:24:09,220
but every time you do that check does the i-th character in the string

1815
01:24:09,220 --> 01:24:13,300
equal the special null character, and if so, that's it for the loop.

1816
01:24:13,300 --> 01:24:15,320
We only want to iterate through this for loop

1817
01:24:15,320 --> 01:24:18,520
so long as it's not that special backslash zero.

1818
01:24:18,520 --> 01:24:22,810
So if I go ahead now and save this file and make string and run

1819
01:24:22,810 --> 01:24:27,220
dot slash string and my input for instance is Emma, Enter,

1820
01:24:27,220 --> 01:24:29,260
I'm going to see literally her name back.

1821
01:24:29,260 --> 01:24:33,400
So this is kind of my way of re implementing the idea of percent s,

1822
01:24:33,400 --> 01:24:34,813
but using only percent c.

1823
01:24:34,813 --> 01:24:35,980
But I liked your suggestion.

1824
01:24:35,980 --> 01:24:37,230
Why don't we use the string--

1825
01:24:37,230 --> 01:24:40,988
the length of the string, rather than this low-level implementation detail?

1826
01:24:40,988 --> 01:24:42,780
It would be really nice if I could just say

1827
01:24:42,780 --> 01:24:48,690
while i is less than the length of s--

1828
01:24:48,690 --> 01:24:50,440
so how do express this?

1829
01:24:50,440 --> 01:24:55,560
Well, it turns out there's another file called

1830
01:24:55,560 --> 01:24:59,610
string dot h inside of which are a bunch of string-related functions

1831
01:24:59,610 --> 01:25:00,900
that I might like to use.

1832
01:25:00,900 --> 01:25:04,950
One of those is a function called str leng, for short,

1833
01:25:04,950 --> 01:25:07,150
which means the length of a string.

1834
01:25:07,150 --> 01:25:09,130
So I can take your suggestion and just say,

1835
01:25:09,130 --> 01:25:10,838
I don't care how a string is implemented.

1836
01:25:10,838 --> 01:25:12,755
I mean, my god, the whole point of programming

1837
01:25:12,755 --> 01:25:15,840
ultimately is too abstract on those lower level implementation details.

1838
01:25:15,840 --> 01:25:18,600
Let me just ask the computer what is your length, so

1839
01:25:18,600 --> 01:25:20,070
that I don't count past it.

1840
01:25:20,070 --> 01:25:24,540
Let me go ahead now and make string, dot slash string.

1841
01:25:24,540 --> 01:25:26,010
Let's type in Emma again.

1842
01:25:26,010 --> 01:25:28,030
And the output is the same.

1843
01:25:28,030 --> 01:25:33,090
But now, this is correct perhaps, but I argue it's not very well-designed.

1844
01:25:33,090 --> 01:25:36,300
I'm being a little inefficient and I bet I can do this better.

1845
01:25:36,300 --> 01:25:37,280
What do you see?

1846
01:25:37,280 --> 01:25:38,423
AUDIENCE: [INAUDIBLE]

1847
01:25:38,423 --> 01:25:39,340
DAVID MALAN: Go ahead.

1848
01:25:39,340 --> 01:25:43,290
AUDIENCE: [INAUDIBLE]

1849
01:25:43,290 --> 01:25:45,300
DAVID MALAN: Yeah, exactly.

1850
01:25:45,300 --> 01:25:47,910
Remember in a for loop that the condition in the middle,

1851
01:25:47,910 --> 01:25:50,790
in between the semicolons, is a question, a Boolean expression,

1852
01:25:50,790 --> 01:25:53,620
that you ask again and again and again.

1853
01:25:53,620 --> 01:25:56,940
And it turns out that calling a function is not without cost.

1854
01:25:56,940 --> 01:25:59,770
It might take a split second, because computers are super fast,

1855
01:25:59,770 --> 01:26:04,140
but why are you asking the same question again and again and again and again.

1856
01:26:04,140 --> 01:26:07,080
The answer is never going to change, because Emma's name is not

1857
01:26:07,080 --> 01:26:09,630
growing or shrinking, it's just Emma.

1858
01:26:09,630 --> 01:26:11,350
So I can solve this in a couple of ways.

1859
01:26:11,350 --> 01:26:12,642
I could do something like this.

1860
01:26:12,642 --> 01:26:17,130
Int n get str leng of s, and then I could just plug in n.

1861
01:26:17,130 --> 01:26:20,460
My program is just as correct, but it's a little better designed

1862
01:26:20,460 --> 01:26:23,250
now because I'm asking the question of string length

1863
01:26:23,250 --> 01:26:27,333
once, remembering the answer, and then using that answer again and again.

1864
01:26:27,333 --> 01:26:30,000
Now, yes, technically, now I'm wasting some space, because I now

1865
01:26:30,000 --> 01:26:31,440
have another variable called n.

1866
01:26:31,440 --> 01:26:32,530
So something's gotta give.

1867
01:26:32,530 --> 01:26:35,220
I'm going to use more space or maybe more time,

1868
01:26:35,220 --> 01:26:37,802
but that's a theme we'll come back to next week especially.

1869
01:26:37,802 --> 01:26:40,260
But it turns out there's some special syntax for this, too.

1870
01:26:40,260 --> 01:26:43,980
If you know in a loop that you want to ask a question once and remember

1871
01:26:43,980 --> 01:26:48,210
the answer, you can actually just say this and do this all in one line.

1872
01:26:48,210 --> 01:26:51,900
It's no better or worse, it's just a little more succinct, stylistically.

1873
01:26:51,900 --> 01:26:55,740
This has the same effect of initializing i to zero, and n

1874
01:26:55,740 --> 01:27:00,190
to the length of string, and then never again asking that question.

1875
01:27:00,190 --> 01:27:00,990
So I can save this.

1876
01:27:00,990 --> 01:27:03,120
I can make string.

1877
01:27:03,120 --> 01:27:05,100
I can then do dot slash string, and I'm going

1878
01:27:05,100 --> 01:27:07,560
to see hopefully, Emma, Emma again.

1879
01:27:07,560 --> 01:27:10,960
So a third and final version of this idea, but a little better Designed.

1880
01:27:10,960 --> 01:27:11,996
Yeah?

1881
01:27:11,996 --> 01:27:15,670
AUDIENCE: [INAUDIBLE]

1882
01:27:15,670 --> 01:27:15,672


1883
01:27:15,672 --> 01:27:17,130
DAVID MALAN: In this case, it's OK.

1884
01:27:17,130 --> 01:27:18,420
This would be a common convention.

1885
01:27:18,420 --> 01:27:20,280
When you are doing something especially to minimize

1886
01:27:20,280 --> 01:27:22,710
the number of questions you're asking, this is OK, so long

1887
01:27:22,710 --> 01:27:23,910
as it's still pretty tight.

1888
01:27:23,910 --> 01:27:26,590
But there, too, reasonable people might disagree.

1889
01:27:26,590 --> 01:27:27,230
Yeah?

1890
01:27:27,230 --> 01:27:29,703
AUDIENCE: Is the prototype string in library [INAUDIBLE]??

1891
01:27:29,703 --> 01:27:31,120
DAVID MALAN: Really good question.

1892
01:27:31,120 --> 01:27:34,902
The prototype for string, its declaration, is in string dot h.

1893
01:27:34,902 --> 01:27:36,860
I would get one of those cryptic error messages

1894
01:27:36,860 --> 01:27:40,400
if I forgot to include string dot h, because clang would not

1895
01:27:40,400 --> 01:27:43,910
know that str leng actually exists.

1896
01:27:43,910 --> 01:27:46,490
Let me try another example here and see what kind of power

1897
01:27:46,490 --> 01:27:51,140
we have now that we actually are controlling--

1898
01:27:51,140 --> 01:27:53,690
now that we actually understand what a string actually is.

1899
01:27:53,690 --> 01:27:55,482
Let me go ahead and whip this up real fast.

1900
01:27:55,482 --> 01:27:58,190
So up here in my program, called uppercase dot c,

1901
01:27:58,190 --> 01:28:00,350
me give myself the CS50 library.

1902
01:28:00,350 --> 01:28:02,270
Let me give myself standard Io dot h.

1903
01:28:02,270 --> 01:28:06,140
And now let me give me string dot h, just so I can use str leng.

1904
01:28:06,140 --> 01:28:09,440
Let me give myself the name of a function main.

1905
01:28:09,440 --> 01:28:11,630
And then in here, let's do the same thing.

1906
01:28:11,630 --> 01:28:13,868
String s gets get string.

1907
01:28:13,868 --> 01:28:16,160
But this time, let me just ask the human for the string

1908
01:28:16,160 --> 01:28:18,290
before I'm going to do something to it.

1909
01:28:18,290 --> 01:28:24,230
Then I'm going to go ahead and say after I want the following to happen.

1910
01:28:24,230 --> 01:28:25,550
And I'm going to do this--

1911
01:28:25,550 --> 01:28:31,610
for int i get zero, n equal str leng s as before.

1912
01:28:31,610 --> 01:28:35,390
Do this so long as i is less than n, and on each iteration, i plus plus.

1913
01:28:35,390 --> 01:28:36,740
So copy-paste from before.

1914
01:28:36,740 --> 01:28:38,930
I just retyped out the same thing.

1915
01:28:38,930 --> 01:28:42,170
Now let me go ahead and in this for loop, let me change

1916
01:28:42,170 --> 01:28:45,410
this string, whatever it is, all to uppercase.

1917
01:28:45,410 --> 01:28:46,590
So how might I do this?

1918
01:28:46,590 --> 01:28:52,280
So let me go ahead and say, well, if the current character at s bracket i

1919
01:28:52,280 --> 01:28:58,700
is greater than or equal to lower case a, and that same character is less than

1920
01:28:58,700 --> 01:29:00,187
or equal to lowercase z.

1921
01:29:00,187 --> 01:29:03,020
So I'm using some week one style stuff, even though we didn't really

1922
01:29:03,020 --> 01:29:04,850
use this much syntax last week.

1923
01:29:04,850 --> 01:29:06,440
I'm just asking a simple question.

1924
01:29:06,440 --> 01:29:11,480
Is the i-th character in s greater than or equal to lowercase a and--

1925
01:29:11,480 --> 01:29:13,370
double ampersand means and--

1926
01:29:13,370 --> 01:29:16,570
logically, is that character less than or equal to z?

1927
01:29:16,570 --> 01:29:19,940
So is it a, b, c, all the way through z-- is it a lowercase letter?

1928
01:29:19,940 --> 01:29:24,120
If so, I want to do something like convert to uppercase.

1929
01:29:24,120 --> 01:29:26,180
But we'll come back to that in just a moment.

1930
01:29:26,180 --> 01:29:30,590
Else what do I want to do if the character is not lowercase

1931
01:29:30,590 --> 01:29:33,096
and my goal is to uppercase the whole input?

1932
01:29:33,096 --> 01:29:34,250
AUDIENCE: [INAUDIBLE]

1933
01:29:34,250 --> 01:29:35,300
DAVID MALAN: Yeah, just leave it alone.

1934
01:29:35,300 --> 01:29:35,690
So you know what?

1935
01:29:35,690 --> 01:29:37,773
I'm just-- fine, I'm just going to leave it alone.

1936
01:29:37,773 --> 01:29:40,842
I'm going to print it back out, just as I would with printf like that.

1937
01:29:40,842 --> 01:29:42,800
So now even though this is not obvious from the

1938
01:29:42,800 --> 01:29:45,830
get go how I'm going to solve this, I've now left myself

1939
01:29:45,830 --> 01:29:47,540
a placeholder, pseudocode if you will.

1940
01:29:47,540 --> 01:29:49,830
I just now need to answer this question.

1941
01:29:49,830 --> 01:29:56,602
Well, it turns out a popular place to go for this answer would be AsciiChart.com

1942
01:29:56,602 --> 01:29:58,310
And there's different ways to solve this,

1943
01:29:58,310 --> 01:30:00,060
but this is just a free website that shows

1944
01:30:00,060 --> 01:30:02,480
us all of the decimal numbers that correspond to letters.

1945
01:30:02,480 --> 01:30:08,460
And recall from week zero, 65 is a, 66 is b, and so forth.

1946
01:30:08,460 --> 01:30:11,090
Notice that 65 is-- capital A is 65.

1947
01:30:11,090 --> 01:30:12,736
What is lowercase a?

1948
01:30:12,736 --> 01:30:14,640
AUDIENCE: [INAUDIBLE]

1949
01:30:14,640 --> 01:30:16,180
DAVID MALAN: 97.

1950
01:30:16,180 --> 01:30:22,330
And then look-- 66 to 98, 67 to 99, 68 to 100--

1951
01:30:22,330 --> 01:30:24,690
what's the difference between these?

1952
01:30:24,690 --> 01:30:25,720
Yeah, it's 32.

1953
01:30:25,720 --> 01:30:28,510
If you add 32 to 65, you get 97.

1954
01:30:28,510 --> 01:30:31,640
If you add 32 to 66, you get 98, and so forth.

1955
01:30:31,640 --> 01:30:34,870
So it seems that the lowercase letters, wonderfully conveniently,

1956
01:30:34,870 --> 01:30:39,880
are all 32 values away from the uppercase letters.

1957
01:30:39,880 --> 01:30:42,460
Or conversely, if I have a lowercase letter,

1958
01:30:42,460 --> 01:30:45,460
logically, what could I do to it in order

1959
01:30:45,460 --> 01:30:49,960
to convert it from uppercase to lowercase--

1960
01:30:49,960 --> 01:30:53,180
Sorry-- from lowercase to uppercase?

1961
01:30:53,180 --> 01:30:54,240
Subtract, right?

1962
01:30:54,240 --> 01:30:58,300
So why don't I try printing out printf, percent c,

1963
01:30:58,300 --> 01:31:01,450
then go ahead and print out not the actual character,

1964
01:31:01,450 --> 01:31:03,193
but just subtract 32 from it.

1965
01:31:03,193 --> 01:31:05,110
I know these are integers underneath the hood.

1966
01:31:05,110 --> 01:31:07,000
And frankly, if I want to be really explicit,

1967
01:31:07,000 --> 01:31:10,960
I can convert it to an integer, the Ascii code, and then subtract 32,

1968
01:31:10,960 --> 01:31:14,120
but that can be done implicitly-- we saw earlier.

1969
01:31:14,120 --> 01:31:17,740
So let me go ahead and save this file and run uppercase,

1970
01:31:17,740 --> 01:31:20,290
make uppercase, dot slash uppercase.

1971
01:31:20,290 --> 01:31:24,280
And this time, let me write Emma's name in all lowercase, and voila,

1972
01:31:24,280 --> 01:31:24,940
I see it here.

1973
01:31:24,940 --> 01:31:25,898
Now it's a little ugly.

1974
01:31:25,898 --> 01:31:26,705
What did I forget?

1975
01:31:26,705 --> 01:31:27,580
AUDIENCE: [INAUDIBLE]

1976
01:31:27,580 --> 01:31:28,310
DAVID MALAN: A new line.

1977
01:31:28,310 --> 01:31:31,143
So I'm going to go ahead and do that at the very end of the program,

1978
01:31:31,143 --> 01:31:33,100
so I get it only once at the very end.

1979
01:31:33,100 --> 01:31:38,140
Let me rerun-- make uppercase, dot slash uppercase, Emma in lowercase.

1980
01:31:38,140 --> 01:31:39,980
Voila, I've got it uppercase.

1981
01:31:39,980 --> 01:31:42,993
So this is like a very low-level implementation

1982
01:31:42,993 --> 01:31:44,660
of the notion of upper casing something.

1983
01:31:44,660 --> 01:31:46,780
So if you've ever done this in Google Docs or Microsoft Word--

1984
01:31:46,780 --> 01:31:48,370
convert this all to uppercase for whatever

1985
01:31:48,370 --> 01:31:51,010
reason, that's all the computer is doing underneath the hood--

1986
01:31:51,010 --> 01:31:54,850
iterating over the characters and presumably subtracting off of that.

1987
01:31:54,850 --> 01:31:57,970
But this, too, is at a low-level detail that we probably

1988
01:31:57,970 --> 01:31:59,830
don't want to have to think about too much,

1989
01:31:59,830 --> 01:32:02,872
and so it turns out there's functions that can solve this problem for us.

1990
01:32:02,872 --> 01:32:06,320
And you might have discovered these last week or used them yourself.

1991
01:32:06,320 --> 01:32:10,210
But on CS50's website is an example of what are called manual pages.

1992
01:32:10,210 --> 01:32:13,840
And if I go ahead and pull this up on the course's website,

1993
01:32:13,840 --> 01:32:17,560
we'll see a tool that adds the following.

1994
01:32:17,560 --> 01:32:25,070
If I go to the course's web page and click on manual pages,

1995
01:32:25,070 --> 01:32:27,190
you'll see the CS50 programmers manual, which

1996
01:32:27,190 --> 01:32:29,560
is a simplified version of a very popular tool that's

1997
01:32:29,560 --> 01:32:32,770
available on most computer systems that support programming.

1998
01:32:32,770 --> 01:32:36,430
And suppose I want to do something like convert something to uppercase,

1999
01:32:36,430 --> 01:32:37,730
I can search up there.

2000
01:32:37,730 --> 01:32:39,820
And notice, there's a few functions available in C

2001
01:32:39,820 --> 01:32:41,020
that relate to uppercase.

2002
01:32:41,020 --> 01:32:44,470
Is upper, which asks a question, to lower and to upper.

2003
01:32:44,470 --> 01:32:46,200
I'm going to go ahead and use to upper.

2004
01:32:46,200 --> 01:32:47,860
I'm going to go ahead and use to upper.

2005
01:32:47,860 --> 01:32:51,300
And if I click on this, I'll see essentially its documentation for it.

2006
01:32:51,300 --> 01:32:53,050
And it's a little cryptic at first glance.

2007
01:32:53,050 --> 01:32:55,060
But what you're seeing in the documentation

2008
01:32:55,060 --> 01:32:58,900
is it's required header file and it's prototype.

2009
01:32:58,900 --> 01:33:02,441
What file do I apparently need to include to use to upper?

2010
01:33:02,441 --> 01:33:03,316
AUDIENCE: [INAUDIBLE]

2011
01:33:03,316 --> 01:33:04,649
DAVID MALAN: Yeah, c type dot h.

2012
01:33:04,649 --> 01:33:06,399
I don't really know what else is in there,

2013
01:33:06,399 --> 01:33:08,410
but this is my hint that I should use that file.

2014
01:33:08,410 --> 01:33:11,080
And what kind of input does to upper take?

2015
01:33:11,080 --> 01:33:13,270
Well technically, it takes an int, for reasons that

2016
01:33:13,270 --> 01:33:14,800
are explained in the documentation.

2017
01:33:14,800 --> 01:33:17,110
But even if the documentation is not obvious,

2018
01:33:17,110 --> 01:33:19,880
it turns out it's actually pretty easy to use.

2019
01:33:19,880 --> 01:33:23,470
I'm going to go ahead and rip out most of this logic,

2020
01:33:23,470 --> 01:33:28,480
and I'm just going to do this-- printf, percent c, to upper,

2021
01:33:28,480 --> 01:33:31,180
s bracket i, semicolon.

2022
01:33:31,180 --> 01:33:35,650
And up here, I'm going to go ahead and include c type dot h,

2023
01:33:35,650 --> 01:33:37,660
because in reading the documentation, I realize

2024
01:33:37,660 --> 01:33:41,320
that oh, I can pass in any character to to upper, and if it's lowercase,

2025
01:33:41,320 --> 01:33:44,800
it's going to return in uppercase, and if it's not a lowercase letter,

2026
01:33:44,800 --> 01:33:47,450
it's just going to return it unchanged.

2027
01:33:47,450 --> 01:33:51,400
So if I save this file now, make uppercase, and then rerun

2028
01:33:51,400 --> 01:33:56,140
this program, this time typing in Emma's name again in lowercase, voila,

2029
01:33:56,140 --> 01:33:59,230
I've now used another helper function, something someone else wrote.

2030
01:33:59,230 --> 01:34:02,050
But you can imagine that all the person did

2031
01:34:02,050 --> 01:34:04,150
who wrote this function for us is what?

2032
01:34:04,150 --> 01:34:08,260
Like an if else, checking the Ascii mathematics to see

2033
01:34:08,260 --> 01:34:11,575
if the character is indeed lowercase.

2034
01:34:11,575 --> 01:34:14,270
Any questions then on this?

2035
01:34:14,270 --> 01:34:18,610
Again, now the goal is to move away from caring about 32 or the Ascii codes

2036
01:34:18,610 --> 01:34:21,520
and just using helper functions someone else wrote.

2037
01:34:21,520 --> 01:34:22,202
Yeah?

2038
01:34:22,202 --> 01:34:24,628
AUDIENCE: Why [INAUDIBLE]

2039
01:34:24,628 --> 01:34:26,170
DAVID MALAN: Why do you not need to--

2040
01:34:26,170 --> 01:34:29,052
AUDIENCE: [INAUDIBLE]

2041
01:34:29,052 --> 01:34:30,010
DAVID MALAN: The type--

2042
01:34:30,010 --> 01:34:31,900
Ah, why do you not need to declare the type of int.

2043
01:34:31,900 --> 01:34:32,440
I am.

2044
01:34:32,440 --> 01:34:35,440
This only works if it's the same type as i.

2045
01:34:35,440 --> 01:34:36,577
Good question.

2046
01:34:36,577 --> 01:34:39,410
So I get away with it because both i and n are meant to be integers.

2047
01:34:39,410 --> 01:34:40,090
Yeah?

2048
01:34:40,090 --> 01:34:44,010
AUDIENCE: [INAUDIBLE]

2049
01:34:44,010 --> 01:34:44,785


2050
01:34:44,785 --> 01:34:46,410
DAVID MALAN: Are there any limitations?

2051
01:34:46,410 --> 01:34:51,163
No, you may use any functions you want on CS50 problem sets,

2052
01:34:51,163 --> 01:34:52,830
whether or not we've used them in class.

2053
01:34:52,830 --> 01:34:54,913
That's certainly fine, unless otherwise specified,

2054
01:34:54,913 --> 01:34:56,710
which will rarely be the case.

2055
01:34:56,710 --> 01:34:58,023
So what else then can we do?

2056
01:34:58,023 --> 01:34:59,940
Well turns out, we've just empowered ourselves

2057
01:34:59,940 --> 01:35:01,890
with a couple of new features, one of which

2058
01:35:01,890 --> 01:35:04,140
is, again, called command line arguments.

2059
01:35:04,140 --> 01:35:05,850
We've seen these before.

2060
01:35:05,850 --> 01:35:09,420
What did I describe previously today and last week as a command line argument?

2061
01:35:09,420 --> 01:35:11,700
What was an example?

2062
01:35:11,700 --> 01:35:13,290
Anyone-- I heard here.

2063
01:35:13,290 --> 01:35:14,010
AUDIENCE: Dash o.

2064
01:35:14,010 --> 01:35:14,843
DAVID MALAN: Dash o.

2065
01:35:14,843 --> 01:35:17,490
Remember that clang can have its default behavior, which

2066
01:35:17,490 --> 01:35:20,520
was a little annoying, whereby it outputs a file called a dot out,

2067
01:35:20,520 --> 01:35:25,170
overridden by saying dash o hello, or dash o anything,

2068
01:35:25,170 --> 01:35:28,920
to change the output to a file of your choice.

2069
01:35:28,920 --> 01:35:31,080
That was an example of a command line argument.

2070
01:35:31,080 --> 01:35:33,917
You literally typed it after the command, on a line,

2071
01:35:33,917 --> 01:35:36,750
and it's an argument in the sense that it's an input to the program.

2072
01:35:36,750 --> 01:35:38,640
So a command line argument, more generally,

2073
01:35:38,640 --> 01:35:43,110
is just one or more words that you type at the prompt after the program you

2074
01:35:43,110 --> 01:35:44,370
care about running.

2075
01:35:44,370 --> 01:35:46,110
So where are these germane here?

2076
01:35:46,110 --> 01:35:51,300
Well finally, can we now explain what a little more of this canonical program

2077
01:35:51,300 --> 01:35:52,110
is about.

2078
01:35:52,110 --> 01:35:55,470
We already discussed earlier today that includes standard Io dot h.

2079
01:35:55,470 --> 01:35:57,900
It just contains your prototypes for things like printf,

2080
01:35:57,900 --> 01:36:01,110
and that gets copied and pasted during pre processing into the file,

2081
01:36:01,110 --> 01:36:02,290
and so forth.

2082
01:36:02,290 --> 01:36:05,110
But what we've not explained yet, what void is here,

2083
01:36:05,110 --> 01:36:06,330
let alone what int is here.

2084
01:36:06,330 --> 01:36:10,080
We've just been copying and pasting this now for just over a week.

2085
01:36:10,080 --> 01:36:15,570
Well it turns out, that in C, you do not need to write only the word void inside

2086
01:36:15,570 --> 01:36:16,830
of those parentheses.

2087
01:36:16,830 --> 01:36:21,000
You can also write, wonderfully, int arg c, string arg v, open bracket,

2088
01:36:21,000 --> 01:36:22,110
close bracket.

2089
01:36:22,110 --> 01:36:23,620
Now why is that compelling?

2090
01:36:23,620 --> 01:36:25,470
Well notice there's a pattern here, and it's

2091
01:36:25,470 --> 01:36:28,530
quite similar to my average function a moment ago.

2092
01:36:28,530 --> 01:36:30,750
It takes two arguments main, apparently.

2093
01:36:30,750 --> 01:36:34,360
One is an int, and one is what?

2094
01:36:34,360 --> 01:36:35,680
It's not a string, per se.

2095
01:36:35,680 --> 01:36:36,430
It's--

2096
01:36:36,430 --> 01:36:36,910
AUDIENCE: [INAUDIBLE]

2097
01:36:36,910 --> 01:36:38,420
DAVID MALAN: --an array of strings.

2098
01:36:38,420 --> 01:36:40,033
Now arg v is a human convention.

2099
01:36:40,033 --> 01:36:41,950
It means argument vector, which is a fancy way

2100
01:36:41,950 --> 01:36:44,590
of saying an array of arguments.

2101
01:36:44,590 --> 01:36:47,920
And the way you know this is an array is by the fact that you have open bracket

2102
01:36:47,920 --> 01:36:48,820
closed bracket.

2103
01:36:48,820 --> 01:36:51,760
And it's an array of strings because to the left is the word string.

2104
01:36:51,760 --> 01:36:54,430
This is just an old-school integer called int arg

2105
01:36:54,430 --> 01:36:57,850
c, which stands for by convention, argument count.

2106
01:36:57,850 --> 01:37:00,700
However, we could call these arguments anything we want.

2107
01:37:00,700 --> 01:37:03,550
Humans for decades have just called them arg c and arg v,

2108
01:37:03,550 --> 01:37:06,670
just like my average function took in the length of an array

2109
01:37:06,670 --> 01:37:10,690
and the number of scores inside of it.

2110
01:37:10,690 --> 01:37:13,450
So what-- the actual scores inside of it.

2111
01:37:13,450 --> 01:37:15,380
So what can we do with this information?

2112
01:37:15,380 --> 01:37:17,560
Well it turns out, we can now write programs

2113
01:37:17,560 --> 01:37:21,620
that take words from the human, not via get string, but at the actual command

2114
01:37:21,620 --> 01:37:22,120
prompt.

2115
01:37:22,120 --> 01:37:24,380
We can implement features, like clang has.

2116
01:37:24,380 --> 01:37:27,430
So let me go ahead and write a program called arg v in a file

2117
01:37:27,430 --> 01:37:28,900
called arg v dot c.

2118
01:37:28,900 --> 01:37:33,070
Let me go ahead include the CS50 library.

2119
01:37:33,070 --> 01:37:37,980
Let me go ahead and include standard Io dot h.

2120
01:37:37,980 --> 01:37:38,830
Voila.

2121
01:37:38,830 --> 01:37:43,000
Now let me go ahead and do int main not void, int arg

2122
01:37:43,000 --> 01:37:47,140
c, string arg v, open brackets.

2123
01:37:47,140 --> 01:37:50,350
So it's actually worse than it has been, but now it's useful.

2124
01:37:50,350 --> 01:37:51,130
We'll see.

2125
01:37:51,130 --> 01:37:53,180
And now I'm going to go ahead and do this.

2126
01:37:53,180 --> 01:37:59,050
Let me go ahead and say if arg c equals two,

2127
01:37:59,050 --> 01:38:02,630
that's going to mean that the human has typed two words at their prompt.

2128
01:38:02,630 --> 01:38:07,630
And I'm going to go ahead and say this, hello percent s, new line,

2129
01:38:07,630 --> 01:38:11,230
and then I'm going to plug in arg v bracket one,

2130
01:38:11,230 --> 01:38:15,160
for reasons we'll soon see, else if arg c does not equal two,

2131
01:38:15,160 --> 01:38:20,050
I'm just going to hard code this and say hello, world, backslash n.

2132
01:38:20,050 --> 01:38:21,118
So what am I doing?

2133
01:38:21,118 --> 01:38:23,410
I'm trying to write a program that allows the human now

2134
01:38:23,410 --> 01:38:26,200
to write their name at the command prompt,

2135
01:38:26,200 --> 01:38:29,590
instead of waiting for the program to run and use get string [INAUDIBLE]

2136
01:38:29,590 --> 01:38:31,120
like a blinking prompt.

2137
01:38:31,120 --> 01:38:34,990
So what I can do now is this, make arg v. It compiles.

2138
01:38:34,990 --> 01:38:37,570
Dot slash arg v, Enter.

2139
01:38:37,570 --> 01:38:38,950
Hello, world.

2140
01:38:38,950 --> 01:38:45,480
So presumably, what does arg c equal when I run it in that way?

2141
01:38:45,480 --> 01:38:46,480
DAVID MALAN: Maybe one--

2142
01:38:46,480 --> 01:38:48,550
I mean, not two, at least, it stands to reason.

2143
01:38:48,550 --> 01:38:50,800
It's not two, because I didn't see my own name.

2144
01:38:50,800 --> 01:38:53,253
So if I go ahead and rerun it now, it would say David.

2145
01:38:53,253 --> 01:38:54,670
What's it going to say, hopefully?

2146
01:38:54,670 --> 01:38:56,950
Like, hello comma David?

2147
01:38:56,950 --> 01:38:57,850
And indeed, it does.

2148
01:38:57,850 --> 01:38:58,630
Why?

2149
01:38:58,630 --> 01:39:01,300
Well when you run a program that you have written in C

2150
01:39:01,300 --> 01:39:05,320
and you specify one or more words after your program's name,

2151
01:39:05,320 --> 01:39:09,400
you are handed those words in an array, called arg v,

2152
01:39:09,400 --> 01:39:13,700
and you are told how many words the human typed in arg c.

2153
01:39:13,700 --> 01:39:19,000
So the clang program, the make program, help 50, style 50, check 50,

2154
01:39:19,000 --> 01:39:21,610
all of the programs we've seen thus far that take words

2155
01:39:21,610 --> 01:39:24,570
after the program's names, literally are implemented with code

2156
01:39:24,570 --> 01:39:26,290
that's similar in spirit to this.

2157
01:39:26,290 --> 01:39:28,990
Some programmer checked oh, did the human type any words?

2158
01:39:28,990 --> 01:39:31,930
If so, maybe I want to output a different name than a dot out.

2159
01:39:31,930 --> 01:39:33,670
Maybe I want to output the name hello.

2160
01:39:33,670 --> 01:39:36,190
When you run make something, well what do you want to make?

2161
01:39:36,190 --> 01:39:40,120
That's a command line argument that the human programmer checked arg v for

2162
01:39:40,120 --> 01:39:43,270
to know what program it is you want to make.

2163
01:39:43,270 --> 01:39:47,090
So it's a simple idea, even though the syntax is admittedly pretty ugly.

2164
01:39:47,090 --> 01:39:48,490
But it's the same idea.

2165
01:39:48,490 --> 01:39:51,790
And the only two forms then, for main moving

2166
01:39:51,790 --> 01:39:55,150
forward are either this new one, which lets you accept command line arguments,

2167
01:39:55,150 --> 01:39:57,677
or the old one, which is when you know in advance I

2168
01:39:57,677 --> 01:39:59,260
don't need any command line arguments.

2169
01:39:59,260 --> 01:40:02,290
It's entirely up to you which to use, if you actually

2170
01:40:02,290 --> 01:40:05,510
want to accept command line arguments.

2171
01:40:05,510 --> 01:40:08,410
Now there's one last detail that we've not explained yet

2172
01:40:08,410 --> 01:40:10,180
and that's this one here.

2173
01:40:10,180 --> 01:40:13,030
Why the heck does main have a return value?

2174
01:40:13,030 --> 01:40:15,280
And there's not really a super compelling reason here,

2175
01:40:15,280 --> 01:40:18,160
but we can see that there's a low-level reason that this is useful,

2176
01:40:18,160 --> 01:40:20,290
but it's not something to stress over much.

2177
01:40:20,290 --> 01:40:25,030
It turns out that main by default in C does have a return value.

2178
01:40:25,030 --> 01:40:29,110
And even though we have never returned anything from main yet, by default,

2179
01:40:29,110 --> 01:40:30,990
main returns zero.

2180
01:40:30,990 --> 01:40:34,090
Zero in computers typically means all is well.

2181
01:40:34,090 --> 01:40:37,120
It's a little paradoxical, because you would think zero-- false-- bad.

2182
01:40:37,120 --> 01:40:39,410
But no, zero tends to be good.

2183
01:40:39,410 --> 01:40:44,260
The reason for this is that main can return non-zero values,

2184
01:40:44,260 --> 01:40:47,893
like one, or negative one, or 2 billion, or negative 2 billion.

2185
01:40:47,893 --> 01:40:50,560
In fact, if you've ever seen an error message on your Mac or PC,

2186
01:40:50,560 --> 01:40:52,477
sometimes there's a little window that pops up

2187
01:40:52,477 --> 01:40:55,750
and it's a cryptic looking code, like an error has happened, negative 42,

2188
01:40:55,750 --> 01:40:56,740
or whatever.

2189
01:40:56,740 --> 01:40:59,680
That number is just an arbitrary number some human

2190
01:40:59,680 --> 01:41:04,420
decided that their main program will return if something went wrong.

2191
01:41:04,420 --> 01:41:07,220
And we can do this as follows.

2192
01:41:07,220 --> 01:41:14,320
I can write a program like this in a file called exit dot c that has,

2193
01:41:14,320 --> 01:41:20,735
say, the CS50 library, that has includes standard Io dot h, int main void--

2194
01:41:20,735 --> 01:41:22,610
I'm going to go back to void, because I'm not

2195
01:41:22,610 --> 01:41:26,290
going to take any-- or actually, no, I'm going to do int rc,

2196
01:41:26,290 --> 01:41:30,377
and then string arg v brackets, so I can take a command line argument,

2197
01:41:30,377 --> 01:41:31,960
and I'm going to start to error check.

2198
01:41:31,960 --> 01:41:34,370
Suppose this is a program that the human is supposed

2199
01:41:34,370 --> 01:41:36,160
to provide a command line argument.

2200
01:41:36,160 --> 01:41:37,190
I'm going to do this.

2201
01:41:37,190 --> 01:41:40,190
If arg c does not equal two, you know what I'm going to do?

2202
01:41:40,190 --> 01:41:45,860
I'm going to yell at the user, say missing command line argument backslash

2203
01:41:45,860 --> 01:41:48,320
n, but now I want to quit from the program.

2204
01:41:48,320 --> 01:41:49,970
I want to do the equivalent of exit.

2205
01:41:49,970 --> 01:41:51,770
So how do you do that in C?

2206
01:41:51,770 --> 01:41:54,080
You actually return a value.

2207
01:41:54,080 --> 01:41:57,150
And if all was well, you would return zero.

2208
01:41:57,150 --> 01:42:00,470
However, if something went wrong, the sky's the limit, up to 2 billion

2209
01:42:00,470 --> 01:42:01,500
or negative 2 billion.

2210
01:42:01,500 --> 01:42:05,330
However, we'll keep it simple, and just return one, if something went wrong.

2211
01:42:05,330 --> 01:42:11,210
Meanwhile, I might then say printf, hello, percent s.

2212
01:42:11,210 --> 01:42:14,040
Type in arg v one, just as before.

2213
01:42:14,040 --> 01:42:17,270
And then, if all is well, return zero.

2214
01:42:17,270 --> 01:42:19,252
So not much new is happening here.

2215
01:42:19,252 --> 01:42:20,960
This program is very similar to the last,

2216
01:42:20,960 --> 01:42:24,680
except instead of saying hello world by default, I'm going to yell at the user

2217
01:42:24,680 --> 01:42:26,540
with this, missing command line argument,

2218
01:42:26,540 --> 01:42:31,040
and then return one to signal to the computer, this program did not succeed.

2219
01:42:31,040 --> 01:42:34,670
And I'm going to return zero, if and only if, it did.

2220
01:42:34,670 --> 01:42:35,405
Yeah?

2221
01:42:35,405 --> 01:42:38,660
AUDIENCE: Why is arg c unequal to zero?

2222
01:42:38,660 --> 01:42:42,990
DAVID MALAN: Why is arg c not equal-- really good question.

2223
01:42:42,990 --> 01:42:46,070
So let me go ahead and change this.

2224
01:42:46,070 --> 01:42:50,810
What is in arg v zero that makes it have two things instead of one,

2225
01:42:50,810 --> 01:42:52,230
if I run David--

2226
01:42:52,230 --> 01:42:53,600
if I run my name, David.

2227
01:42:53,600 --> 01:42:56,030
Well, hello-- let me recompile.

2228
01:42:56,030 --> 01:43:01,630
Make arg v one, or make arg v, dot slash, arg v, hello--

2229
01:43:01,630 --> 01:43:02,780
no, wrong program.

2230
01:43:02,780 --> 01:43:03,890
Make exit.

2231
01:43:03,890 --> 01:43:05,600
Sorry.

2232
01:43:05,600 --> 01:43:07,490
There's no program to detect that mistake.

2233
01:43:07,490 --> 01:43:10,190
Dot slash exit, missing command line argument.

2234
01:43:10,190 --> 01:43:15,530
However, if I do exit David, now I see-- oh, did I run arg v before?

2235
01:43:15,530 --> 01:43:16,310
Check the tape.

2236
01:43:16,310 --> 01:43:17,450
Hello dot exit.

2237
01:43:17,450 --> 01:43:21,110
So in arg v, the first word you type, the program's name,

2238
01:43:21,110 --> 01:43:22,910
is stored at arg v zero.

2239
01:43:22,910 --> 01:43:26,450
The second word you type, the first argument you care about,

2240
01:43:26,450 --> 01:43:28,370
is an arg v one.

2241
01:43:28,370 --> 01:43:29,690
And that's why arg c is two.

2242
01:43:29,690 --> 01:43:32,648
I literally typed two words at the prompt, even though only one of them

2243
01:43:32,648 --> 01:43:36,050
is technically an argument I care about.

2244
01:43:36,050 --> 01:43:39,448
So where can we go from this?

2245
01:43:39,448 --> 01:43:41,990
So we're going to use this now to solve a number of problems,

2246
01:43:41,990 --> 01:43:43,407
that of readability, for instance.

2247
01:43:43,407 --> 01:43:44,960
You might recall this paragraph here.

2248
01:43:44,960 --> 01:43:45,860
Mr. And Mr. Durst--

2249
01:43:45,860 --> 01:43:47,660
"Mr. And Mrs. Dursley of number 4 Privet Drive

2250
01:43:47,660 --> 01:43:50,490
were proud to say that they were perfectly normal, thank you very much.

2251
01:43:50,490 --> 01:43:52,490
They were the last people you'd expect to be involved in anything

2252
01:43:52,490 --> 01:43:55,790
strange or mysterious, because they just didn't hold with such nonsense,"

2253
01:43:55,790 --> 01:43:56,495
and so forth.

2254
01:43:56,495 --> 01:43:59,120
So from the very first Harry Potter in the Philosopher's Stone,

2255
01:43:59,120 --> 01:44:01,160
if you were to run the entirety of that book

2256
01:44:01,160 --> 01:44:05,487
through a program written in C, that analyzes its readability,

2257
01:44:05,487 --> 01:44:07,820
you would be informed that the grade level for that book

2258
01:44:07,820 --> 01:44:09,260
is estimated at grade 7.

2259
01:44:09,260 --> 01:44:13,760
So you can read it well and comfortably if you're a human in grade 7.

2260
01:44:13,760 --> 01:44:15,090
Why is that the case?

2261
01:44:15,090 --> 01:44:18,710
Well, the program, as is conventional in software,

2262
01:44:18,710 --> 01:44:21,498
would analyze like the number of words in the sentence,

2263
01:44:21,498 --> 01:44:24,290
the lengths of your words, how big the words are that you're using.

2264
01:44:24,290 --> 01:44:26,082
There's a number of heuristics that are not

2265
01:44:26,082 --> 01:44:31,272
perfectly correlated with readability, but they are--

2266
01:44:31,272 --> 01:44:33,230
they're not perfectly aligned with readability,

2267
01:44:33,230 --> 01:44:35,220
but they do correlate with readability.

2268
01:44:35,220 --> 01:44:37,303
So the bigger the words, the bigger the sentences,

2269
01:44:37,303 --> 01:44:41,090
and more likely the older you should be to actually read that text effectively.

2270
01:44:41,090 --> 01:44:42,670
Now something like this.

2271
01:44:42,670 --> 01:44:45,080
"In computational linguistics, authorship attribution

2272
01:44:45,080 --> 01:44:47,540
is the task of predicting the author of a document of unknown authorship.

2273
01:44:47,540 --> 01:44:50,720
This task is generally performed by the analysis of style metric features,

2274
01:44:50,720 --> 01:44:52,280
particular characteristics of an author's writing

2275
01:44:52,280 --> 01:44:54,655
that can be used to identify his or her works in contrast

2276
01:44:54,655 --> 01:44:56,055
with the works of other authors."

2277
01:44:56,055 --> 01:44:58,430
If you were to run that through the same program and see,

2278
01:44:58,430 --> 01:45:00,138
otherwise known as Brian's senior thesis,

2279
01:45:00,138 --> 01:45:04,610
you would get grade 16, because he uses a lot bigger words, longer sentences,

2280
01:45:04,610 --> 01:45:06,110
more elegant prose.

2281
01:45:06,110 --> 01:45:10,293
It turns out that this program in C to which I allude, will exist in a week,

2282
01:45:10,293 --> 01:45:12,210
because for the first problem on the problem--

2283
01:45:12,210 --> 01:45:14,168
one of the problems on the problem set will you

2284
01:45:14,168 --> 01:45:16,010
implement a readability analysis.

2285
01:45:16,010 --> 01:45:19,040
But it all boils down to taking in text as inputs, such as Harry

2286
01:45:19,040 --> 01:45:22,250
Potter or Brian's text, analyzing the lengths of the words,

2287
01:45:22,250 --> 01:45:26,295
looking for the spaces, and so forth, and deciding how advanced that text is.

2288
01:45:26,295 --> 01:45:28,295
But we're also going to challenge you with this,

2289
01:45:28,295 --> 01:45:31,310
this notion of cryptography, the art of scrambling information

2290
01:45:31,310 --> 01:45:32,570
to keep it private.

2291
01:45:32,570 --> 01:45:35,450
And cryptography might work, just like in week zero,

2292
01:45:35,450 --> 01:45:38,330
as having inputs and outputs, where the input is the message you

2293
01:45:38,330 --> 01:45:40,410
want to send safely to someone else.

2294
01:45:40,410 --> 01:45:43,452
The output is some kind of scrambled version thereof, the equivalent of,

2295
01:45:43,452 --> 01:45:46,160
like in grade school, maybe writing a little love note to someone

2296
01:45:46,160 --> 01:45:48,243
and passing it through the class to the recipient.

2297
01:45:48,243 --> 01:45:50,452
And you don't want the teacher, if they intercept it,

2298
01:45:50,452 --> 01:45:53,780
to be able to understand the message, so it's somehow scrambled or encrypted,

2299
01:45:53,780 --> 01:45:54,710
so to speak.

2300
01:45:54,710 --> 01:45:56,748
In cryptography, the input is called plaintext,

2301
01:45:56,748 --> 01:45:58,290
and the output is called cipher text.

2302
01:45:58,290 --> 01:46:02,180
So if we were, for instance, to say something like hi exclamation point,

2303
01:46:02,180 --> 01:46:05,540
recall that, that of course can be represented in Ascii as three numbers--

2304
01:46:05,540 --> 01:46:07,670
72, 73, and 33.

2305
01:46:07,670 --> 01:46:10,130
Well, it turns out, if we want to send a fancier message,

2306
01:46:10,130 --> 01:46:13,580
a longer one, we can just look at all of those numeric equivalents,

2307
01:46:13,580 --> 01:46:16,520
do some mathematics on them, and effectively scramble them.

2308
01:46:16,520 --> 01:46:17,600
But we need a key.

2309
01:46:17,600 --> 01:46:21,140
You and I need to decide in advance, sender and recipient, what

2310
01:46:21,140 --> 01:46:24,290
is the secret we're going to use to kind of jumble the letters up

2311
01:46:24,290 --> 01:46:27,230
so as to encrypt it without a teacher or a classmate

2312
01:46:27,230 --> 01:46:28,820
intercepting and decrypting it.

2313
01:46:28,820 --> 01:46:32,750
Suppose, very simply and probably foolishly, our secret number is one.

2314
01:46:32,750 --> 01:46:36,490
You and I both green one is our secret and we're going to use one to scramble

2315
01:46:36,490 --> 01:46:38,630
the information as follows.

2316
01:46:38,630 --> 01:46:42,490
If I want to say, I love you, and send this across an insecure medium,

2317
01:46:42,490 --> 01:46:44,620
like a roomful of people, well I might first

2318
01:46:44,620 --> 01:46:47,500
convert each of these letters to their Ascii equivalents

2319
01:46:47,500 --> 01:46:50,800
just by looking them up on AsciiChart.com or doing it in code,

2320
01:46:50,800 --> 01:46:54,010
then I might go ahead and start adding one to each of those letters,

2321
01:46:54,010 --> 01:46:57,040
because that is the secret on which you and I have agreed,

2322
01:46:57,040 --> 01:46:59,020
and then I'll convert it back to the characters

2323
01:46:59,020 --> 01:47:03,280
as by casting it from an int to a char so that the message I actually

2324
01:47:03,280 --> 01:47:06,760
write on my piece of paper, or send in my program, looks like this.

2325
01:47:06,760 --> 01:47:10,210
So that if a teacher or a classmate intercepts it, they see this,

2326
01:47:10,210 --> 01:47:12,070
but you know, I love you.

2327
01:47:12,070 --> 01:47:16,160
And so, with that said, will you be doing your readability and cryptography

2328
01:47:16,160 --> 01:47:16,660
and more?

2329
01:47:16,660 --> 01:47:20,010
That's it for week two, and we'll see you next time.

2330
01:47:20,010 --> 01:47:20,926


